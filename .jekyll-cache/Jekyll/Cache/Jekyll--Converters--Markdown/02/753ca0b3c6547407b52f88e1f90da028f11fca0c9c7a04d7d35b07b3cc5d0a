I"Y<h2 id="item-1-consider-static-factory-methods-instead-of-constructors">ITEM 1: Consider static factory methods instead of constructors</h2>

<p>属于 “创建和销毁对象” 那章。静态工厂方法跟“四人帮”设计模式里面的<em>工厂方法</em>模式是不同的。<!--more--></p>

<h3 id="静态工厂方法的好处">静态工厂方法的好处</h3>

<ol>
  <li>
    <p>有名称，容易读。</p>
  </li>
  <li>
    <p>静态工厂方法不一定每次都创建新实例。有点类似<em>享元</em>模式（<em>Flyweight</em> pattern)。如果创建对象代价比较大，使用静态工厂方法可以提高性能。这种类被称为<em>实例受控</em>（<em>instance-controlled</em>）类。可以确保<em>单例</em>（<em>singleton</em>）或不被实例化。还有让<em>值不可变</em>类（immutable value class）保存没有两个相等的实例存在。</p>
  </li>
  <li>
    <p>可返回任意子类的对象。</p>
  </li>
  <li>
    <p>静态工厂方法返回的对象可以因调用参数不同而不同。</p>
  </li>
  <li>
    <p>返回的对象可以先不存在，这就是 service provider framework 的基础，例如 Java Database Connectivity API (JDBC).</p>

    <p>服务提供者框架的三个主要组件：服务接口（service interface），代表实现。服务提供者注册接口（provider registration API），用于注册服务的实现。服务访问接口（service access API），客户端用来获取服务实例的方式。以 JDBC 为例子，<code class="highlighter-rouge">Connection</code> 就是服务接口， <code class="highlighter-rouge">DriverManager.registerDriver</code> 是服务提供者注册接口， <code class="highlighter-rouge">DriverManager.getConnection</code> 是服务访问接口，然后 <code class="highlighter-rouge">Driver</code> 是服务提供者接口。</p>
  </li>
</ol>

<h3 id="静态工厂方法的缺点">静态工厂方法的缺点</h3>

<ol>
  <li>只提供私有静态工厂方法（没有 <code class="highlighter-rouge">public</code> 或 <code class="highlighter-rouge">protected</code> 构造器）的类不能被继承（派生），不过有时候是好事，因为鼓励使用组合而不是继承。</li>
  <li>比较难找，因为不想构造器那样出现在 java doc。</li>
</ol>

<h3 id="一些静态工厂方法的例子">一些静态工厂方法的例子：</h3>

<ul>
  <li>
    <p><strong>from</strong> —— 一种类型转换方法，取一个参数并返回此类型对应的实例，例如：</p>

    <p><code class="highlighter-rouge">Data d = Date.from(instant);</code></p>
  </li>
  <li>
    <p><strong>of</strong> —— 一种聚集方法，取多个参数，返回此类型的实例，整合了这些参数的值，例如：</p>

    <p><code class="highlighter-rouge">Set&lt;Rank&gt; faceCards = EnumSet.of(JACK, QUEEN, KING);</code></p>
  </li>
  <li>
    <p><strong>valueOf</strong> —— 更详尽版本的 <strong>of</strong> ，例如：</p>

    <p><code class="highlighter-rouge">BigInteger prime = BigInteger.valueOf(Integer.MAX_VALUE);</code></p>
  </li>
  <li>
    <p><strong>instance</strong> 或 <strong>getInstance</strong> —— 返回参数描述的实例，但不一定得到同样的值。例如：</p>

    <p><code class="highlighter-rouge">StackWalker luke = StackWalker.getInstance(options);</code></p>
  </li>
  <li>
    <p><strong>create</strong> 或 <strong>newInstance</strong> —— 像前一个，但是保证每次都返回新实例。例如：</p>

    <p><code class="highlighter-rouge">Object newArray = Array.newInstance(classObject, arrayLen);</code></p>
  </li>
  <li>
    <p><strong>get<em>Type</em></strong> —— 像 <strong>getInstance</strong> 但是在不同类里面，<strong><em>Type</em></strong> 是静态工厂方法返回的对象类型，例如：</p>

    <p><code class="highlighter-rouge">FileStore fs = Files.getFileStore(path);</code></p>
  </li>
  <li>
    <p><strong>new<em>Type</em></strong> —— 像 <strong>newInstance</strong> 但是在不同类里面，<strong><em>Type</em></strong> 是静态工厂方法返回的对象类型，例如：</p>

    <p><code class="highlighter-rouge">BufferedReader br = Files.newBufferedReader(path);</code></p>
  </li>
  <li>
    <p><strong>type</strong> —— <strong>get<em>Type</em></strong> 和 <strong>new<em>Type</em></strong> 的更精简替换，例如：</p>

    <p><code class="highlighter-rouge">List&lt;Complaint&gt; litany = Collections.list(legacyLitany);</code></p>
  </li>
</ul>

<h3 id="总结">总结</h3>

<p>通常使用静态工厂方法更好，所以可以考虑一下，而不是只想到公有构造器。</p>
:ET