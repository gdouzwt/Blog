---
typora-root-url: ../
layout:     post
title:       响应式变革 Reactive Evolution 2019 ~ 2020
date:       '2019-11-21T08:10'
subtitle:   根据龙之春 Josh Long Devoxx Belgium 2019 演讲整理
author:     招文桃
catalog:    true
tags:
    - Reactive Programming
    - 响应式编程
    - Spring WebFlux
    - Spring Cloud Gateway
    - RSocket
    - R2DBC
    - Kotlin
---

## 响应式变革第一部分——构造服务端

在比利时的，那里有些讲荷兰语有些讲法语，称为佛兰芒语。

### 

### 开始正题【响应式编程】

​		响应式编程不是一个特别新的话题，不是新的概念。大概在 5 年前就开始讨论这个话题了。它更多地应该是一个答案。对更老的问题的答案，一个已经存在很久了的问题——如何扩展系统，可以支持更多用户，处理更多进入系统的请求。

​		响应式编程是一种表达方式，一种新的答案。而答案的本身，并不是很新颖。响应式编程，更多是关于线程的使用效率。是关于让你的系统，让你的软件，在 JVM 上更好地处理线程的一种方式。这是很重要的，因为线程代价高，JVM 的线程开销大。

​		所以现在问题是，为什么我们为什么关心这个，对吧？我们支持更多用户的动机是什么？问题不是特别难回答，我相信你们能够指出一些方面。在过去 10 年 或是 12 年促使我们扩展的原因，并处理更多的用户，并不难找到这类东西。我才用这东西自拍了， iPhone 对吧？还有安卓设备，各种这些智能设备，这又促使了一大波，还有物联网的浪潮。这些联网设备随着我们连接更多的东西到互联网，随着我们逐步地迁移到一个HTTP 请求的世界
并加上 CSS 和 JavaScript 构成一个视图的年代。我们从那个世界。迁移到了另一个世界，现在单独的一个用户界面，可以由十几个网络请求的，一系列的网络请求。最终才组合组成你看到的视图，对吧？而且这对于不同的连接设备都不同，当我们进到新的世界。现在一个用户界面又十几个网络请求组成，我们后端的服务变得更加棘手。尤其是这些服务没花什么时间，产生结果原因是正确的传统构建软件的方式，在JVM构建软件的传统方式一直比较简单。当请求进来的时候你得到一个 `java.net.ServerSocket`，监听在 8080 端口并且当这些请求进来的时候
`ServerSocket` 接受客户端进来的 socket 请求然后客户端将载荷发送到服务器，服务器接收给与 `SeverSocket` 和 socket 都有 `InputStream` 和 `OutputStream`然后他们开始相互通信了。它们来回传输字节通过网络。然后，当那个请求到达服务器，在传统的服务器 15 年前。那是非常简单的 `while` 循环一个 ：

```
while(serversocket.accept()==true)
```

接受请求，创建一个新线程，在线程中你从请求中读取输入的字节。你在输出流产生响应，然后你发送回去，产生一个响应需要什么？现今，要做什么产生一个响应
嗯 你要做很多事情 你要调用数据库
你要调用 Web 服务
你要调用 额 其它的 API
传统的做法使用输入输出流
所以全部的while循环都在这个线程
你发出一个请求 并等待数据返回
只能停在那里等 等 等
你在等待这些字节返回
同一时间 你在那个线程做什么
没事干 只是等 空闲状态
然后 这就是真正的犯罪
这是真正的问题
因为占用线程不做任何事情
这是非常不高效的线程使用方法
线程代价高 我们不能无限地创建它们

### 传统的方式

对吧 所以这是第一个问题
希望还是有的 对吧
在视野之内
几年内 幸运的话 我们有望迎来纤程 对吧
我不知道什么时候才有 算他两年吧 最快的情况
但愿这能让你创建更多的线程
另一个问题 当然
假设你部署
最新版本的 JVM 到生产环境
我是这样做的
你也应该这样做
如果不
我可以看到你们一些人有点不自在
所以我就不问了
你们还有多少人还在用 Java 8 不过……
我们可能
哦哦 我看到你们有些人不自在了
好不管怎样
关键是假设你们有
使用最新版的 Java
并且假设我们在未来两年或三年有纤程之类的
额 然后
现在我们需要解决另一个问题 构建分布式系统
现在我们思考数据跨越网络的情况
考虑服务之间通过线路交互
是傻子的想法傻子的做法
去认为当我们请求的时候立即就能获取数据
就好像数据在打个响指就在那了
对吧
傻子才这么想
才会认为 服务响应迅速
快捷 或者是可靠的
而且一直是高可用的
而且不会出错
当构建分布式系统这些交互情况是常见的
而且这种方式 这种传统方式 读取下一个字节
并不断地等待下一个字节
忽视那样的现实
忽视网络是不稳的
不稳定的 有时候还有问题的地方
数据可能会丢包
所以我们需要更好的范式 更好的沟通方式
用于处理这样特别的现实情况
所以 我们面对的是…… 噢
好东西
我们面对这样的需求
构建更好的系统 构建更好的软件
要支持它
目前 我们使用响应式编程
响应式编程 使得我们可以
处理更好利用我们线程的需求
并允许我们编写更多消息传递风格的代码
将世界想象成为一系列的异步事件
事实确是如此 世界是异步的 是充满事件的
不是一系列的同步数据 你随意能获取想要的
所以 我们有这样的目标 目标是我们有一堆线程
随着请求进来
我们不想占着线程等待下一个字节到来
我们得有些转变
我们要改变传统方式
处理数据流的方式
而不是坐在那里等待数据到来
随着我们将数据从输入流取出来
而不是这样操作
让我们切换到另一个世界
比如说 我们等待数据推送给我们
我们等待数据的生产者发布数据给我们
然而这是很难的概念对吧
想一下我们所做的事情可能阻塞线程
我们有什么东西是阻塞线程的
额 当然啦 有很多显而易见的事情
例如占用CPU的任务
像计算斐波那契数列
或者是加密，挖矿对吧
额 额…… 安全之类的东西
因为那需要加密
会符合这一类型
额…… 运行 Slack
对吧 需要很多CPU 资源
基本上全占用了 对吧
你不希望这些东西独占 CPU
这是很显然的 而且你不能解决这个问题
使用响应式编程
有些东西就是要占用 CPU 的
但是有些东西是 IO 密集的 受限于输入输出的
然后这些东西是天然适合
我们现时所作的一些修改
你发现 我们不需要做同步的
阻塞的输入输出
没理由让我们查询数据
从输入流 我们可以让数据准备好给我们
我们可以告诉操作系统 看这里操作系统
这是一个文件描述符
它有数据但是目前还不可用
请给我一个消息 给我一个中断
回调我
当数据可用的时候
对吧 这是操作系统很容易做到的事情
它可以查询可以管理
它可以高效地选择
成千上万的文件描述符
但它不能创建成千上万的线程
这就是问题所作
所以更好的情况是 嘿操作系统
给我一个回调当数据可用的时候
我会当它现在可用的状态继续工作
而不是更早的时候 同时
之前我用于询问数据的线程
我已经离开了那个线程
并让操作系统的其它用户使用那线程做其它事情
这仍然不是什么新东西
它有个老术语叫多线程协作
很简单的概念
我们说 嘿
我将会这样写代码
去告诉系统
我什么时候用完这个线程
我会表达更加明确
我会多花些功夫使得
那是一个多租户的系统
这是一个很简单的概念
响应式编程出现的原因是
给我们一种编程范式、模式
去让我们这样的表达这个世界
可以让我们这样说 嘿
我请求了这个数据 但是它还不存在这里
这是异步的 它现在还不在这里
还未被解决 但最终会到来的
而且 可能不止一个值
这就是事情变得有点不同的原因
我要怎么说 我有一个值需要获取
使用现在的 JDK
你说我有个 Future
Future<String> 或 Future<Integer> 随意啦
甚至 CompletableFuture 更好
会给你一个值

### 说完传统的多线程编程模型开始引出响应式话题

等了这么久还缺的是 一种方式表达
我有一连串的异步解决的值
所以我们需要一种范式 一种计算方面的模式
允许我们去描述这样的一种数据
这就是 Reactive Stream 规范的作用
Reactive Stream 规范是一些通用的底层接口
由这些组织提出 Pivotal, Netflix, LightBean, eclipse 基金会还有其它的
这是 4 不同的接口和一个类
给你能力
异步的数据串流
而且它们是非常基础 非常非常基础的
它允许我们说 嘿 有数据进来了
除此以外并没有给你什么了
它不支持我们常用的操作
我们处理数据时期待的操作
我将它们比作数组 就像 Java 的数组
你们有多少人写代码用到数组的
大多数时候
是的 数组常常用到 对吧
通常你不会这样做的
如果我要描述一系列数字或什么的 我使用 List
或者 Set 随意吧 对吧
那会使用数据类型
因为这样处理数据方便惯用
我可以扩展它们 可以操作它们
可以流式操作 可以过滤它们之类的
所以这是非常常见的抽象 对吧
Java 数组不太好用
你们这些不看的
你们大概有二十人
举手了 然后我说 “大多数时候”
大部分人放低手了
因为大部分人没有经常使用数组
我们使用更高层次的数据类型
这里也有同样的需求
对于这些响应式流
它们非常基础 作为一种基石
但我不会在生产环境只是要这些
我需要操作符
使用，组合处理流数据
更加容易 这就是Project Reactor 的意义
Project Reactor 来自 Pivotal
它类似于 RxJava
它为你提供了这些好用的操作符
好 我们完事了吗？
可以回家了吗？
还不行 当然不了，对吧
这是我们迎来另一个问题的情况
假设，只是假设
出于某种原因
只是假象 好吧 好吧
我不承诺任何事情 但想象一下
在一条时间线上
技术
你用着熟悉的技术
了解的并使用了很多年 几十年的 对吧
想象这些技术例如 Spring 例如 Hibernate
想象由于某种原因
这些你们已经熟悉的技术
不能理解
java.util.Collection
或者是 java.util.Set
java.util.Map 之类的
假设想象一下 例如
只是假想一下
你想要映射一对多的关系
在 Hibernate 的实体里面 使用 java.util.Set
想象一下 当你这样做的时候 Hibernate 不仅
抛出异常
想象一下你这样做了
Hibernate 不仅抛出异常
它实际上还渲染一个纯文本组成的竖中指
在控制台
并引起你机器的内核恐慌
帮你关机
它非常讨厌
java.util.Set
你还会继续在Hibernate 继续用 java.util.Set 吗？
如果你知道会出现这样的情况
当然不会啦 对吧
你不会弃用 Hibernate
如果你想做的是同步地阻塞
并映射对象到JDBC的数据结构
没有比这更好的了
那是现有最好的东西了
你不会重造 Hibernate 的轮子
你只是使用阻力最小的方式而已
如果这意味着使用其它数据类型
那就使用吧
因为那会让你可以到生产环境
最终那才是最重要的
它可以让你使用你熟悉的数据访问技术
去到生产环境 所以我们有同样的需求
我想要处理的我的日常需求
我希望可以构建数据访问层
能支持安全 Web 服务
还有其它的作为开发者的日常
开发交付到生产环境的东西
但我不想放弃所有那些
只是为了支持响应式类型
所以这就是 Spring 团队的第一步
在 2017 年 我们发布了
Spring 框架 5.0
5.0 是首个版本整合了
Pivotal Project 原生地
与此同时还有 Reactive Stream 规范
在此基础上我们构建了响应式 Web 运行时
 我们整合了对
Spring Data 的支持
还有 Spring Security 还有 Spring Boot 和 Spring Cloud
所以今天在 2019 年
快到 2020 年了
我们可以构建端到端的微服务系统
在Sping的生态系统

### 讲响应式数据流规范 Project Reactor 背景

朋友们 那就是我们今天要走的旅程
一起来 那么
让我们看一下
为了做这件事
我要到
网络上我第二喜欢的地方
排在生产环境之后
在网上我最喜欢的地方 当然是 生产环境
我爱生产环境
你也应该爱生产环境
你应该尽早到生产环境 越频繁越好
带上家人和孩子 那里天气很好 那是地球上最欢乐的地方
那里比迪士尼乐园还好
是的 即使我很了解迪士尼还是这样说
不过如果你未到过生产环境 你可以从这里开始
start.spring.io
如果你需要灵感
在早晨喝杯咖啡或茶之前
start.spring.io
如果你的孩子
休息不好 睡不着
start.spring.io
如果你消化不良
经历一晚上酗酒之后
还有 PHP
start.spring.io
我们将在这里构建一个应用
使用 start.spring.io
有些注意事项 首先
暗色模式
这很牛逼 额……
第二 我们要构建一个服务称为 reservasion-service
额 我们要构建
一个新的应用
我想充分利用这些选项
这里有一些选择我们需要指定的
这边有两种不同的选择
在我们进入下一步之前要确认的
而我只是想花点时间讲一下这些选项
人们有时候会感到疑惑
所有这些
所以让我们讲一下 首先
我们有打包方式的选择
当下我们应该怎么打包应用
在2019年
人们经常为此问题烦恼
让我冷静地好好说
在这里解释何时何地选择哪个选项
如果有些奇怪现象
物理反常现在 恐怖的灾难
戏剧性的 时空意外
你突然发现你被传输到很远很远的过去
那么选择 .war
不过如果你在这里
跟我在一起
在 2019 年
快到2020年了
那就选择 .jar
这是重要的一部分
是我的顶层设计 指导
个人哲学 —— make jar not war!
还有
你能做的有很多
选择在于你
但我鼓励你选择默认的
好了 然后我们要选择 Java 版本
你现在想要用什么版本的 JVM ？
朋友们 这些选择中只有两个是正确的
我给你点提示
一点提示 哪个是不正确的
是这个
这是不正确的版本 朋友们
就在这里
就在这里 你看到吗
这是说 8 吗？
这是错的
这边你有两个选择 Java 13 和 Java 11
Java 11 是目前的长期支持版
这是个可接受的答案
但在我看来
因为这是目前
面向生产环境的 受支持的 Java 版本
因为它有很好的新特性 和好的性能提升
我会选择 Java 13
这是正确的事情
我的朋友们 不仅是技术上来说
道德上来说也是
道德上
你准备回家了吗
以生产环境使用 Java 8 的事实去面对孩子？
你要展开这这样的对话吗?
我认为你不会
所以现在 使用 Java 13
然后我的朋友们
我们有选择
关于依赖的选择
我们需要用什么依赖
我们加入响应式 Web支持
添加入 Lombok
添加 Reactive MongoDB
然后加入 R2DBC
加入 PostgreSQL 支持
加入 RSocket 支持
然后我认为我开心
有这些选项
有了 Reactive Web, Lombok
Reactive MongoDB, R2DBC, PostgreSQL
还有 RSocket
有了这些 我就点生成
这会给我一个全新的项目
我会在我的 IDE 打开
用什么 IDE 没关系
我使用... 一切都会顺利运行的
现在我将它打开
现在你能看到那字体吗
比我还高
好吧 我们将字体设大一点
以防万一好吧
那么
字体
喔
OK
Font
Chrome 在运行吗？ 是的
我就知道是
好了
好吧
这是
我在上台前刚构建过这个
好吧
谁在下种子？
噢 嗯 好了
快行了 好

### 开始写代码

额 我们现在有
一个全新的项目 Spring Boot 项目
最新最好的Java版本
我要注释掉
一些我现在还不需要的东西
我去掉这些，我不需要这些
我要注释掉
R2DBC 的依赖
并注释掉 R2DBC 本身
我们留下
设置自动导入
现在我的选择满足了
让我们去到我们的应用
我们的应用只是一个main方法入口
我们应用程序的入口
只是一个全新的应用
它所作的全部只是一个普通的 Spring Boot 应用
我们所要作的是写数据到数据库
通过创建一个实体
我要像这样地创建一个实体好吧
这个实体
这是个实体 但是需要
你懂得 需要一些常规东西
getter 和 setter， 我需要 toString
我需要 equals 和 hashCode
我需要构造器等东西
还有这个
OK 另一个构造器 好
好东西 对吧 我需要这些 这就是 Java
额 这非常现代
非常现代
如何现代... 
我不那么做
那很糟糕
我是用 Lombok
Lombok 是一个编译时注解处理器
Lombok 使得我可以整合
getter 和 setter
toString, equals, hashCode 之类的
在此之上我加入 Spring Data 的 @id 注解
它会告诉 MongoDB
这个文档 这个实体 这个对象
我在这里描述的
将会被持久化
到一个单独行 称之为集合
在 MongoDB 里面
在那个世界 在MongoDB 里的叫法
一个记录被称为文档
所以这是一个文档
在一个集合中
这个文档有一个 id 字段
还有name字段 它们都在这里描述了
这基本上就是我要做的
让这个能用
现在我要创建一个
repository
repository 只是一个东西
会将数据存储到数据库的东西
会处理无聊的
到掉土渣的
读/写 更新/删除 的生命周期方法
支持处理我们数据的方法
这个 repository
支持所有可能的操作
在这你可以看到
所有这些常用方法
你在生产环境需要的
并将任务完成 例如save, saveAll
count, delete, findById
检查是否存在
诸如此类的
所有这些方法我猜想
对于你们来说应该很熟悉了

### 开始讲 Reactive Streams Spec

一些现在还未熟悉的是
是参数的类型
第一个参数是一个 Publisher
这个Publisher 你可以看到
来自于
org.reactivestreams:reactive-streams
这是一个Publisher
产生 0 到 n 个记录
对吧
是一个产生记录的Publisher
异步地 不受限地
输出到一个订阅者
Subscriber
当它首次订阅
它会给一个指针到一个Subscription
在这里看到我们有这个Subscription
等下我们再回头看这个 Subscription
稍后再看
这个可以说是最重要的部分了
当数据到来的时候
1 2 3
十亿，万亿
无限的数据 当它们到达的时候
onNext 方法会被调用
是在onNext 方法里面
我们才能 消耗并处理到达的数据流
那些来自Publisher 的数据
如果遇到错误
当出现错误
onError方法会被调用
就是在这个onError方法我们有机会
去 额…… 处理一些错误
请记住 错误
可在任何地方发生
但是堆栈追踪信息
那个 try-catch 机制
是限制在单个线程的
所以我们而是通过这个机制传播错误
因为请记住 我们的代码
会轻易地从一个线程切换到另一个线程
随着我们在响应式管道中执行代码
所以我们不能假设它们在同一个地方
所以这是非常能用的，自然的方式去处理数据
我们将错误作为另一种数据
而且这也是多线程代码中处理错误的自然方式
最后当我们处理完的数据
onComplete方法会被调用
就是在onComplete 方法里面我们知道
我们无异常地完成了所有事情
你懂得 没有错误
现在 让我们回到这个 onSubscribe 方法
这个我之前说了 应该是最重要的部分了
这个订阅
对于这个订阅者是唯一的
每个订阅者
当订阅到一个发布者
获得一个新的订阅
这个订阅
代表链接
联系 会话可以这样想的话
存在于生产者于消费者之间的
Subscriber 和 Publisher
就是在这个订阅当中
消费者或者订阅者才可以请求
更多的数据或者
另一方面 去取消
数据的产生
所以这是很重要的
订阅者
通过使用订阅
控制消耗的速率
订阅者说 嘿 我在要多十个记录
然后 哇啦
如果有多十个记录的话
就会发给订阅者
但是不会给多 而且时间也不能确定
对吧
在规范里面没有提到这十个记录
会在未来一秒到达之类的
你可能在十年获得十个记录
你不知道 对吧
未来十年你可能每年得到一个记录
是没有保证的
或者你在下一纳秒就得到了十个记录
还是 没有保证的
所以你选择一个数字
那是 一个你可以想象到的
同一时间舒适地 安全地处理
或接近于同一时间
对吧
这是很重要的
有你掌控
消耗的速率
你控制发布者的速率
给你数据的速率
这意味着 如果你受不了
如果你的订阅者 消费者
受不了这么多数据
那是谁的错？
那是你的错
其实这还好
我宁愿你能掌控自己的命运
而不让过于积极的发布者主宰我命运
对吧
所以这给我了这种能力
它给我了数据的客户端
去管理控制流的能力
我控制数据流
这称为
客户端管理的流控制
这 绝对不是什么新概念
对吧
自从同一个网络中有一个计算机和另一个
我们就有了这个概念 流控制
确保方程的一端
产生数据不会比另一端快
绝不是什么新概念
新的东西只是
现在我们在这个概念套了一层表面 API
作为顶层的结构
这是我们可以在 API 显示地做的事情
好吧？
如果我们想要取消
取消数据流
我们同样也可以 这也是很重要的
你不希望卡在一种情形 无法阻止数据太多
流控制
在响应式编程的世界
有时候 多亏营销
被称为 背压式
如果你有听过背压式这个词的话
你可以将其与客户端管理流控制交替使用
这就是已经存在了数十年的概念 对吧
从世界起源开始
哪个世界并不重要
在过去的 70 80 年里的任何东西 对吧？
好了
现在
哈 我们有
发布者 订阅者 和订阅
那是三个 我说有四个的
第四个类型是
是Processor
而处理器
是一个桥梁 一个水源和水槽
在订阅者与发布者之间
消费者 和…… 生产者
ok？ 就是这样
它就是一个桥梁
这就是完整的 Reactive Streams 规范
早告诉你了 很简单的规范
很荒芜的没什么东西
那里边没有什么值得关心的内容的
非常简单的 API
如果你理解所有这些
就目前来说的话 我毫不怀疑你们都懂了
那么恭喜你们 你们是已认证的响应式编程人员
走 去硅谷
筹集数百万资金
炸了各种傻逼派对
你已经准备好了
你可以的了
你已经走在很多硅谷人之前了
ok 
现在 我们有
这四种类型
正如我所说 它们是非常基础的
非常原始的
够了吗？ 这些类型够了吗？
我会说 额…… 不够
是吧？ 我们没有简单的方式可以
支持操作 例如支持 mapping 和 flatmapping 之类
因此 我们有特别实现
首先是 Flux
Flux 来自 Project Reactor
那是一个 pivotal 的项目
它构建在响应式流规范的 Publisher 之上
你可看到 CorePublisher 最终是实现 Publisher
所以你可以看到 Flux
说到底只是一个 Publisher
但同时它也提供了很多，很多，很多操作符
你看到吗？
很多不同的东西
相信我
你不想花费太多时间在这些代码里
你会晕头转向的
所以 只需相信它做了你期望的事情
你想要做什么
OK? 这些代码支持像map 和 flatmap 的操作
还有 filter 所有这些你需要的处理流数据的东西
Flux 是生产者 但它产生 0 到 n 个值
可能不受限的
OK ?
另一方面  Mono
也是一个发布者
它也有这些很多不同的操作符 很多很多操作符
哇！ 对吧？
你可以使用很多东西
但是 Mono 最多产生一个值
0 个 或 1 个
有点像 CompletableFuture
但它支持背压式
OK？ 而且它是基于推的
区别于基于拉的 
好的 那么这就是CorePublisher
这是一个 Mono 现在我们有这两种不同的东西
问题是公平起见
为什么我使用其中一种？
有人让你渲染一个用户界面
然后给你一个Publisher<Customer>
你怎么知道该怎么做？
如果它们给你一个Mono发布者
那么你就知道这是单个详细记录
他们可能想让我渲染这个记录的详情
对吧 这区别于Flux<Customer>
那样的话 他们可能想让你渲染所有用户概况列表
对吧 其中之一
现在我们有这两种不同的类型
我们可以用它们写一些样例数据到数据库
我要创建SampleDataInitializer
它会监听一些事件
就像这样 @EvenListener
然后我们说
OK？

### 写入数据库 MongoDB

我们要写些数据到数据库
所以 @Component
只是一个普通的 Spring Bean
我们在这里注入 reservationRepository
注入到构造器
我需要 @RequireArgsConstructor
还有参数 定义这些数据
然后我将数据写入到数据库
通过创建一些名字 好吗？
所以我要过一遍
并获取一些名字
这些是在 Spirng 团队的人
显然我在其中 很高兴见到你们 我是 Josh
额... 还有谁？ 我们有 Madhura
她很厉害 我们有
Mark Paul Luke 他也很厉害
我们还有 Olga 她也很厉害
我们还有 四个了
还要四个 我们有……
Spencer 他很厉害
还有Ria 她很厉害
Stéphane 法国的不是荷兰的 虽然他也很厉害
OK 有那么一个人
额 还有
额……
还有谁
还有谁
我说的是在 Devoxx 那位
不是那个 我觉得还有一个在我们 Spring 团队的
尽管 也欢迎他
额…… 不对
额…… 还有谁呢?
还有额 Violetta 好吧？
她也很厉害 好了
现在我们有 
所有这些不同的名字
好吧
好东西
要开始了 就是这些名字
我们要做的是
我们要访问这每一个名字
我们有由名字组成的响应式流
我们要访问每一个 并将它变成
reservation的数据流
OK 所以 reservations 就这样
我们将访问其中每一个
我想要将它们保存到数据库
我可以写 map
我可以这样做 我可以写
然后 我这样做会怎样？
额 map
返回 Mone<Reservation>
OK
而我不想一个 Mono<Reservation>
因为如果我这样做
我会得到这个
Flux<Mono<Reservation>>
不是很理想
而是 我想取出这个内部的发布者
我有个内部的发布者被这个
这个Lambda 的返回值创建的
而且我想压平这个 压平它
所以我只有 Flux<Mono>
为了达到目的 你使用 flatMap
OK？ 就像这样 你可以替换为方法引用
哇啦 这就是你的新的响应式流 好吧
所以 现在这是我们的数据
我要将它存到数据库里
额 我现在有了这些数据
如果我现在运行这个程序
啥都不会发生 你可以看到
这个响应式流
这是我们所说的冷的数据流 什么都还未发生
我们需要实际激活它 对吧
这有一个终端函数需要被调用
我们的终端方法就像
就像 Java 8 Streams API
所以我们说
或者我们可以提供一个消费者或者订阅者 对吧
不要提供订阅者
太多方法了
最近我使用 Consumer
对吧 非常简单
当然这可以是
Java 8 lambda
所以 哇啦
log.info OK？
Log4j2
然后是 reservations
好 这可以是一个方法引用
所以 就是这样 OK？
这就是所有东西
现在 我可以那样做
但在我做之前
让我们想一下会发生什么
我要运行这个程序
它是 额…… 顺便设置一下
我懒 我希望我的代码也是
所以就这样 现在
我要运行这个程序
它会将一串数据
它会创建一个预约流
并会保存每一个到数据库
当我运行这个程序
多次运行 经过连续的迭代
我会看到数据库反映同样的数据
多次
那不是我想要的 我想先清理一下
所以我先删除所有东西
所以让我们写
这会返回一个Mono
那是一个异步的 Void
那么之后
不是订阅
我可以写.subscribe
但那就会很奇怪了
我会有一个嵌套的
我会有一个嵌套的回调
而不是做
嵌套的回调之类的东西
我是用操作符
将各种串联起来
一个发布者到另一个
所以我要写 saved
然后
我想写
找到数据
然后当且仅当
我才想打印日志出结果
所以我实际上
所以我实际上使用操作符去保证
所有东西都删除了
异步地
加个限制
仅当它全部完成了
之后我才管保存数据
仅当那个时候
在我保存了所有东西之后 才管
问数据库取数据
另一个要注意的是
正如我在这串起的管道
你也可以  你更经常
你会在这里串起这些东西
所以在管道的定义
让我们看一下那个代码
因此 OK
现在就是这样
完成了这部分
这就变成
一个 Reservation
OK 这就是
新的管道
保存数据记录的管道
额
老实说
这是正确的做法
对吧
Java
有 var
前缀了
所以
你应该用那个
OK？
现在
额
这边
我的管道
额
你可以看到
这个
这些操作符
让使用
响应式流的类型
非常有用
对吧 而响应式流类型
是 它们是 JDK 8
友好的
对吧
这并不是说必须要用 Java 8
你可以用更早的版本 对吧
顺便说一下 它们是
而且这很重要
它们是
这些等价的类
在 Java 本身里面了
自从 Java 9 开始
所以你可以看到 java.util.concurrent Flow
.Processor
Flow
Flow.Subscription
Flow.Subscriber 还有 Flow.Publisher
这些类型被镜像到 JDK 里面了
已经超过两年了
每行都一样的
唯一不同的只是
包不同
所以当你谈论响应式流
重要的是要注意
你可能说的是 Java 9 的响应式流
或者是
或者是响应式流规范本身
那个给了 Java 9 响应式流灵感的
大部分 API 例如 Reactor
支持从一种切换到另一个
你可以适配
Java Flow 的 Publisher 到
到普通的 Publisher
反之亦然
OK?
现在
让我们运行这些代码 看有什么结果
现在好了
编译
我们看看
你看看
朋友们看到吗
数据在这呢
这行得通
你可以看到这数据
已经反映出来了
在这里并显示在控制台上
这行得通
这当然行啦
因为这是个dmeo
你还期待什么呢？
这总是行得通的
这并没有很有趣对吗
我们可以看到那个 id 是 UUID
那与 MongoDB 里的相匹配
如果我到这里
输入 db.reservation.find({ })；
然后这是数据
你可以看到
Mark Stéphane 等等
所有这些名字
都反映在数据库里
但并没有按照特定的顺序出现 对吧？
对吧？
那是因为
我们使用
flatMap
好吧?
所以 flatMap
压扁了所有东西
但它这样做乱串了结果
一样东西被压扁
如果一样东西解决了
首先
在内部的发布者
那么解释的数据流 saved
可能会是乱序的
我可能有 1 2 3
但我可能得到 3 2 1
然后最后的东西被 flatMap
OK?
这就是
这很有趣 我们有数据在数据库
这能运行 这当然能运行啦 像我所说那样 这是demo
肯定能跑的
这真的不是我在这里的原因
如往常一样

### 扯一下纯文本艺术字

我想重点指出的是这个
这个
是 Spring Boot 的纯文本艺术字
这艺术字花很长时间才弄好哇
在我们Spring 团队有很不少人是博士来的
还有 PhD
这些人的前半生从事核物理
让我很开心地想象
某日某处突然
有个 GitHub issue 说讨厌这东西
所以我们需要有好看的纯文本艺术字
我想你会认同他们做了很好的工作
因此我想花点时间
如此少的时间
谈一下明显的缺陷
在 IntelliJ Jetbrains 产品
即便我是他家粉丝
我认为这个
这个特别的复选框
特别的没远见
你看到这个复选框吗
这边这个
你看到这个复选框吗
这边这个
你看到吗？
你看到吗？
你看到这个复选框吗
就是这个
就在这
那个
如果你想点这个
不要点它
如果你勾选这个复选框
禁止输出
纯文本艺术字
搞什么鬼?
为什么会有这个复选框？
这是一个很傻的特性
甚至没有人想要这样的特性
好吗
不知道为什么会有这个
我做了这情况下一般人都会做的事情
我上网
并哭诉
然而一个让人有信心的消息
来自我的朋友Yann Céborn
这就是 Yann 在这里 噢不在
好吧 推特 干活吧
来了
这个是 Yann Céborn
Yann
是 Jetbrains 公司的开发布道者
这就是他
他给我发这条让人感到希望的消息
我想跟大家分享一下
今天在这里
我认识 Yann 很久了
我们是朋友
而且我很欣赏他
而每次
每次有个新版本的 IntelliJ
他会说，不要担心 Josh 那会在下个版本修复的
一切都会好的 Josh
不用担心 Josh
下个版本就会修复的了 我想你保证
你知道吗，他每次这样说我都想相信他
我相信他 因为我认识他很久了
他是个好人
我想相信他 但是你知道吗？
你知道吗 我就开始在想
可能…… 可能 可能……
他在耍我
好吧
我不感激他了
随意吧 不管怎样
我有很好的纯文本艺术字
人们经常问的是
人们经常问的是 嘿
我可以修改纯文本艺术字吗
我可以将它重写吗
这是很糟糕的想法
你不可能做得比这个好的
有点自知之明
但还是要说
如果那是你的特别想法 那是你想做的事情
那么那是可能的
而且有好几种方式可以做到
你实际上可以创建你自己的纯文本艺术字横幅
我现在就演示这个
去到你的构建目录
我要来这里
停止应用
我们刚过完万圣节 这个吓人的骷髅
OK
有了那个 我现在运行：mvn spring-boot:run
就是这样
哦耶
对吧 好很多了
一些值得欣赏的地方 首先
很好的 纯文本艺术
其次的话
其次的话
喵
然后我最喜欢的部分
很牛逼
我喜欢这个
所以 不管怎样 这是好东西
那是旧的东西 你之前就可以这样做了
这完全不是什么新花样
所以人们经常问的是 我可以做得更好吗
有什么东西 下一代的看起来是怎样的？
然后 朋友们 就是这个了
好吗
我们现在玩的是 gif 动图
现在我用 curl 下载它
OK 
很快的WiFI
OK
然后 运行
很不错
你们可以鼓掌
这太漂亮了
这并不是对我没影响
噢 我没有做清除
并不是对我没有啥影响
但是在一个异步响应式的世界的代码里
这个东西 特别阻塞
对吧
在所有事情中
不过 没错 这似乎增加了三十秒启动时间
我甚至都不关心
完全是值得的
绝对是令人惊叹的对吧
哈 但是还是因为我们只有很少时间
我要移除这东西了 承受不了留着这东西在代码里 
OK 所以我将要
banner.gif
拜拜
mvn clean 拜拜
OK 那么现在我们有很漂亮的纯文本艺术字
我们有很漂亮的纯文本艺术字
我们有数据在数据库里面
目前为止我使用的是 MongoDB
MongoDB 是一个不错的数据库
用于响应式处理
它有不少特性
有点有趣
我认为我已经表达的很清楚了
在响应式的世界里
例如 有些东西称为 Tailable 查询
你可以告诉MongoDB 
我想问你一个问题
我想你一直检查自己
等待一个答案
例如一个小时之后 如果有匹配问题
那么请告诉我，给我一个结果集
解释的结果与断言匹配
而不是一直在拉取数据库
我可以让MongoDB 告诉我
这是一个很自然的事情
在响应式的世界里
嘿 在我的数据仓库里面 你说 你只需要添加 @Tailable
你可以写 我想表达一个
一个查询 额 一个finder方法
findByName
OK ?
这就能用了
你只需要 你需要确保你已经启用 MongoDB
在一个集群模式
这个我还没有设置好 所以我不演示了
但 在那之后你只需要
你可以在你的代码仓库运行这个方法
然后它就会给你发送符合断言的结果
非常有用 额……
MongoDB 是个很好的体验
你可以做各种酷事情
在响应式的世界里 不过
这不是唯一的选择
我们在Spring Data 的世界里
有很多项目现在支持响应式 NoSQL 数据访问
包含但不仅限于 MongoDB
我们有 Cassandra
有 CouchBase
我们有 Redis
这些都已经是 GA 了的响应式支持 NoSQL 选择
但更进一步
我们有 azure cosmos db
现在也支持响应式数据访问了
来自微软的 微软 Azure Cosmos DB
我们有Neo4J 2.0
对吧 新的Rx Neo4J
Spring Data 项目
那也支持响应式NoSQL 之类的数据访问
用于那个图数据库
我们有很多选择
包括已经 GA 的和还在开发的
那正在向前看的
我们甚至有更多 除了我不太能确定可以说的
OK 这些都在出来
但是人们经常问的问题是
OK 这很好

### 讲完 Reactive MongoDB 之后讲 R2DBC PostgreSQL 为例

我可以做 SQL 数据访问吗
这是很多人在问的对吧
所以你们有多少人用 MongoDB 的？
OK 比我想象中的人多 你懂得
五年前 额
你们有多少人使用 Cassandra？
这有 一些人 我可以给你们买啤酒都不觉得破费
额 你们有多少人用 Redis
我猜 这个估计是最受欢迎的了 嗯 是的 OK
但 仍然是 我们讨论的只是少数人
我认为没有 10% 我会说
大概 5% 对吧
所以不是很多人使用那东西
couchbase 呢?
CouchBase 好东西
啊 大概有五六个人啊
OK 你们有多少人有 SQL 存储的？
在你的代码里
呀 OK 大多数人对吧
只是小的大多数 但还是大多数人
所以 问题是在响应式我们怎么支持 SQL 数据访问？
这是非常常见的问题
所以几年前
我们创建了 R2DBC
OK R2DBC
是…… 额 是一个抽象层
支持响应式关系数据库链接
那里有个核心的 SPI
还有数个不同的实现
有不同的驱动 如果你这样想的话
支持对像PostgresSQL等的访问
微软的 SQL Server
还有 H2
现在也有一个第三方项目
支持 MySQL
对吧？
这里还有更多
R2DBC 实现
在路上（正在开发中）
额 Mark
我们还有什么实现
那个我已经提到过了
Spenner Google Cloud Spenner 是的
SAP Hive
所以我们也有这些进来
所以有很多正在开发
还有很多我们不能提及的
那些正在开发中的 对吧
这些是所有不同的 R2DBC 实现
R2DBC
在目前
还有没有 GA
还没有 GA 的
所以我在这一刻
在这一刻
我希望你觉得
持有像对待PHP一样的犹豫怀疑态度
PHP
这边是生产环境
这边是 PHP
他们不应该相遇的
OK?
不过 不过
我刚被通知
这个很快就会 GA 了
那是什么时候？我的朋友
感恩节
不是加拿大的感恩节
OK 那是更加往后的 大概在那一周后
所以这个月的下旬
十一月底 最后一个星期四
额 或者是差不多的时候 我们应该会有 GA 的
那会包含存储过程吗？
没有 所以它会有 基本上
按照我的理解 它会支持大多数东西 除了存储过程
我们会让 API 稳定下来再看看那会是怎么样
在我们实现那个之前
所以你能够像 GA 的风格使用它
去做几乎所有你想做的事情
用这些 API
R2DBC
现在已经可用了 你可以尝试
我们在大会上已经宣布了在华盛顿 DC
在 2018 年的时候
就是那时候我们向公众发布的
所以自我们发布到现在几乎有一年了 对吧
在此之前已经不止一年了
因为我们一直在开发它
我们知道它已经经过考验了 有经过迭代了的
而且它很有用
你总能从现今开始使用它
这就是我们已经做了的 当我在 start.spring.io
在那 Spring Initializr 我勾选了R2DBC这项
OK 所以我要在这里
将它放进来 放进这个
好东西
然后我要注释掉 MongoDB OK?
这会添加依赖 就这样
然后在这里添加这个
然后这里我们需要重构一下代码
还有 我不想建议
通过我的做法 我的说法 你应该按某种方式写代码
然后能够从 MongoDB 迁移到 R2DBC 没意义对吧
我的代码是非常简单
要让它能够跑起来
总的来说 如果你有场景发现 MongoDB 是最适合的话
可能那个应用场景不是 R2BC 或 SQL 适合的
或者等价的替换 好吧
嗯 额…… Spring Data 的目的
并不是支持这种奇葩的可移植性 OK？
所以我有这代码
移除 @Docuemt
额 我的实体 我的东西
我的记录
将会被存储在单调递增的主键
作为数据库中的主键
所以我将它从 String
也就是 UUID
支持 UUID 的改成 Integer 好吗
改完之后 我的代码又可以运行了
我们可以再次运行这个程序
就是这样
它抱怨了 因为我没有
一个指向我的数据库的属性
我要去到我的属性文件 application.properties
然后我要指定
r2dbc url 对吧
所以 r2dbc
url
而这是
这是我们之间的小秘密 OK 你不能告诉别人
这是我小小的生产环境的密码
OK 我们要
指定用户名
现在当然
你会被建议
记住你可以使用环境变量
你可以使用 Spring Cloud 配置服务器  
也可以用 Azure 配置服务器
你可以用很多方式外部化你的用户名和密码
但就我们演示目的
这应该可以用
让我们再次运行这个
OK
然后这是数据
在数据库你可以看到已经反映在那了
额 在控制台
在这里 我们单调递增地
增加主键也反映在数据库上
psql -Uorders orders
\d reservation 
然后可以看到那个模式
有个主键 是integer类型
然后有一个列称为 name 
类型为 varchar
我可以敲入
来吧
好东西
OK 这也行得通
现在我们可以响应式地
我们响应式地写数据到 MongoDB 和 SQL 数据存储
那是好东西
下一个 人们经常问的问题是
你懂得 你说得很好听
但是我还是要保证我数据的完整性的
在此背后我有这些很好的数据存储
有些东西正如我期望那样运行
而在旧的方式却不能这样期望 例如
数据的原子性如何？
我如何保证当我往数据库写入十样东西
全部都写入或者全都不写入 对吧
这就是事务的应用场景
嗯 事务正如你们可能知道的
在传统的那个世界
我们基于 ThreadLocal 对吧？
你创建… 有代码
保存与当前线程相关联的 ThreadLocal
那个 ThreadLocal 存储你的事务的状态
当前正在进行的事务
而 ThreadLocal
在当前线程的任何地方都可以解决
你只需请求
通常只是
通常是某个东西
在框架里面 例如Spring 会为你做这事
它们一直追踪那个 ThreadLocal
并在线程结束的时候清除掉它
并在 ThreadLocal 安装当前事务
当一个新事务开始
那个机制
用于这方面很久了
而那个机制最终是被
PlatformTransactionManager 解决
这只是一个非常简单的接口
给你三个选项
给我一个事务 给我一个定义
提交事务或者回滚
这种抽象允许我们
可以抽象大部分不同的 API
很多不同的 API
都有它们自己相应的资源本地事务
问题是所有这些都假设 ThreadLocal
所有都基于一种概念
那会有一种存储机制附着在当前线程
我可以在往后任意时间解决它
那是非常不好的假设
尤其是在响应式的世界里
对吧 在响应式的世界里
我们不能保证
请求会从一个线程开始 并保持在那个线程
在整个事务的生命周期
所以 而是
我们需要其它东西
所以在 Spring 框架 5.2.x
那是刚刚发布的
我们正在使用的 已经 GA 了
在 Spring 5.2.x
我们发布了一个 ReactiveTransactionManager
所以就算这边的这个东西
而那个 ReactiveTransactionManager
也是继承于 TransactionManager 的
对吧 它们都只是标记性接口
额 它继承了那个接口
并且它有对应的响应式
就如你所见的在 PlatformTransactionManager里面的
包括给我一个当前的事务
或给我一个新的事务
提交事务还有回滚
OK? 这个ReactiveTransactionManager
允许我们做事务的包裹
以熟悉的方式
让我们创建一个 @service
在这里我们添加 ReservationService
而这个服务会让我们可以写数据到数据库里
给定的一系列的数据流的名字
这是变长参数的名字数组
所以为了这样做
我要注入我们的 ReservationRepository
正如往常一样
让它是 @RequireArgsConstructor 就会合成了
由 Lombok 合成
所以我想从那里获取数据
所以 Flux.fromArray...
OK?
这是我的 String 类型的发布者
我将取其中的每一个
我要 map 每个名字都 Reservation 里面
我们在创建某些方面我们之前就有了东西
这是一系列的已经 map 了的数据
我要写 对于它们每一个 我要 flatMap 每个记录
存入到数据库里面
这它传入进去
额 这会给我
我想要验证每一个
我想要写
reservatoin.doOnEach(...
OK 我写 doOnNext(...
所以对于每个reservation
我想要断言测试一下它
我想要判断它
每个记录都有一个有效的名字
给定一个reservation
返回 true 或 false
如果那个名字是由大写字母开始的
getName().charAt(...
0... 然后我要写
然后我断言判断它应该是
一个大写字母
如果不是的话 我想让它失败
测试
好吗
所以我们应该这样做
doOnNext(...
传入 r
然后
the name ... 
OK?
哇啦 这是我已更新了的管道
额 很明显你可以将这些都串联起来
就像我这样 我想做这样的事情
串联起来那样我更容易读
即使我想将它拆开看看正在发生什么事情
然后就是这样
这是已经更新的代码
现在我们有了一个管道基本上是跟之前一样的
问题是
我首先读入数据
然后再当且仅当这样我才做验证
更加重要的是
如果我写两个记录的话会怎样
或者是十个、五个 随意吧
然后第三个记录有个小写的名字
我真的想写入前面两个记录吗？
可能我更希望那是原子性的对吧
这取决于你 额是
风格选择问我我觉得 但是
让我们假设我真的想要原子性操作
我想要保证要么
全部名字都写入
或者全部都不写入
为了支持这个 我是用了
这个新的 ReactiveTransactionManager 支持
所以我能够创建一个
ReactiveTransactionManager 实例
像这样
然后这个需要
这里边有很多不同的实现 顺便说一下
我们有 ReactiveTransactionManager 的实现
在 在 额 R2DBC
给我也给 MongoDB 实现了
还有 Neo4J
对吧 我确信还有一些我忘记了的
至少目前有这些
return new ...
注入来自 R2DBC 的连接工厂
然后 我们想要
创建一个 TransactionalOperator
好吗
而这个 transactionalOperator
需要 ReactiveTransactionManager 才能干活
所以我们创建那个
然后 哇啦 OK？
所以这是我们的事务管理者
嗯 就是这些东西
现在
我想要做的是
是我想要使用那个 TransactionalOperator
例如 private final
TransactionalOperator
然后我会写
this.transactionalOperator...
然后我将整个管道
放到这个事务分区里边
使用这个 transactionalOperator
所以 再次
所有东西在 transactional 里边的
在里面的整个发布者
会在一个事务当中
不在这里边的不会在一个事务里 对吧
我可以用另一种方式
写 @EnableTransactionalManagament
对吧 然后只需要
只要返回的是一个发布者
我只需要用 @Transactional
在这个例子中 它们是一样效果的
TransactionalOperator
很好如果你想要更细粒度的事务控制
什么需要事务控制 而什么不需要
所以现在然我们重写这里的代码
使用那个支持事务的服务
这里 private final ...
好吗
然后
我要写 this.reservationService...
好吗
哇啦
这是我们的服务 这是我们要写入数据库的数据
额……
这会是支持事务的
所以我要写数据到数据库
支持事务地
但我要删除所有在那个事务之外的东西
然后我要读取数据
在事务之外
所以这个
这行可能会显示 0 或 10，我们不清楚 或者 8 实际上
这是我们有的 8 个记录
所以这只是
让我们将
Mark 的名字 暂时地 只是暂时地
我们会将 Mark 的名字改成小写
而他是
操作中的第三个记录 对吧
所以现在
让我们返回到数据库这边
delete from reservation
对吧 现在里边什么都没有了
OK？
现在再次运行这个代码
这些只是日志
反映了这里有异常
但是这个应用没事能运行
额 现在
数据库里什么都没有 OK？
如果我恢复这个
大写字母
我们会看到全部 8 个
噢 就是这些
所以这里有数据 我们事务地
写入数据到数据库
正如我们期望的那样
OK 顺便问下 你们有注意到
这需要更多时间编译吗
相对比应用启动运行时间而言
对吧
我们目前所做的好处是
这是非常快
对吧 那么
我的大多数运行时间 你可以看到
少到 0.9 秒左右
额 ……
这是有帮助的 顺便提一下 我还跑着 Chrome 呢
即便如此 我还能获得那样的速度
可以想象到在生产环境会是怎样吗
肯定会更加好
OK 那么现在
我有这个事务分区
我将数据写入到了数据库

### 演示事务操作

额
我想是时候写一个 HTTP API 了
OK 下一件事就是写一个简单 HTTP 服务
我们写 @RestController
这是非常常见的东西
毫无疑问的肯定见过了 RestController
所以你可以写 Reservation...
ReservationController 就像这样
你可以在这里注入它
可以写 private final ...
OK ?
我将一个 我要将它添加为
构造器注入依赖 使用 @RequiredArgsConstructor
然后我创建一个简单端点
Reservation 的发布者
然后我要读取所有数据
我写 this...
reservationRepository.findAll(...
重启一下
运行了吗？ 是的 跑起来了
所以 localhost:8080/reservations
这是我们的数据
好吗 这啥牛逼的
你以前就见过了 一点都不牛逼
非常简单 只是一个 RestController 返回一个发布者
这是很重要的 所以
尽管这看起来像 Spring MVC
然后你可能会觉得熟悉
如果你使用 Spring MVC
这个并不是 Spring MVC
这里边没有 Servlet API 在 classpath
对吧 我甚至都没有使用 Servlet API
这是全新的 Reactive Web 运行时
基于 Netty 的
从底层开始构建起来支持我们这里想做的
好吗 所以
我们这里有响应式支持
而有些东西
表面上是非常相似的 例如那些注解
将会感觉非常熟悉
其中不同的是 我们实际上返回 额
发布者
Spring MVC 控制器的返回值
典型的是
用于构造会被客户端渲染的响应的东西
这个实际上不是这样做的 是吗？
这个它本身就是一个响应了
这是一个东西 WebFlux 这个框架
可以用来到达结果的东西
两者是不同的 它们之间的区别是很重要的
它给了一个我们可以用的
然后得到结果的结果
但不是同样的东西
所以这次进入到了问题
OK 如果我想要一些东西一直活着
在一个管道的生命周期之内一直存活着
我应该怎样做？
我如何附着某物
到生命周期超越这东西的
记住我们不能使用 ThreadLocal 对吧
ThreadLocal 现在用不了啦
你可以看到 我们解决了事务的问题
就在几分钟前
我们可以做的方式是 如果你想做的话
是我们可以访问一个称为 context 的东西
OK 你可以创建一个订阅者上下文
而 context 是在底层支持的
我们的能力取附着一个例如
额 事务附着到目前的管道
不管那个管道是在哪个线程执行的
这是一个可以支持我们做分布式跟踪的东西
去持续画出沿着不同线程的路线
那是可以允许我们做
安全扩散的
你可以在数个不同线程间传播认证信息
你可以创建一个与管道有关的上下文
就像这样
所以我在这里做的是
创建一个 context
以一个键和值
分别等于 a 和 b 的
对吧
它可以一直可见
在这个管道之中 我可以访问这个上下文
我的代码的任意地方 我可以写
doOn...
例如 ...Each...
然后我给个信号 从每个信号
我可以获取到当前的上下文
例如我可以打日志输出它
所以你自己可以做各种事情
你可以自己管理那种机制
但除此之外 这仍然是
一个 Spring MVC 风格的控制器而已
我喜欢这种风格
考虑到这只是一个简单的例子
我想要发起一个 HTTP GET 请求
然后想它返回 Reservation
就是这样而已 然而我一整个类和构造器
还有注解 方法之类的东西
只是为了支持那一个 HTTP 端点
额 你可能更喜欢这种替换的风格
称之为函数式响应式端点
在 Spring 5 及其后版本可用
所以我们支持它已经超过两年了
所以 routes
return ...
好吗
.GET(...
所以我正在做的是 我创建一个 Bean
在这个 Bean 里面
我定义一个函数式响应式路由
而我将它注入作为数据仓库的协作对象
我写 ...findAll(), Reservation.class...
然后 哇啦 OK？
就是这样子
我将使用 static import
然后这就是我整个 HTTP 端点
这只是一行 我说的是
让…… 当某人对/reservations 发起请求时
那么指派这个 Lambda 去干活
还有就是这是构建者方法
所以我实际上可以将这些串联起来
我可以做 .DELETE 我可以做... 
PUT 还有  POST 等所有这些东西
我可以编程地添加这些东西
我可以使用条件语句 while 循环之类 随意玩
去随意添加这些端点
所以 取决于你偏好的风格
但它们功能上来说是一样的
它们做的是同样的事情 OK？
所以让我们重新运行这个程序
然后看一下我们会得到什么
我？ 嗯 可以了
OK 就是这样
这就是数据
OK？
现在我们有了一个可用的响应式 HTTP 端点
我们有 额……
我们有 R2DBC
我们看到我们可以写 SQL 到数据库
额 当然这是一种非常常见的自然的事情
我们有这些非常……
额……
简单 易实现的用例对吧
我想写数据到 SQL 数据存储
然后我想从 HTTP 端点读取它们
然后问题当然是
那又怎样？
我以前就可以这样做了
我并不需要响应式去从数据库读取8个记录
然后将它暴露为 JSON 对吗？
这在以前做起来也不难 为什么今天我要这样做

### 写一个 HTTP 端点

这是个好问题
所以真实的用例 真实地使得
响应式编程如何迷人的
是它带来的能力和机遇
用于一些可能会独占线程的事情
那么有什么例子
什么会独占一个线程？
在一个典型的应用架构我们会怎么做？
可能会让一个线程一直开着
嗯 每当你需要客户端与服务器通信的时候
然后客户端想要活动地持续地更新
自是很自然的候选者
去让一个线程持续地打开
像服务端发送事件之类的
例如 WebSocket
然后这些协议支持的使用场景是什么？
它们支持的使用场景必须要
持续地更新 例如
聊天 presence 还有股票动态
这类型使用场景需要一直接入的
OK？
那么让我们创建
一个服务会产生
数据的一个永不停息的数据流
OK
我们将创建一个 WebSocket 端点
那会响应
一系列 WebSocket 数据流 一系列“问候”的数据流
当某如需要一个“问候”
给定一个“问候”请求， 我们将要
产生数据流
作为问候的响应 好吗
request
OK 然后
@service
将这个类型放到这里
class
将这个类型放到这里
这里
好
那个请求只是有
name 它的详细内容只是包含一个名字
然后响应会有
问候消息它本身
OK ?
现在当然是 @Data
哇 这是什么
@Data
@AllArgsConstructor @NoArgsConstructor 好东西
好东西 现在
我们要做的是
当某人请求一个“问候”
我们会返回一个不间断的数据流
new Greeting ... Request
额 不好意思 是 response
Hello
OK?
所以这将会是不间断的数据流
现在 那是一个不间断的数据流
让我们用这个替换它
然后用 Lambda 替代
然后我们也调用 delayElements...
我要写
我想要延迟它 1 秒
所以每一秒我都要产生一个新的值
现在
留意下我刚才做了什么
我引入了
一个永不间断的数据流
它将会产生新的响应
一直都会
那个数据流会
会很快地滚动下来很快占满控制台
我们不看看到终结的
所以我通过使用 delayElements 分散下结果
我可以这样
我可以在这里改变时间是因为
是因为在 Reactor 背后我们所做的一切
里边都有个调度器
通常你不会注意到它存在
你也不需要知道它存在
但它一直都在那里
那个调度器
就是允许我们控制
执行的动向
从一个线程无缝的切换到另一个线程
你不需要担忧这个
调度器
处理两件事
处理调度任务
然后它处理多线程
它实际... 它有点像个线程池
加上一个定时器 你可以这样想
OK ?
额 这是我们放进 Reactor 里的抽象
通常你不需要担忧这个
但是默认情况下
一个线程占一个 CUP 核
好吗？
所以你有每个线程一个核
在默认的应用程序
这意味着
如果你是
在一个机器
你只有四个核 那你就只有四个线程
所以非常重要
你不阻塞这些线程
如果你使用响应式代码
那么你不能阻塞
对吧
额 在这里你有调度器
如果你觉得需要的话
如果你需要重写调度器的话
如果你需要做一些事
那会阻塞的话
非常重要的是
你处理好
额
将那个任务
放到一个不同的调度器
所以 Schedulers...
额…… elastic() ...
或者是 fromExecutor(...
你懂得像这样
你提供你自己的 Executors
随你所想 对吧
很重要的是
你要处理好重写调度器
那某个管道的使用
要么 subscribeOn 或者是 publishOn 对吧
我通常使用 subscribeOn
但如果你有一个生产者它会
如果你有消费者比生产者更慢的话
你可以使用 publishOn 对吧
嗯 喔 这是
这被认为是代码臭味
我认为那会是代码臭味
如果你发现要经常这样做
如果你有代码在你的代码库里是阻塞的
与阻塞资源之间的交互
然后你要扩展开那个交互
通过添加更多线程的办法
这样是
我们尝试使用
响应式编程的初衷
我们想要的是
你懂得 不阻塞
我们想从中获益的
是在系统高效地复用线程
如果你只能通过增加线程扩展的话
有的问题了
你应该能找到那个代码
而且一点点
隔绝并从你的代码中移除
为帮助你做这样的事情
我们创建了称为 blockhound 的东西
是一个 Java 代理
你可以用它来检测
不阻塞线程的阻塞调用
你只需将它添加到 classpath
然后只需运行 BlockHound.install()
在你的 public static void main(... 方法里
在你启动 Spring Boot 之前
OK ？
额
这样做了之后
如果你干些傻事 例如 Thread.sleep() 或计算斐波那契数列
不管什么 额
你会得到这个阻塞的调用
对吧 这个阻塞的异常
它会抛出异常 帮助你知道那里有错误
就那么简单
然后你可以好好调试或者
将其隔离，或者至少处理好
将它放到它自己的调度器
这响应式的世界里这要做很重要
请记住 如果你有四个核心 你有四个线程
如果你阻塞了其中一个线程
那不只是一个请求
那是你 25% 的用户
对吧 你通常可能使用 PHP
去解决那样的问题 不 不要那样做
做正确的事情
OK ? 那么
我们有一个调度器
你可以使用它 如果你想的话
那个调度器
是一个允许我们
像这样做事情
我们可以增加时间
时间是我们的 API 的一个维度
这是响应式编程的一种好处
我们现在可以想象世界
真的作为一系列的时间  时间里一系列的事件
那么现在我们那样做了
让我们创建一个请求
额 WebSocket
端点 OK？
Websocket ...
好吧 ...Configuration
然后我们会在这创建一些 Beans
那个 WebSOcketHandleerAdapter
这是一个东西
我们需要
去告诉 Spring
去查找 WebSocket 支持 对吧
我们需要那个 WebSocketHandler 本身
然后这里边是我们的业务逻辑
等会我们再回头看看这个
这个是业务逻辑
然后我们实际上需要告诉
Spring 去装载我们的
WebSocket 端点
到一个 HTTP URL
我们需要这样做的原因是
额 WebSocket
是一个二进制协议
但当 WebSocket 客户端连接到服务器的时候
它会升级
到二进制协议
所以它先是连接到 HTTP
然后有握手 接着协议升级
我们需要告诉框架
嘿 映射这个端点
这个 HTTP 端点
到这个二进制协议
OK? 所以我要写 Map.of...
/ws/greetings
然后我要给它一个引用到 WebSocketHandler
它会延迟操作 对吧
我要给...
我要给这个特定的 URL
一个排序 只是为了确保它
确保它排在其它 URL 之前
OK 那么现在
这是我的 WebSocketHandler
这是业务逻辑所在的地方
条约很简单 当请求进来的时候
我们获得一个指向当前 WebSocket Session 的指针
而正是在那个 WebSocket Session 我们才可以
做一些像
询问传入的数据
那么什么是传入的数据
在这个例子当中
那将会是一个“问候”请求
将会是 String 类型的 name
我们可以将它变成一个问候请求
然后调用服务得到一系列的响应
再发送回给 WebSocket 客户端
所以我们将会说 嘿
给我们一个数据流
的 WebSocket 消息
接收当中的每一个
就像这样 获取载荷作为文本
就像这样
map 这里边的文本
这些是名字
实际情况只是会有一个名字
你知道的我们这里有个发布者
map 每一个名字
到 GreetingRequest
就像这样
OK
greetingRequestFlux
然后将当中的每一个
然后我们会将它变成对服务的一个调用
然后我们注入刚刚创建的“问候服务”到这里
就像这样 gs
.greet( gr ...
然后我们将要
创建一个“问候响应”
现在对于其中每一个响应
我想要将它转换成 WebSocket 消息
我可以返回给客户端
我们将要写
receive... 额 我们要写 greetingResponseFlux...
OK？这些是
String 类型的名字
我要将它变成
WebSocket 的消息
通过写 txt...
将它变成这样
这是我的 WebSocket 信息数据流
我只需要写 session.send(...
map1
这就是整个管道
很显然
我不想让它这样子
折叠起来成为一个
容易理解的数据流
OK
所以你可以看到
默认情况下我使用 map
除非我有其它东西会产生一个发布者
那样的话我会使用flatMap
额 还有
就是这样 这就是整个序列
所以 receive
当然这整个接口
时函数式接口 所以
这是它的 lambda 形式
OK?
现在
我有一个 WebSocketHandler
这是一个 Bean 我在配置类里边配置的
这是一个 WebSocket 端点
这东西能用
但我想 我要给你们演示这个
现在我的朋友们 我有点
有点尴尬
我们这边有点问题
不幸的是
我要给你们演示这个
然而我想不到做这事的更加优雅的方式了
我想不到一个好的方式去做我想做的事情
但我必须做这件事 为了做这件事
额…… 我会觉得不自在
对吧 我们是朋友啊 我觉得……
这会破坏我们之间的信任如果我这样做
但我想不到更好的方式了
而我通常不会在体面的公司里做这样的事情
OK 如果我能避免的话 如果我可以找到其它方式
去做我想做的事
那么当然我会
哎…… 我要写 JavaScript
OK？
好 那么
window.addEventListener...
OK 这些代码
OK
不好意思 是 ... ws/greetings ...
对吧 就是这样
然后 当 Socket 打开的时候
然后我可以开始跟它交互了
我要做的是
我要获取 Socket
我要发送请求
我只是写
Devoxx
Belgium OK?
好了吗？
然后
当数据进来的时候
我要加载这些资源
所以我要构造请求 这是我们要发送的名字
实际上我们不需要在 Belgium 后加叹号
当那个消息返回的时候
我们有 onMessage 回调 所以写 function ...
... msg ... 我将结果打印到这里
所以 console.log(...
然后我们重启应用
OK
噢 是这个
就是这样我的朋友们
每一秒钟
至往后无限
它会产生新的结果
它会一直有…… 继续有…… 有……
永远
直到永远…… 永远…… 永远……
它不会结束的
它是无终结的
就像海洋……
亦如星空……
还有你代码中的 bug
无穷的
无尽的 我们朋友们
那没关系
好吗 那没关系 因为
我们要做的是
是在雨滴之间
在这些消息发送给客户端的过程
那个线程释放了
某物 某人在系统中之后可以使用那个线程
去做更多的事情
这是真正的好处
响应式编程带来的进步
并不是我们让每个事务更加快
是我们这样做所以
处理更加多的事务
这就是真正的胜利
对吧 做个简单的计算
这个完全算不上是真实的性能测试
但在这里使用简单数字做例子
这里的目标是用一半的硬件成本去处理
同样多的事务
对吧
或者去处理
一半…… 额一样数量的事务
或者是两倍数量的事务
以同样的硬件
对吧
那并不是要使得每个特定的事务更加快
记得吗 因为线程切换
那可能会更慢一点
但目标是你可以用同样的硬件做得更多
你更高效地使用了这个系统
所以我的朋友们 我们已经看了如何构建一个服务
在这边谈论了一些不同的东西
我们构建了一个简单服务

### 演示 WebSocket 实时发送消息到网页

在下一节
我们会讲构建一个客户端
那将会带我们进入到恐怖的微服务
当你有一个服务于另一个服务通信的时候会发生什么
在那一节我们会讨论像网关 HTTP 适配器 网关之类的
API 适配器 HTTP 客户端 你懂的
我们会用 kotlin 写
那会是在第二节
现在是生理休息期啦
你自身的一些 IO
额 去喝杯咖啡 喝杯茶
我很感谢你们 谁目前玩得开心？
只是确认一下 OK
好东西
我要在相机使用夜间模式
好东西
OK 我的朋友们 大概十分钟或十五分钟后再见
15 分钟后？
OK 好的 我们有 额 现在几点？
十点多…… 现在是十一点
所以 11点15分 回到你的座位上
好了
好东西 欢迎回来
那么 我刚才遇到一点问题
我去找杯咖啡
跟大家一样 额 那边有个人在门口
你的胸牌在哪里？
噢…… 我的胸牌在这边……
但我当时没有带 所以……
我差点回不来了
他非常坚持不让我回来
啊…… 所以……
还好现在没事了
幸好你们很多人在那里说， 他是演讲者……
没事的，这是他的日程表 哈哈
嗯 不管怎样 欢迎大家回来
那怎么样 有趣吗
啊 很有趣
我拿了咖啡 我觉得我准备好了
我们只有 55 分钟了 不是很多时间我的朋友们
所以我们要开始了
我知道你们有些人还正在回来
我们真的要继续了 所以

### 第二节开场

现在 我们已经构建了一个服务是一个 HTTP API
额…… 我们演示了 WebSocket
我们演示了 响应式 NoSQL 和 SQL 数据访问
在 Spring Data 的世界里
我们全部用 Java 写的加点 JavaScript
对吧 那有点
额…… 你懂得 总会遇到 JavaScript 的对吧
就如谚语所说那样
额 然后 现在
是时候将我们的注意力转到
构建客户端
构建一个东西 我们可以用来
额 与那个服务进行通信
去构建边缘服务
而边缘服务是在逻辑上在架构的边缘的东西
首个来自外界请求的端口
会被适配到对下游微服务的请求
而边缘服务是逻辑上我们处理
一些边界关键问题
例如 负载均衡
路由 还有安全之类的
所以我们要在这里做 在这个边缘服务里做
额 我们要构建一个 像往常一样
通过到 start.spring.io
OK? 所以我们开始
啊 现在
我们要构建一个应用
你知道吗 顺便说一下 有点失望
之前从 10 月 31 日开始
那时候是万圣节前夜
从 10 月 31 日开始
这是万圣节前夜风格的
那很酷啊
现在变回暗色模式也很好 你懂的
但 当时这里有个南瓜和鬼怪的
随意啦 没关系

### 开始写代码 Kotlin

OK 我们要构建一个应用基于 Kotlin 的
我们要构建一个 reservation-client
OK? 就是这样
很好 我们要在这边选择 正确的东西
当然选择 Java 13
然后我们有一些需要的依赖
我们需要响应式 Web 支持
我们需要 RSocket
额 我们需要 Spring Cloud Gateway
我们需要 响应式 Redis 支持
我们需要 Spring Security 支持
然后我觉得我对我目前的选择满意了
所以我要点击 Generate
当我确认我已经有了我所需要的
是的 齐了 好
所以我要构建一个应用
现在 这是一个 zip 文件可以打开的像往常一样
这是我们的 IDE
UAO
喔 这是什么东西
让我们看一下 我们不需要那个
这个也不要
这也不需要
OK？ reservation...
好
我给自己拿了两杯咖啡
只是以防万一
好东西
跑起来吧 好
这是基于 Kotlin 的应用程序
你们有多少人使用 Kotlin
OK 实际上很不错啊 手先别放下 让我看看
哇……
那很好啊
那大概有 三分之一 或者 四分之一 我觉得惊讶
这很让人惊奇 这很酷
好东西
所以 Kotlin 是一种好的编程语言
构建在 JVM 之上
你懂得 编译到字节码
有互操作性
跟其它的各种库之类的东西
使得它如此吸引人
目前 Kotlin 最大的用户是安卓用户
那是有很好的原因的
Android 很难有现代版本的 Java
Java 8 怎么讲都不
跟它们相关 对吧
你不能保证你在安卓写的代码
可以编程成 Java 8
因为很多人没有与 Java 8 兼容的运行时
所以你要编写代码编译到 Java 7 之类的
或者目标是 Java 7 
这可能有点让人失望
因为我们现在用的是 Java 13 对吧
版本号差不多是两倍了
然而我们还不能在安卓用户端使用它
所以 Kotlin 是非常不错的
它可以编译到更加老的版本
同时仍使用一种语言
用起来更像 Java 20 的感觉
相比较于 Java 7 对吧
额……
额 我意思我喜欢 Java 的 很显然啦 但是
那只是 按照定义来讲
它并没有那么有趣、前沿对吧
额……
所以 Kotlin
非常不错的语言
在 Kotlin 有些东西你要理解的 首先
函数是由 fun 开头的
函数名紧随其后
所有在 Kotlin 当中你可能称为方法的其实都只是函数
如果它们在一个类里边
我说它们是成员函数
如果在一个类之外
它们只是函数
它们只是顶层的东西
它们可以这样的 这是需要注意的
我们这里有的是
一个空的类
这是一个空的类
里边什么都没有
那里是同样的东西对吧
所以我有一个空的类
里边什么都没有
这个函数不属于这个类
它可以
那样的话 我就要这样做 对吧
但我不是要这样做
我只是有一个顶层的类
一个顶层的函数
它们看起来是相互相邻的
额 在 Kotlin 里边
参数名称
放前边然后才是类型 对吧
额 有一种同一的语法
给泛型参数的
那就是<xxx> 这是一个数组
String数组 相当于 String[] 对吧
OK 这基本上就是你需要理解的了

### 讲一点 Kotlin 背景基础知识

我们要做的是 我们要构建一个应用
那会访问一个 API
额……
边缘服务
首先要做一些事情
我要确保这个应用
在 9999 端口启动
我们要确保注释掉
那个…… 那个…… 安全相关的东西
因为那会锁住这个应用的 我们现在还不想这样
好吧 计算机
好？
好 这样可以了 好吗
我要选择 Enable-Auto import
因为有时候要更改 classpath
我希望工具会跟上节奏
OK 现在我要创建一个类
它将会是
额 Java config 风格的端点
我将会创建一个 API 网关
使用 Spring Cloud API Gateway
这是第一类
边缘服务
一个 API 网关是一种将外界请求
并处理它们
以一种通用的方式
有点与载荷本身无关的那样
它基本不知道那是 JSON 还是 XML 也不怎么关心
它只是做一些通用的转换
与载荷的语义无关
与特定的载荷本身无关
所以我们要创建一个基于 Spring Cloud Gateway的网关
现在 Spring Cloud Gateway
是构建在 Spring 响应式 Web 支持之上的
所以它本身就是响应式的了
我要在这里创建一个 Java 配置风格的端点
所以我在创建一个 额…… 
我们过去称之为 Bean 配置方法的 现在是函数
我正在注入一个类型为 RouteLocatorBuilder 的参数
我要使用 RouteLocatorBuilder
去构建我的网关路由
你做的方式是构建一个路由
然后你构建（builder 模式） OK？
现在 额……
在 Java 的话看起来就像这样
显然 在 Java 你会有分号
但在这里是可选的
可以有任意多个这样的route() 调用
每个路由
对应着某些会进入到服务的东西的定义
然后你想要拦截
处理 然后转发到其它东西
OK? 通常你有一个像这样的 Lambda
然后 Lambda 有一个 route 配置 或 规范
然后使用路由的规范去定义 例如
当每个请求进入到
这个路径 称为 /proxy
... and().host(...
这个主机 ……
然后我想将它发送到
这个 URL 所以 localhost ...
现在当然
我实际这样做不到 对吧？
这会发生什么？
首先  嗯……
我需要返回一个 RouteLocator
...RouterLocator...
那就是返回值
那就是它抱怨的
额 首先
将要发生的是 我想要
匹配 /proxy
然后我想匹配这个主机名
当然如果路径是 /proxy 那么
如果我转发到这个
不作任何地更改
那会变成 /reservations/proxy
那不是我想要的 所以我需要
去过滤、我要按某种方式处理一下
所以这里我们有 filter 回调 我们写……
然后赋予一个 lambda
我们可以使用 filterSpec...
然后写……
这将会作为一个代理 这些过滤器
是这里真正的力量
它赋予你能力做各种事情
想象一下
你有一个 HTTP (不好意思口误）HTML 5 客户端
然后那个 HTML5 客户端
想要调用下游的服务
额 为了让那成为可能
你要确保你支持
CORS 跨域请求脚本 对吧
而为了那样做 你要写
我想要添加一个首部
HttpHeaders.
噢 不是这个
你可以看到不少人也想到了这个
对吧 HttpHeaders
我们要允许 ACESS_CONTROL_ALLOW_ORIGIN
ALLOW_ORIGIN
我想要说 允许所有东西
OK？
嗯 所以那是
让我们去掉另一个
使得这不必要地长
OK 拜拜
然后这个
OK？
好
这就是这些代码
让我们看一下如果运行会怎样
正在编译
curl
减号 额不好意思 http://locahost:9999/proxy
这样当然是不行的
额 噢~
不是这个
security.rsocket #%……￥%@#
哼？
这是什么鬼
我这辈子都没见过这个
说真的 这真有趣
这就是追求新技术的馈赠
OK 我们有这个
让我们注释掉它
我以为我已经注释掉安全相关的依赖了 不是吗
我觉得我已经注释掉了
maven reimport...
别 那是什么？ ...rsocket.core?
哇 看起来我们的确遇到些问题了 但我们可以
有可能解决它
让我们看一下 噢这个
spring-security-rsocket 没人想要这东西
我没要这个
OK 这次好了
这是新的 OK 好 那么
它们想帮忙的 因为我最初勾选了RSocket
它引入了其它东西
然后我勾选了 Security
它将这两样都引入了
但这两样我不是全都要
OK 现在它显示
它找不到端点 对吧
404 所以现在
我指定一个主机断言 -H"host.devoxx.spring.io"
OK
然后 那…… 失败了 额 9999
-H ... devoxx.spring.io
连接被拒绝……
噢 因为我的服务（未运行） OK
它正在代理请求
到这边这个东西
我的 ReservationService
那东西还没有运行
OK 让我们重启它
然后这些就是请求
如果我美化输出到 JSON....  json_pp
OK 就是这样
这是我们的数据
OK 所以我们代理转发了数据
我们也可以看更加详尽的输出
去掉那个
我们可以看到我们这样做
它添加 Access-Control-Allow-Origin 首部到响应
所以现在任何 JavaScript 客户端
可以连接到我的边缘服务
而那会允许它们获取到数据
它会响应式不阻塞地转发请求
那不会等待完整的响应
它会流式传输数据当可用的时候
它会从下游的微服务获取到数据
在这个例子中就是 localhost:8080/reservasions
然后它会发送回到给我们的客户端
OK？
所以现在 让我们再回顾一下这代码 既然我们
已经让应用程序的基本骨架可以跑起来了
这个
是在 Kotlin 种非常像 Java 做法
OK ?
但有很多方面我们可以改善的 首先
我们有一个函数
创建了一个表达式
那个我们之后返回了
我们实际上没有
什么东西在中间 没有逻辑 没有状态
什么都没有 我们不
我们并没有从中获益
所以我们可以使用等号
在这个例子 我们实际上可以
做个赋值 基本上我们可以写
这个函数 = 这个表达式
所以如果你调用这个 它是等价于调用那个的
那样更好一点
另一个 Kotlin 做得很好的是
它有种很好的能力
如果一个函数最后的参数是个lambda
你可以将lambda写到函数的外边
所以在这个例子
我可以将它重写成这样
喔 这看起来有点傻 不是吗？
现在我在那里什么都没有了
对吧
但功能上是一样的
所以在 Kotlin 你也可以去掉括号
对吧 那也是同样的东西
额 这样好了一点 对吧？
这边也一样 我可以修改这个
即使这些全都很不错
但是我们有这些不必要 有些……
lambda 的参数
对吧 这是一个路由的规范
但 这只是中间变量
这些是我们创建了为了有个名字而已
但我们并不需要这些名字
因为我们直到 lambda 有它的参数
所以我们可以去掉这些变量名
然后我们可以用 it 引用
it 是一个隐式地被创建的参数 对吧
如果你用过 groovy 你就知道这些东西了 对吧
所以同样的东西 我可以在这做同样的东西
我可以写 it 对吧
当然 在这个例子 可能会有点疑惑
因为变量范围的问题
这可能是你想要保留变量名的原因
OK 随你
OK 我喜欢那样 看起来更好一点了
但甚至在这里
我们还可以做得更好
所以 其实 Kotlin 当中有个很好的特性
或可以获得扩展函数
这些是在 JVM、JDK
还有在 classpath 上的代码里面
但它们被添加到已存在的类型
所以你可以将类型粘起来 非常像 ruby
例如你可以给已存在的类添加东西
额 这意味着你可以像玩视频游戏
你可以解锁一个秘密等级
你的类路径上有这些库
那些通常是为 Java 用户准备的
但它们表达了某些 API 功能
某些能力到 Kotlin
而且只有通过使用 Kotlin
才可以使用它
所以实际上 我们还可以再次重写一遍
routes
然后这是 DSL
所以 RouteLocatorBuilder 是 Java API
是用 Java 写的 你可以看到代码
是 Java 对吧
不过
这里有个额外的函数 称为 routes
我们可以看到
是一个扩展函数
让我下载它
OK
下载源代码吧
谁在下种子 随意吧
OK 这个函数
是定义在 RouteLocator 之上的
并且它需要一个 RouteLocator 做参数
从这里之后它接收一个参数
那是一个 lambda
那 这很有趣 这个lambda语法
没有参数
然后返回 Void 
Unit 相当于 Void
这个 lambda 也写作
也被定义做
额… 基于对上下文绑定的RouteLocator DSL引用的
所以基本上
在那个lambda
如果我调用 this.
我实际上调用的是
我是对着一个 RouteLocator 实例调用的 this.
我原来的 'this' 已经被替换成这个 DSL 的 'this'
这意味着我可以对着这个（方法）调用，我意思是类型
而实际不需要声明那个类型
我的 lambda 被插入到那个对象里
它的上下文 基本上是这样
所以现在我可以重写这些
更加明确地 我可以说
route...
然后我要匹配一个路径
为 /proxy
而且，顺便说一下，我可以这样做
我们可以那样做 但我们也有
额 中缀表示法
对吧
所以 ...host...
我可以这样做 我写
"*.spring.io"
随意啦
但因为这是中缀标记法
我可以去掉所有这些
对吧 同样的东西
额……
然后
我想要创建 filter
然后这个 filter
包括设置路径
对吧 "/reservations"
然后我想要添加响应首部
让我……
复制这个
OK 跟之前的一样
然后是 uri
在这里
"http...
"http://localhost:8080/"
好了
就这样
这就是整个东西
所以现在我可以重写
全部 我不需要 build
上下文会帮我完成的
就是作用范围它本身
给予了我那个 对吧
然后就是这样 这就是全部的重写的 DSL
所以你得到像这样的
类型安全的
看起来有点像 有点让我想起
以前的 Apache 配置文件 对吧
不同的是这是编译器的 而且是类型安全的
对吧 这很不错

### Kotlin DSL 配置 Spring Cloud Gateway

所以这跟刚才给你展示的东西基本上是一样的
为了证明 让我们重启一下应用
我喝点咖啡 我觉得我值得这样做
OK？
那么
看吧 这就是我们的数据
所以这就是跑起来了的应用
现在
那个过滤器
就是魔法的所作
是力量所在
我可以做各种有趣的事情
我可以修改首部 我可以修改请求 URI
我可以修改请求体、响应体
我可以保存
或者是移除首部 例如 host 首部
我可以做重定向、可以做重试
我可以做重写
URL 重写
一些你可能会用 NGINX 或 mod_rewrite 做的事
你可以很容在这里做到
路径重写之类的东西
你可以在这里做
我可以设置响应的状态
我可以做各种事情
使用这些 filter
我最喜欢做的事情之一是
当然是创建我自己的 filter 对吧
因为你可以完全掌控
所以如果你想要创建你自己的 filter
做起来很简单 对吧 你可以
你可以看那是怎么做的
嗯……
另一样我最喜欢做的事是
考虑下限制访问速率
那么
速率限制器
是一个非常简单的东西
速率限制器是一种东西
当有一个请求进来的时候
查看进来的请求
基于你的规范的条件来验证
然后
选择保留还是拒绝那个请求
还有
通常那个标准是
你所规定的一个计数 一个预算
你说，我允许
额…… 让我们假设 10 个记录 5 个请求
每秒十个请求
或5请求每秒 或者是 每秒百万个请求
不管是什么吧
对你来说可以接受就好
一个速率限制器
关注两个很常见的应用场景
第一种用例
是 嘿~
我想要限制在全球范围的绝对请求次数
到 随意吧 n 个请求每秒
5 让我们只用 5
简单容易好算数 OK？
所以假设我们想要限制每秒访问的绝对次数为5个请求
这意味着不管人们在哪里发起请求
也不管是一个客户端、机器人或者是人
什么都没关系
你只需限制每秒5个请求就好了
对于全球范围
OK？
嗯……
这是很常见的用例
如果，由于某种原因你有一个很昂贵的下游服务
那 很难扩展起来的
例如 我想到的是大型机
对吧 某种大型机 你可以处理 x 个请求
x 个事务处理
x 个用户
但如果你再添加一个
你要买个新的大型机
对吧
这些东西还未开始用就已经要花几百万了
对吧 如果可以的话没人想要扩展这些东西
所以这非常有用 像说 嘿~
我要将所有东西汇聚起来降低到这个小的
受限的速率
我要说 OK 这里只有 5 个请求
只是简单的数学
我确信你可以处理比那更多的 对吧
但是我只将它限制到每秒5个请求
对全球范围
不管是谁在发起请求
嗯……
这是一种应用场景 另一个应用场景是
我想要处理 我想每个用户
都是每秒只能发起5个请求
好吧 所以在这个案例你没有扩展起来的问题
很可能地 现在是 2019 年 快到 2020年了
你可以使用一个云平台 例如 CloudFoundry
或者你可以用 Kubernetes 构建一些东西
额 随意什么东西吧 对吧？
如果是这样的案例
你想要限制对下游服务的调用
但你不想限制用户的绝对数量
通常你只是限制每个用户的请求数量
以确保每个人都参与公平的游戏
额 没有人 你懂得 滥用系统
并从中获益
你不希望有机器人对你的页面发送垃圾请求
或者是爬虫之类的 不管什么
发现一种方式毁了系统对其它人的服务质量
所以速率限制器在这两方面都有用
嗯……
速率限制器维持进入系统的请求的计数
同时
它们与你所给的预算作比较
如果预算超了
它们拒绝请求
它们将请求发到别的地方去
所以我们有了速率限制器
嗯……
一个追踪进入系统请求数的速率限制器
我们有一个边缘服务
我有一个边缘服务 一个速率限制器
这个速率限制器 现在 让我们假设
我们想控制并限制每秒请求次数到5
如果我创建另一个这样的边缘服务实例会怎样？
如果我将这个边缘服务的 JVM 线程
并将其部署 然后我现在有两个实例在负载均衡器后面
当中每一个都可以配置成
不可以超过每秒5个请求
那么现在
我变成可以每秒请求十次 不是吗？
我所转发请求到的下游服务
那个 reservation 服务
会看到十个请求每秒
因为我有两个节点
两个都允许每秒五个请求
这样不好 对吧
这就是将预算值写死在 Java 代码里的问题
我们需要某种方式去追踪用户的数量
而且是保持追踪
独立地追踪某个特定的节点
我们需要一些东西是可见的 是一致的
能跨越所有的 JVM 访问 对吧
而且定义上来讲它必须要闪电般迅速
本质上 我们需要原子性的数字
然后是非常快的
可以运行在集群当中
而且那可以容易地接入到我们的应用
因此
我要放入
额……
该放在哪？
Redis 对吧 就是它
我添加了 spring-boot-starter-data-redis-reactive
OK？
所以我们将要创建一个基于 Redis 的速率限制器

### 开始配置限流器 RateLimiter

K? re... 额 fun...
我会将它限制为5个请求每秒
然后我要冲破到 7 OK？
OK 就是这样
嗯……
现在为了让它能用
我需要配置
速率限制器
所以我可以写 set...
setRateLimiter 像这样子
然后我只需调用 redisRateLimiter
但请记住 在 Kotlin 里边
就像现在的很多语言那样
例如 Groovy、Scala
Ceylon 基本上其它东西
你可以只写
基于属性的访问
它同样是这样调用 rateLimiter

这个 rateLimiter
它会查找速率
它会查找当前的计数
那个将会对我们调用的计数进行验证的
在 Redis 里边
嗯 什么是键值对存储啊
所以为了找到那个值
你要找到那个键 知道要用哪个键
所以我们要给它一个 keyResolver
所以我们写 keyResolver...
然后我们可以插入 KeyResolver
嗯 这个 KeyResolver
有一个很简单的任务
返回一个数据流对吧
所以我可以写 你懂的
额 这是我的键
对吧
这是我们要在 Redis 里面使用的 key
这里有人看过《美丽人生》这电影吗？
La vita è bella
电影台词
没有吗？ 好吧
不管如何 这是这东西
嗯 额…… 
所以 KeyResolver
OK? 它返回
单个的数据流
这是首个应用场景
我说 不管世上谁在发起请求
我不在乎你在哪里
我不在乎 你在的地方是白天
而你在购物 然后那服务
应该会允许你
完全使用这系统 与此同时也有人在半夜使用这服务
他们应该在睡觉的
我可以将他们的服务降级
因为这时候那各地区没有太多流量
你在这世上任何地方都无所谓
因为我期望每秒不超过5个请求
就全球范围而言
OK？ 这就是一种应用场景
一个键 管理所有
OK ?
你可以那样做
现在注意到作为参数我们有个请求
对吧 那个请求
是 it 我们可以只用 it
但它在那里
我们可以根据它验证一些东西
我们可以说 嘿~

### 限流器的基本需求

给我 Principal
给我当前的 Java Security Principal
与这个请求相关的
对吧 所以
Principal
然后我想要将那个 Principal
然后我想 map 它一下
我要写 map...
所以它会给我
一个 publisherOfName
所以 Publisher
Publisher<String> 的名字 等于这个
就是这样 好
这是我在这里创建的类型
额 我显示地指定类型
那样你们可以看到 但你们不必要这样做
你也可以这样写 好吗？
同样的东西
这是我的数据流的名称
我可以返回那个啦 我可以只是写 return...
publisherOfName
对吧
让我们这样做吧
OK?
额……
在 Kotlin 当中 顺便提一句 最后一行
在一个函数里面
或是 lambda 在这个例子
是那个被返回的对象
所以其实这也能用
所以实际是我在这里返回
我这里获取到了名称 不过如果没有名称会怎样？
如果这里没有 Principal 会怎样？
在当前的请求里 那么……
我们需要 .switchIfEmpty(...
所以我们写 Mono.empty()...
OK?
现在返回一个数据流的名称如果存在的话
在请求当中
然后我们会讲那个 Principal 从哪里来
我稍后再讲 给我几分钟 不过
如果那不存在的话
那么我们希望返回 ...empty()...
这是非常寻常的策略
我刚才所作的是 我创建了一个 keyResolver
那会基于当前用户返回当前的 key
如果 jlong 是已经认证了的 已登陆到系统的
那么 我会得到那个响应
我会获得那个 key
名称是 jlong
我可以运用那个 KeyResolver
这是如此常见的策略
如此容易写
因为太常用 实际上
我们会有个 PrincipalNameKeyResolver
好吗？
就是这些东西
好东西
实际上它太常用了
所以它是默认的 所以我们会变回这样

### 默认的 PrincipalNameKeyResolver

好吗
那么
这是我们的速率限制器 现在
让我们谈一下安全
然后 这边就是事情变得有点有趣的时候了
安全是非常重要的
很显然啦
额 还有
这并不是带来希望的消息
如果你因其中一方而离开这个讲座的话
你还不够资格做安全
我不希望你自我感觉良好
我想你记住你在安全方面很糟糕
统计概率上来讲 你会搞砸的
额…… 我也会搞砸
这里边没有 这没有温暖而模糊的东西
你真的需要
怀着沉重心情望着镜子并接受你在安全方便很糟糕
你不知道自己在做什么
我也是这样
对吧 这就是关键所在
如果你要做安全
你不该做 如果你觉得你应该进入安全领域
重新思考一下
回家 喝点什么 拥抱你的家人 喂一下你的狗 做些别的
不要自己做安全方面 你就是不够资格
那么
而应该
我想考虑的是
在你的组织里面有人受雇做这方面的
你应该相信他们
而且 也有像 Spring Security 这样的工具你可以使用
你也应该相信那个
对吧 我们有一整个团队
全职干这个的
因为这些东西非常非常难
有很多我们作为工程师不能理解的东西
作为系统工程师或者是应用程序工程师
额 对于我们来说完全是陌生的
但对于普通的安全工程师而言却很有意义的
额
这有很多的应用案例出现
在应用程序开发的世界
我们只是认为那是理所当然的
这因为安全与响应式编程的交互而变得更糟糕
哈 那么……
开始时候使用 Spring Security 理想的话 雇一个团队
确保他们也使用 Spring Security
我意思是安全专家 额……
当我们使用 Spring Security 构建一个应用
我们关注两件事
这些都是正交的顾虑
它们互相之间并不相连
这些是 额…… 授权
那也就是说我可以做什么？
当我进入到系统后
我能够访问哪些资源？
通过…… 额 通过哪个……
我能通过哪个门在屋里穿行？
给定一个钥匙 基本上是这样
那是授权
然后我们有身份认证
认证回答了问题
谁在发起请求？
John? 还是 Josh 或 Jane?
是谁发的请求？
他名称是什么他的身份是什么
那个正在敲门的人
你可以使用其中一个去通知另一个 例如
我可以说噢 那是 Josh
Josh 有 你懂的 Josh 是好朋友
他可以进来这个房间
例如 可能那是其他人呢
你不是特别相信他们的 你懂的
你不想让他们看到
你的笔记本上的 PHP 代码
你们之间还没那么亲密
所以
所以你不会告诉他 对吧
他们并没有那个权限
他们没那个权限 那就是授权
Spring Security 处理所有这些正交的顾虑
这些顾虑
这些事相关的但是不是同样的事情
现在想一下认证
让我们将观念切换回那些基础的认证概念
我们在认证方面的目标是
获取一个从外界进来的请求
然后将那个请求变成一个东西
那可以告诉我们 是谁在发起请求
所以我们要将进来的 HTTP 请求
进来的对服务的请求 不管是什么吧
然后将它变成一种标记
关于请求者的
某些 Id
我们要请求获取身份认证
关于请求者的 有很多种方式实现这个
你可以做基于 x.509 的相互认证
基于证书的认证对吧
这是其中一种方式
你可以做基于表单的用户名/密码认证
你可以做 HTTP basic 用户名/密码认证
对吧
你可以做各种不同的事情
你可以有 cookie “记住我”之类的东西
你可以使用令牌
你有对应着某些身份认证的令牌
那会从一个认证服务器那里解析的
使用 OAuth
很多不同的方式可以达到这个特定的目的
可以做到对于给定的请求
这是 Josh 这是 Jane
OK?  哈
然后取个简单的例子
然我们讨论一下用户名和密码
如果请求中有用户名和密码那会怎样？
不管是一个表单 还是 HTTP basic 请求
当用户名和密码进入到系统 你提取用户名
然后你有密码
然后你要跟某些东西对比
然我们假设你有一张表
OK 一张 SQL 表
充满用户名和密码
所以当请求进来的时候
请求进来
然后我们有密码
然后这个密码 额……
是加密的
当请求进来时
没有 对吧
那是未加密的对吧
你需要那样做 你要加密
对吧 基本上是
你要这样做的原因是
但愿在你的 SQL 表里
所有东西都是加密的
那是加密的吧？
OK 我要……
喔…… 我才不会使用你们的软件呢
看起来只有五个人
剩下的人 你们吓到我了 额……
这是怎么回事 我以为
大家都会喊 yeah
但是
但…… 没所谓吧，额
是的 哈哈哈
嗯……
那么…… OK
但愿你的密码以某种方式加密了 对吧
而且…… 因为它是加密存在数据库里的
类似地你也需要对进来的请求中的密码进行加密
并比较它们
对吧，你可以要做
选择所有的用户名和密码并查看
passwordEncodes.equals 那个请求的已加密的密码
如果那为真的 你可以接受进来的请求 说
这真的是
额 你懂得 他所说的
是真的 对吧？
OK
那么关于密码加密怎么说？
那是什么原理 额
密码加密
就是前面提及的几样东西之一
我们早前提到的
会耗时间的
通常是 CPU 密集型任务
目前
Spring Security 使用的是 BCrypt
作为默认的密码加密器
它支持十多种不同的密码加密方式
但在目前 2019 年默认的密码加密器
以后可能会变的
如果你在看这个视频
在 2020 年
或者甚至是下一周
对吧 我们现在是 2019 年 11 月初
但是
因为安全领域经常发生变化
你并不知道这些东西会不会变得过时
有些时候某种加密方式很正常 然后
然后不行了
它们会被破解
不再可接受的了
所以 就目前而言 BCrypt 挺好
BCrypt 是非常 OK 的密码加密格式
那是 默认的 额
然后 还有它是 CPU 密集型的
那意味着 它要花费时间
它是计算上不高效的
你要坐在那里 等待结果
为了等待加密
要花多长时间取决于你
那是编码强度的维度
你可以配置的
有点像调整杠杆
去取得更强健的秘密或不那么强健的密码
强度越强 花费时间越长
可能要一秒 也可能要两秒
你不知道的
关键是当那正在发生的时候
我们的服务会发生什么？
你在阻塞
你坐在那个线程上 你在阻塞
这正是我们在响应式系统所不希望的
OK 那么……
现在我们将坏消息放到一边了
对吧 那可能会阻塞的
你觉得 Spring Security 在这里能做什么？
Spring Security 所做的是
当它准备要做用户认证的时候
它 创建... 它使用……
它使用后台线程 它使用调度器
它从主线程池中移开
这就是我们所能做的
对吧
这就是我们所能做的
不可能在加密算法上实现响应式的
你所能做的就是将它移到一边
那就是 Spring Security 所做的
那么好消息是
在坏消息中有个好消息 好消息是
那就是你
所有不同的认证技术和不同的
你用惯的东西
使用的这些不同方法
用于在 Spring Security 当中做用户认证的
某些依赖一些加密算法
所有这些机制
这些你可能早已经熟悉了，如果你有用 Spring Security
它们的所有
继续能用得好好的
基本上不用修改
在响应式的世界里
这是好事
坏消息是
所有的这些
你所熟悉的东西 所有的
这些做加密的技术
毫无疑问 你们肯动用过当中一些
继续能用
不用更改
在 Spring Security 当中
这有好有坏对吧
额……
这的确意味着你要特别注意将任务移到其它线程
在这个例子中 Spring Security 为你做了这件事
OK 但我早期提到
这是你需要注意的问题
移开或隔离此类阻塞的交互
OK 你有用户名和密码
但顺便一下 也有替代方案
对吧
有不少基于用户名与密码认证的替代方案
嗯……
而且重要的是
要留意这些选择
对吧，其中一种选择是使用 OAuth
OAuth 是非常适合的
额 因为
你做的是获得一个 Token
一个 Token 进来
然后你要根据授权服务器验证那个 token 对吧
或者是一个已被加密的 JWT
已经被验证了的
基本上是一个自验证的
但是 额……
不过哪种方式至少都会与实际干活的第三方有交互
去验证 用户名和密码
但只需做一次
如果那是一个授权服务器
是在第二个节点完成的
更好的是 如果你购买基于云的服务提供者
例如 okta
他们会为你做加密
当你支付 okta 或者像 okta 的机构
去作为一个 OAuth HUB
你实际上是购买他们的安全服务
这其实很好 因为有整个团队全职干这件事
但你实际上也购买他们的 CPU 周期
你给钱他们为你做这个占进超的操作
在他们的计算机 而不是你的
对吧 这实际上挺划算的如果你那样想
你购买的不仅是他们的知识 还有，你懂得 CPU周期
现在
额 那是其中一种选择 
你可以使用 你可以使用那个
请记住，让你的安全人员在队里很重要
这方面我可以一直讲好几年
请记住 很多事情 我们觉得合理的
其实不是
让他们也加入决策过程是好的
我再次猜测才学到
几乎都要猜两次才中
你懂得 你不会清楚安全的兼容性
关键点是 如果用户名和密码进来
然后我有这个密码想要
我想要加密并针对请求的密码进行校验
我要做什么 我获取那个密码并加密
然后我对数据表做一个选择全部操作
然后 username=? 以及 password=？
我看一下那个东西 如果我够聪明的话
作为一个系统工程师 一个应用工程师
我说 OK
你知道吗 每个密码加密需要 2 秒钟
我会给我自己更多一点时间
我要短路求值那个验证过程
我准备说 select * users where username=?
如果那个用户不存在
那就不用管密码了
对吧 如果用户名不存在
就不用管密码了
听起来非常合理对吧
我之前就是这么干的
但从安全角度来看完全是错误的
黑客利用这一点 别人想黑你的系统时
别人利用这一点 说 噢 好你有一个登录页面
如果用户存在需要2秒登录
即使密码错误 但如果用户不存在 就不花时间
所以他们可能不知道你的密码
但他们现在知道 jlong 存在于数据库里
例如 对吧
这是时间相关黑客 这我以前都没想过的
但安全人员会考虑到 Spring Security 会返回假 密码
如果不匹配的话
这个例子 总会是两秒，不过什么情况 对吧
现在
额 那是
现在已不是非此即彼
所以我们要做的是
讲 Spring Security 加入到我们的应用
然后我
我要这样做
使用你可能用到的最坏的东西
我没时间为你设置 Active Directory 或是
或 SAML 或
或是 OAuth
所以我们只做 基于用户名和密码的加密的东西
硬编码密码， 别这样做
千万别这样做
所以 我们要写 fun...
OK 我们的认证
将会是一个 MapReactive...
而现在我要加入 Spring Security 依赖

### 讲了安全方面的情况 主要还是 Spring Security

OK 就是这样
好
将会给我一个 MapReactive…… 电脑干活吧
然后我们要创建一些用户 我写User...
这个方法
是已经过时了 这个函数是过时了
额 它基本上
你可以看到
没有将其移除的计划
对吧
但它不是安全的
它只有在做演示的时候才是可以接受的
嗯哼
嗯 所以它会使用默认的那个
在目前也就是 BCrypt 对吧
如果你将所有的数据存到数据库
以 BCrypt 的形式，今天的话
然后到明天默认的换了其它的话
量子 BCrypt 之类的
那样子突然就没人能登录进系统了 对吧
因为你使用不同的加密方式
那就是为什么你要指定需要使用加密方式
就我们的目的
因为我实际并没有与数据库交互
只是在内存的
那没关系的
OK? 现在
我们创建一个用户名
还有一个密码
OK？
还有就是
我给自己一些角色
USER OK？
好东西 看看那
现在
我也添加 Spring Security 的领头人 Rod Winch
而他 我相信他保护我的数据
还有我的生命
隐式地
所以我们这样做
关于这个 demo 有趣的方面是
我在这边为你演示的
这个 demo 我做过不少次
我经常到处飞
每年我都尽量去多点地方
我尽量访问更多的人
额 你懂得在全球范围内
而那会让我有的忙的
我已经访问了 三十多个国家 有时候更多
每一年
每年都去很多很多城市
成百成千里路
从北美来到这边就已经要 600000 英里了对吧
所以我尽量去适应
我设法接触更多的观众
所以我在不同的时区都做过这个 demo
现在我们在欧洲 现在是
这离我所在的州不是很远
Rod Winch 住在堪萨斯州 美国本土正中心
有时候我在其它国家做这个 demo 我去到更远
到东边 例如我去东欧
我去亚洲 我去中东
我去世界各地 你懂的 我去
澳大利亚 比如说
似乎不管我在哪里做这个 demo
与我在哪里做这个 demo 无关
我注意到的一些事情是
那
每次我做这个 demo
不管我在世上何处
一些奇怪的事情发生了
似乎不管在何处都会发生的
不管我在哪个时区
只是很奇怪 每次我做这个 demo
我在这边硬编码写死用户名和密码
在舞台上
每次我现场做这个 demo
在地球上的任何地方 不管在哪个时区
一些真的非常奇怪的东西
开始发生
每次我做这个 demo
因为他无法理解
由于他不必要理解的原因
Rod Winch
在每次我做这个 demo 的时候
在台上将用户名和密码写死在代码里的时候
每次我做这个 demo Rod Winch 他
开始回复邮件
每次我做这个 demo
Rod Winch 开始回应 Google Hangout 和 Slack
或在 Twitter
他开始发起 Pull Requests
不管我在世上何处
只是看起来
每次我做这个 demo 的时候都会成功
他就突然出现了 不管是在什么时候
Rod Winch 是一个顾家的人
他有好的妻儿 他应该睡得很好的
有时候 对吧
你觉得
但不管什么时候 我做这个 demo 时
他开始睡不着
每次我做这个 demo 
我写死用户名和密码到代码中时
由于一些 Rod Winch 没法理解的原因
Spring Security 领头 Rod Winch 不必要理解的原因
每次我做这个 demo
当我在台上写死用户名和密码到代码里
Rod Winch Spring Security 的领头人
开始难过
这将他唤醒
睡得那么沉的时候
他没得选择 只好干些活
因为他不知道那是怎么回事
所以我的朋友们
不管你做什么 我无法强调更多了
不要让 Rod Winch 难过
不要做这样的事情

### Authentication

现在
我们要
也要做授权控制
OK？ authorization...
然后我们使用 ServerHttpSecurity 构造器 就像这样
然后写 http.
我们要启用一些东西
我想要构建它
这很好
我将要
使用 HTTP basic
OK 我想要 HTTP basic
很好 我要写 HTTP basic
定制化它 这里的类型是什么？
这是一个定制器
然后 withDefaults() 好
我要禁用 csrf()
因为在这里我不需要
所以我写 Customizer
Customizer...
OK
额 it...
.disable()
OK 只是一个 lambda
我可以这样做
嗯 我想要设置一个
授权交换器
OK 当请求进来时
我想要允许
anyExchange()...
可以被访问
当我们要限制一个端点
当 .pathMatchers...
/proxy
是一个
被允许的
额 不好意思
当你发起一个请求到 /proxy
我需要它时被认证的
其它东西都可以通过
但这个端点会被锁住
而且这是特别重要的 因为
这个需要出现在前面
我想要确保 我们先匹配这个
然后是通配符其它所有东西都匹配了
如果这个放在下面这里
那么我们不会有机会到达这个规则
因为它会匹配第一个
OK
所以很重要的是最具体的规则
放在前面
所以这是默认的配置 OK
让我们看一下那会怎么样
好了
这就是结果
你可以看到这是 401 Unahuthorized
Basic realm="Realm"
我需要认证 OK 所以
-vu jlong:pw 设为 http basic
当我这样做时
我在下边这里获得了数据 这是 JSON
随着我发起请求 我接收到 3 个首部
表示我限流的容量
X-RateLimit-Burst-Capacity
以及 Replenish-Rate ...
OK 那么现在
我想要获取一些流量
但愿会超出它的限额
在我发起请求的时候 你可以看到我使用的是
额 稍微切换下
负载均衡器
额 不好意思 负载生成器
当你那样做的时候你可以看到
429 Too Many Requests
它正在拒绝请求
因为它超出了一个很小的限额
我只是指定 5 个
那样的话我随便用 Bash 就可以超了
然后其中一些能通过
你可以看到
所以这边有一个通过了
所以这是每秒5个对吧
你看这边 你看 你看
然后最后结果是 429
对吧 所以每5个请求能通过
然后在那之后
请求被拒绝

### 限流器的演示

OK 非常常见
非常简单地运行
Spring 给与我们能力
你懂的做各种有趣的事情
现在
目前 我已经使用了
Java 的配置风格
然我快速地指出 在 Kotlin
我们有
好的 设施
你可以在 Java 里面做的 但为了好玩
我会在这里创建一个 context
context
OK 然后我要添加
我的 Bean
我要像这样添加一个 Bean
所以你可以看到 Bean
你可以注册
其它 Bean 例如这个 RateLimiter
我可以按这种方式注册
我可以说
Bean 然后删除那个
这实际上是函数式风格的注册
所以我可以说
addInitializers...
context
然后 哇啦 OK？
这实际上是一个函数调用
所以我可以做 if
if (Math.random() > .5 ) 对吧
那样的话这个 Bean 不会被注册
如果小于则会 随意吧
如果它是大于的就会被注册否则不会
你可以选择任一风格
实际上这些东西可以混合搭配的
唯一的问题当然是
通过将它取出来
使得我现在得要注册这个 Bean 
作为一个参数 所以 redisRateLimiter...
你可以混合搭配的
OK 随你便
现在我们有
函数式的响应式端点
我们有 API Gateway
我们使用 Spring Cloud Gateway
我们看了 看了响应式……
我们看了在响应式编程上下文中的安全
我们看了API Gateway 不同的过滤器
当中包含限流器
现在让我们来讨论一下 API
额 适配器
API 适配器是一个东西将进来的数据
然后它有点知道荷载中是什么
它知道如何操作或者按某种方式转换
处理那个进来的荷载
并在更改之后继续转发 OK？
一个 API 适配器
额 不是一个特别的东西
你可以只使用普通的函数式响应式风格
我实际上可以
在这里使用函数式响应式风格
然后你看到我在前面的 Java 代码也是这么干
这些是 DSL
你可以想象到的
对于此类东西
在 Kotlin 的世界里
所以我们只需要写 router...
我可以写 ...
我可以产生服务端响应
OK？
所以在这边我产生一个响应
额 那是
基于进来的名字的
基于那……
我要通过调用下游预约服务产生响应
为了要调用那个 Web 服务
我要使用 WebClient
那个 HTTP 客户端，像这样
然后我要调用下游的服务
我写 webclient...
当数据进来的时候
我将会对此修改 我将其转变成一个发布者
类型为 Reservation 的
我可以用 Java 指定
我可以指定为
类型字面量 即 Reservation.class
但在 Kotlin 我可以有这个疑似泛型的东西
我可以提供泛型的参数
但你发现我的类路径中没有那个类
用那个类型
被创建一个数据类型
创建为 data class
val id...
这是一个 Integer
然后是 val name: String 作为 DTO
所以就是这样
你可以看到 IDE 在提示我添加这个扩展函数
那允许我指定泛型参数
然后它知道那是什么
因为有点
验证并在运行时捕获泛型参数
我不需要指定一个类型记号
例如 Foo.class
所以 Reservation
reservaions...
好吧这是一个 发布者
类型为 Reservation
所以这是我的
已更新的代码 让我们看一下有这个
好
实际上我并不需要它 对吧
这是多余的 如果我移除它
保留这个移除那个 一样可以
这是同样的东西
编译器能够知道 随你
所以这是我的 reservations
我所要做的是将它发送回来
那个 Reservation 我实际上想将它 map 到
我只需保留名字
其它的都不需要 OK?
我将要写 reservations
你可以看到那里还有另一个扩展函数

在函数体中的第二个参数
嗯 函数或方法
是发布者的类型
所以 findAll 返回
一个发布者
类型为 Reservation
但是因为泛型
因为 Java 泛型的缺少
在运行时没办法让我捕获
那个泛型参数
我没法说 嘿
T.class 是什么
对吧 不存在的
但这是 Reservation.class
我得要将它传进来
在 Kotlin 我不用这样
我可以只说
<Reservation> 然后它能捕获
在编译时
被捕获并为我写在代码中
就像我显式地写了类型 token
所以这是我的函数时响应式端点
非常简单的 HTTP 调用 然我们确保它能用
让我们看一下得到什么
注意我跨越线路进行网络请求
嗯 首先
我写死了这个主机和端口 这是好主意吗？
可能不吧 我应该使用
负载均衡器 噢 我需要
一个 WebClient Bean 让我们在这里创建一个
fun webClient...

### 一点关于 WebClient

额
OK？
所以现在我们有了一个 WebClient
让我们看一下 我启动这个
我写死了这个用户名和密码
额 这里这个主机名
你不应该这样做
如果你使用 Spring Cloud 和服务发现客户端
你可以使用 Apache ZooKeeper
或者是 Hashicorp Consul
或者是 Eureka 随意吧
你可以说 lb:...
对吧 那实际上是
或 你甚至可以使用 HTTP
不好意思 那只是 http 你可以那样做 对吧
但我写死了用户名和密码
即便如此 让我们假设我做对了负载均衡
如果没有实例可用 没有服务可用怎么办
如果某些东西出错了 网络断开之类的
额 这里有些操作符可以使用
说 OK 例如 onErrorResume...
然后返回 Flux.empty()
如果某些事情出错
我可以控制返回的发布者
非常方便
而如果某事出错 我们可以重试
我可以重试十次
我可以重试十次
然后指数回退 OK
指数式退避 这里发生的是有点跳动
因为那样你想要避免
瀑布式重试风暴 对吧
如果我的服务重试
一秒后重试会发生什么
它重试如果还是失败 就2秒后再重试
3 秒后再重试 直到 10 次
但不是准确的 1秒
想象 5个客户端同一时间发起 5 个同样的请求
结果会
你懂得 扩散那个 失去那个服务
所以要确保我们避免这些
所以我们有回退
额 在 Backoff 里面
你可以做很多有趣的事情
你可以做更多有趣的事情确保你的服务
可以承受一些失败
我喜欢 Backoff 和 retry
另一个你可能使用的是 Timeout
这是非常常见的东西在这里使用超时
问题在于 timeout
它们并不是特别公平对吧
它们是有点
它们是有点不太友好
如果你这样想 想象下
我的服务要调用另一个服务
然后另一个服务调用另一个服务
我的服务在这边提供 9 个简单的路由
是 20 秒 这很不正常
如果你的服务访问要 20 秒
恭喜 你的工作是世上最简单的工作  对吧
你可以在 20 秒内做任何事情 对吧
还是 假设你的服务提供需要整整 20 秒
然后你还调用另一个服务
那个服务要返回到给你
要多快？
我会说 10 秒 对吧？
如果你设置超时
你可以确保你在十秒内超时
然后再试多一次
直到你的服务能够被访问到
在破坏服务协议之前
所以你要将它除以二
那样你可以重试两次
对吧 你调用的东西如何?
如果那个东西调用另一个服务
它要在两秒钟内响应
这意味着它调用的服务要在
5 秒内响应 对吧
所以这变得很不公平 想象下很差的服务
在那之后
要在两秒半之内响应
最终这会变得不堪一击对吧
所以 timeout 是最后的选择 它们能用
但是最后的选择
对吧 我并不想
将我整个系统构筑与超时判断之上
而是一种常见的分布式系统模式
额 谷歌首先提出的 然后 Uber 和 Netflix 都使用
称为 服务对冲
这个 hedging
所以 当你 当你
去一个赌场
我不知道这里是否有赌场
如果你赌博
这是种坏的
这是一种坏的策略
孤注一掷
你希望分散赌注
你要确保将风险分散
将风险分散到各个可能的投资对吧
你想要保留选择
所以分散赌注意味着
你只是分散了风险
这边也是一样的
这就是我们将要做的
分散投资
通过不发起同样的请求
到下游服务
所以我们要做的是
让我们将这代码移到这里
让我们重写这个代码
让我们假设我有
在这边假设我有个调用
val call1 =... 然后这是个发布者
Flux<String>
然后我们不知道这将会来自哪里
//todo OK?
我假设你会在那里发起个网络请求
OK call3
还有 call2
OK？
现在我有它们三个
我想要第一个
我想要在同一时间发起三个请求
而我可以这样做记得是因为
我们有调度器
调度器可以在同一时间发起三个请求
请求会发出去
当返回时 我想要返回的第一个响应
其中一个可能失效
其中一个可能去吃午饭了
你不知道 可能垃圾回收了
可能停止了 不管什么
那个服务现在不可用
而三者之一肯定是可用的
而我使用 3 作为一个简单的数字
你可以用个 for 循环 然后选择一些数字
你可以使用 Spring Cloud Discovery 客户端
去询问服务注册表
你懂得 zookeeper consul eureka 随意吧
你可以说 嘿 服务注册表
给我 x 个实例
给我 20% 的容量
不管是啥 对吧
但让我们假设我想要第一个
我想要第一个的原因是因为我想最快的
第一个开始发出值的发布者
那就是我想保留的
所以我写 Flux.first(call1, call2, call3)
OK?
他所做的是要保留第一个发布者
然后 它取消管道的被压到其它两个
现在我不用浪费时间
在不会产生结果的数据流上面
然后我尽快获得最快的结果
OK?
这是很常见的策略
而且很容易实现

### 超时、重试、分散风险

但想象一下不用响应式 API 实现的话
你所做的是一种竞争状态
定义上来说 这是一种竞争状态
你实际上希望
某些事情会出错
某些事情会先发生对吧？
当你没有注意到
这并不是你想写的代码
在一般的多线程代码
你没有见到
任何的 Phaser、Semapore、CoutDownLatch 或是 CyclicBarrier
或是线程
或是 Executors 在这代码里
然而它们肯定都存在在那里
还有请记住 这不是希望的消息
记住 只有一个人真正懂得如何写多线程代码
而 那人不是你
这就是最关键的
那不是你 是谁不重要
只是不是你 好吗？
将它交给框架吧
尽管如此 相信我们
我们也不敢保证百分百没问题
对吧 我们很肯定
这已经是久经考验了
被一些业务专家 但 你懂的
这些东西易出错
OK 额 现在
顺便说一下 你记得 Java 5 吗
那个 双重锁定模式
他们发现那个继承上来说是不安全的在 JVM
在 Java 5 之前对吧
甚至是 JVM 甚至开发 JVM 的人
发现他们的多线程代码有个bug
在我们所依赖的 5 个版本的 Java 对吧 嗯
所以我们有了这个响应式 API
有边缘服务 也有这些可以使得代码刚强健的模式
这是非常自然的表达在响应式的世界里
所有这些我觉得很有趣
其中一样我可以讨论的是断路器
我在这里并没有引入断路器
因为我们并没有足够的时间
但你可以使用一个项目叫 Spring Cloud Circuit Breaker
它支持响应式断路器
它有四种不同的实现
阿里巴巴 Sentinel
Spring Retry
还有 Hystrix 当然还有 Resilience4j
你可以很容易地使用它们包装
这个特定的调用到断路器
如果出问题了
它会重试 重试 重试
你甚至可以让它重试直到某些条件为真
通常那会是一个布尔量 系统某处的一个开关
可以禁用某个路径
所有这些都很有趣但是
断路器我认为是问题的症结也就我们没有更好的方式

### 讲响应式编程模式比传统自己写多线程的优势

我在这里给你展示的很多东西
是基于没有更好的方式构建更好的服务
目前我给你展示的所有都是基于 HTTP 的
我也挺喜欢 HTTP 的我希望它一天能成大事
但我不知道这是否是服务的最佳选择
是获取文档的很好选择
当做服务的时候我们还可以做得更好
对于有状态的连接
对吧 我想有更好的东西
更快的异构的服务环境 我想有更好的东西
有很多组织想要解决这个问题
Google 方面创造了 gRPC
而那促进了很多 HTTP 2 的变革
而 gRPC 默认并不是响应式的
它支持异步 但不支持响应式
在硅谷有家“小公司” SalesForce
他们为 gRPC 创建了一个插件
是一个 gRPC 的编译器插件
会创建基于 Reactor 的服务
有点意思实际上你可以
代码生成 而不是默认的gRPC代码生成
你代码生成基于 Reactor 的服务
我喜欢那个 但在我看来
我认为 gRPC 不是准确的好选择
首先它要求用 HTTP 2
HTTP 并不支持多路复用
那是流水线的但跟实际支持多路复用不同
而且它还要用到 Google protobuf
所有东西都需要以 Google protobuf 编码
所以我推荐一个叫 RSocket 的东西
在最后几分钟将会看到的是 RSocket
RSocket 是由 Facebook 创建的二进制协议
这是一个原生支持响应式的二进制协议
由从 Netflix 后来到了 Facebook 的人创造的
而且 这是一种开放的二进制协议
因为它是开放的 而且是二进制协议
谁都可以使用 有客户端
包括不同的语言
包括 C++ 包括 JavaScript
当然包含 Java
当这个来自 Netflix 的团队创建 RSocket
一直在搞 RxJava
很多年了 并了解
那个技术的扩展
当那个团队来自 Netflix
决定创建 RSocket
他们为 RSocket 构建一个 Java 客户端
很自然地
搞 RxJava 的这个团队 顺便提一下
那是一个与 Reactive Streams 规范兼容的框架
RxJava 2 及其后版本 现在是 3
这些都是响应式数据流
很自然地那个团队
来自 Netflix 的研究和使用 RxJava 很久了
所以当他们去到 Facebook 他们创建了一个 Java 客户端
RSocket 客户端 很自然地他们选择 Reactor
所以他们这样做了
而 我是开玩笑的 我不知道他们为什么这样选择
我当然感激 因为这使得我们更容易使用它了
顺便说一下 用 RxJava 2 也没有问题
RxJava 很不错 也兼容 Reactive Streams
所以你可以在 WebFlux 用 Reactive Streams
任何返回发布者的
像 Akka Streams 和 Vertex
RxJava 2 可以跟这些东西交互
但是它是基于 Reactor 的 OK?
然后那支持
使得我们非常容易集成
所以我们确实这样做了

### 介绍 RSocket 对比 gRPC

我要做的是构建多一个边缘服务
再多一个 API 适配器
但这一次我想要回到我们的 GreetingService
我要将它变成一个 RSocket 服务
有两件事是必须做的
首先你要写点代码 肯定要啦 对吧 所以
喔
那发生了什么？
Controller OK？
我这个键卡了 感谢苹果
OK 然后是 @MessageMapping
greetings
这是我的 RSocket 代码
不用客气 我已经写好了
现在
为了能这个可用
我要在一个不同的端口运行
7777
然后我运行这个程序
现在 在客户端
我想要消费那个 RSocket 服务
请记住 RSocket 是一个二进制协议
可以做一些你在 HTTP 中不可以做的
首先是
当客户端与服务连接时
当一个节点连接到另一个节点
它们成为对等关系 不再是服务器与客户端的关系
它们是请求者与响应者的关系
一方可以发起会话任一方可以随意响应
任一方都可随意发送多或少
它们可以发送 0 个值 1 个值
一个响应式流的值
它们可以应用原生的背压式
你可以恢复一个 Stream
对吧 我可以拿 10 个记录
然后进入没有WiFi的隧道
然后恢复 取多 10 个记录下来
对于 HTTP
如果我的 HTTP 客户端
不管是否响应式
与我的响应式服务器断开连接
我的响应式 Web 服务 就说 噢
Socket 没了
所有调用都取消了
然后我应用背压式到这个响应式流
然后那会取消响应式流
在我的 MongoDB 或 R2DBC 数据源
对吧 那是传递性背压式 但你只能做一次
用 RSocket 我可以
我可以暂停 可以继续
我可以做真实的响应式背压式对吧
这是非常有用的东西
想象一下它们是省带宽的
如果你知道
你懂的我要穿越一个隧道
我要从这个点开始重新连接
对吧 那么
RSocket 嗯……
额 支持所有不同的消息交换模式
它支持 Fire and forget
它支持数据流输入输出
它支持单个消息入 没有值出
或当个消息入数据流出来
数据流进无消息出 随意吧
但你可以做所有各种消息交换模式
这是线路上真实的背压式
额 它是与荷载无关的
所以 你可以发送 JSON、Thrift、Areon或是 Datapack 随你
或是 Google probuf 这样没问题对吧
嗯 它还有其它的好处
使得它非常适合构建可扩展的服务
假设我们想用 WebSocket 做二进制通信
安全方面如何？
你如何做 WebSocket 安全 对吧？
它是一个
非常简单的问题但不是一个好的答案
如果你首次加载 WebSocket 端点
那里还会有 HTTP 首部的
记得我说过协议升级 更换端点吗
那可以用 HTTP 首部做安全
像往常一样使用 Spring Security
能跑起来了
你如何做安全?
在 WebSocket 并没有首部
在 RSocket 里有首部
你应该有首部传递在范围外的信息
去传输一些像 Token 的东西
这只是一些 HTTP 的基本限制
以及 WebSocket 等其它协议
显然它们并不是为服务而设计的
它们为文档获取而设计的
所以 RSocket 克服了很多缺点
它是有状态的连接
很多你体验到的降速
当你使用 HTTP 的时候 是因为你经常连接和重连
用 RSocket 的话 你一直是连接状态
一旦已连接 任一方可以发送任意多少数据
一个打开的 Socket 可以处理
同时处理很多很多连接 很多很多请求
这就是我所说的多路复用
所以这是一个很有趣的协议

### RSocket 应用举例，使用场景，对比

让我们在这里构造我们的 API 适配器
再多一个端点 我们称之为 greetings
{name}...
然后在这里我要调用下游的 RSocket 服务
然后我将要返回一个请求数据流
但我要将它通过服务发送事件返回给客户端
OK? 所以
我要在这边注入我的 RSocket 客户端
fun rsocketClient...
builder 额不好意思 RSocket...
随意吧
builder...
RScoketRequester...
.connectTcp... 我们只是想连接一遍
例如我可以这样做 OK？
这就是我们的 RSocket 客户端
现在
现在我要注入 RSocket 客户端
所以我写
在这里写 rsocketClient
好吧 RSocketRequester
然后我发起请求 rsocketClient...
然后端点是 greetings
而我要传入的数据是
是 greetings 请求和响应
什么……
这是什么？
这是之前打开的东西
我已删除了
OK 所以这是数据
额 val request
那会是一个“问候”的详情 我也要在这里创建
data class GreetingRequest(val name:String)
还有 GreetingResponse
现在是 GreetingRequest 和 GreetingResponse
greetingRequest 然后 name
我从当前请求的路径变量中获取
所以就是这些
我会将它传进这里 我写 request...
然后返回的数据会是 stream
我会返回类型为 GreetingResponse 的发布者
val greetings
好吗 好东西
greetings
好的 这就是我的数据
所以这是我全部东西
当然这将会是一个服务发送事件流
所以我发送回一个 contentType 去告知框架差异化处理
MediaType...
然后运行
好吗 那么现在
打开浏览器 访问 localhost:9999
/greetings
Devoxx
它会产生响应
每一秒 不间断地
通过网线 你懂的 不浪费时间
一直到永远永远
请记住为了得到那个服务发送事件流
在这个 9999 端口
我做了一个 RSocket 调用
到 端口 7777
那是 响应式地发送不间断的数据流
这就是能用
对吧 这是一个二进制协议 我在最后将它变成了 JSON
这有点可怜
但 你可以看到正在发送什么对吧
现在 RSocket 有点意思
有些有趣的组织
已经开始使用了 它已经被整合到 Spring 5.2.x了
以及 Spring Boot 2.2 两个都 GA 了
所有东西我给你展示的
实际上所有东西除了 Spring Cloud Gateway 都是 GA 的东西
甚至我展示的 Spring Cloud Gateway 都是GA 了
你可以像在旧版本中那样使用它
但我现在使用的是一个非 GA 版本的 Spring Cloud Gateway
嗯 RSocket
正如我所说 是起源于来自 Netflix 的人的
所以当他们去了 Facebook
有了一些有趣的可能性
我们有新的 RSocket 支持
在 Spring Cloud Gateway 
其中一个很有用的使用常见 想象下你有
RSocket 网关作为一个汇集器
请求去到 Spring Cloud Gateway 端点
然后它们转发请求到其它的节点
想象这些其它的节点
完全是黑箱子
没有入口的 完全封锁起来的
没有办法对它们发起请求的

当它们启动时它们打开一个rsocket 连接到网关
然后网关会将它们路由到其中某个可用的节点
其中一样网关可以询问这些节点的是
嘿 你的健康状态如何?
你的可用性如何？
你们有多少人使用 Actuator？
Spring Boot Actuator
一系列的 HTTP 端点你可以用来询问个问题
你健康吗 你的启动时长是多久 状态怎样？指标如何？
那些信息
时已经内建在协议中了
在协议中有一帧
用于广播应用的健康状态
所以智能客户端可以看到它然后
你不是那么忙吧 我要将请求发给你
这就像背压式的反转
而不是客户端控制流量
现在服务它自身可以广播它自身可处理请求的可用性
这就是网关的作用
最好的安全方案是你不需要担心的方案
这就是这特定的组合给你带来的
与网关的整合非常吸引人
如果我有更多时间 我甚至可能会演示下

### 演示完 RSocket

但恐怕 我的朋友们
我们就要没时间了
快速的问题 谁玩得开心？
好东西
谁学到东西了？
哇我很开心几乎大家都举手了
那让我开心
很显然我玩得开心 我穿着 Spring T恤
还有 Spring 内裤 我当然开心
我热爱这些东西 对吧
当我的朋友们
你不必只是听我在吹
很多公司都已经大规模应用这些东西了
我讲所有这些东西
我花了很多时间跟不同的机构交流
在世界各地
我在巡讲
这个月下旬 我会到中国的四个城市
跟 Netifi 一起，另一家搞 RSocket 的公司
还有 我会去阿里巴巴
另一家公司全是用 Spring 的
即使它只是中国的一家“小”公司
我相信它某天会壮大的 额
它们上一年做了 300亿美金 销售额，不好意思是上一年一天的
他们做了 300 亿美金销售额
你们…… 知道吗？
好吧 只是好奇 了解一下
他们都是用的 Spring 他们都对 RSocket 很好奇
好的 我的朋友们 嗯……
希望你们学到些东西 我很乐意回答问题
感谢你们的时间 我后面还有两个讲座 一个讲Kotlin 一个讲测试的
如果你想了解如何测试这些东西的话
你绝对也应该来看看那个
非常感谢
祝你有美好的一天
记得投票!
我想有机会再回来 你要给我投票噢 拜托了

### 结尾