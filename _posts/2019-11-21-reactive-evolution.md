---
typora-root-url: ../
layout:     post
title:       响应式变革 Reactive Evolution 2019 ~ 2020
date:       '2019-11-21T08:10'
subtitle:   根据龙之春 Josh Long Devoxx Belgium 2019 演讲整理
author:     招文桃
catalog:    true
tags:
    - Reactive Programming
    - 响应式编程
	- Spring WebFlux
	- Spring Cloud Gateway
	- RSocket
	- R2DBC
	- Kotlin
---

## 首先是原始版字幕（未完整）放在这里方便整理

演讲分为两个部分，两个部分合起来总时长两小时四十五分钟，翻译字幕制作起来很吃力，只是一个人在肝。希望赶在今天下午之前完成初次审核。

---

一下为字幕内容（srt):

1
00:00:03,566 --> 00:00:05,066
好的

2
00:00:05,066 --> 00:00:06,266
好东西

3
00:00:07,366 --> 00:00:08,799
进来吧 找个位置坐

4
00:00:09,100 --> 00:00:10,166
前面还有些空位

5
00:00:11,233 --> 00:00:11,899
如果你……

6
00:00:13,266 --> 00:00:14,066
如果你想坐前面的话

7
00:00:19,233 --> 00:00:20,633
等人进来

8
00:00:20,700 --> 00:00:22,366
进来吧 好的 好东西！

9
00:00:22,466 --> 00:00:23,632
我们没多少时间

10
00:00:24,066 --> 00:00:24,466
额……

11
00:00:24,733 --> 00:00:26,366
我让他们给我一天

12
00:00:26,866 --> 00:00:28,166
而他们只给我三个小时

13
00:00:29,033 --> 00:00:29,533
所以……

14
00:00:30,066 --> 00:00:31,066
我意思是二十四小时

15
00:00:31,100 --> 00:00:32,800
所以他们说，“你意思是八个小时吗”

16
00:00:32,800 --> 00:00:33,866
我是指二十四小时

17
00:00:34,433 --> 00:00:36,233
嗯 他们没给我那么多时间 他们只给我三个小时

18
00:00:36,333 --> 00:00:37,999
所以我们只有很少时间 朋友们

19
00:00:38,233 --> 00:00:39,199
非常少时间

20
00:00:39,400 --> 00:00:41,300
然后有很多内容要讲

21
00:00:41,300 --> 00:00:43,033
所以我很感谢你在这里听我讲

22
00:00:43,033 --> 00:00:45,066
你有很多的选择 你本可以在……

23
00:00:45,266 --> 00:00:46,499
其它的很多地方

24
00:00:46,700 --> 00:00:47,666
你可以趟在床上

25
00:00:48,000 --> 00:00:49,066
那是个好地方

26
00:00:49,300 --> 00:00:53,066
额 你可以在……

27
00:00:53,066 --> 00:00:53,632
家里

28
00:00:54,366 --> 00:00:55,899
你懂滴 有很多地方可以去

29
00:00:55,900 --> 00:00:57,233
但是你们在这里 我很感激

30
00:00:57,400 --> 00:00:59,466
所以 牛逼 早上好 大家好吗

31
00:01:00,700 --> 00:01:02,066
噢 这很糟糕

32
00:01:02,933 --> 00:01:04,866
很糟糕！ 再来一次 早上好！

33
00:01:05,433 --> 00:01:06,766
这就对了

34
00:01:06,800 --> 00:01:09,466
牛逼 我接受这个 虽然我们可以做得更好

35
00:01:09,700 --> 00:01:10,600
嗯……

36
00:01:10,600 --> 00:01:14,133
在人陆续进来的过程 我想鼓励你们 像往常一样

37
00:01:14,600 --> 00:01:16,900
像往常一样 我的演讲的第一页幻灯片

38
00:01:17,200 --> 00:01:18,766
最重要的一页

39
00:01:19,000 --> 00:01:20,733
在往后的三个小时内会看到的

40
00:01:21,033 --> 00:01:22,499
就是现在的这一页

41
00:01:22,500 --> 00:01:24,600
这一页包含了演讲的题目

42
00:01:25,000 --> 00:01:25,966
所以你知道你在哪场演讲

43
00:01:26,333 --> 00:01:28,833
包含我的名字

44
00:01:29,066 --> 00:01:30,599
你知道演讲的人是谁

45
00:01:30,833 --> 00:01:32,633
上面有我的坐标

46
00:01:32,633 --> 00:01:33,699
 所以你有什么问题的话

47
00:01:34,400 --> 00:01:35,233
当你……

48
00:01:35,300 --> 00:01:36,900
不免会有些疑问

49
00:01:37,233 --> 00:01:38,699
你知道如何联系我

50
00:01:38,700 --> 00:01:39,933
所以 我在网上

51
00:01:39,933 --> 00:01:42,366
我在网上 我很乐意回答问题

52
00:01:42,433 --> 00:01:43,133
有多少人

53
00:01:43,333 --> 00:01:43,933
顺便问一下

54
00:01:44,033 --> 00:01:44,933
有在使用电子邮件的

55
00:01:45,000 --> 00:01:46,066
我一直都很好奇

56
00:01:46,333 --> 00:01:48,066
有多少人……  首先 有多少人用 Twitter ？

57
00:01:48,933 --> 00:01:50,366
Twitter 2019 年了

58
00:01:51,633 --> 00:01:52,099
Twitter

59
00:01:53,400 --> 00:01:55,166
好吧 剩下的人 嗯~ o(*￣▽￣*)o

60
00:01:57,133 --> 00:01:57,733
在忙啥呢？

61
00:01:59,566 --> 00:01:59,999
上 Twitter 吧

62
00:02:00,766 --> 00:02:02,599
好东西 那是新的 IRC

63
00:02:02,833 --> 00:02:03,833
那是个好地方

64
00:02:03,833 --> 00:02:05,533
那是开发者促进开源

65
00:02:05,833 --> 00:02:07,333
促进商业的地方

66
00:02:07,333 --> 00:02:08,433
所以你应该去那里

67
00:02:08,566 --> 00:02:10,732
电子邮件呢 有多少人用电子邮件？

68
00:02:11,700 --> 00:02:12,900
有人用电子邮件吗？

69
00:02:13,500 --> 00:02:14,500
我不是特别喜欢电子邮件

70
00:02:14,900 --> 00:02:15,500
不是粉丝

71
00:02:15,866 --> 00:02:16,299
不过

72
00:02:16,933 --> 00:02:19,133
我倾向于

73
00:02:19,333 --> 00:02:20,633
鉴于 Slack

74
00:02:21,000 --> 00:02:21,966
对吧 我有

75
00:02:22,200 --> 00:02:23,700
额……

76
00:02:23,900 --> 00:02:25,466
相对而言更能接受电子邮件

77
00:02:26,700 --> 00:02:27,966
更能接受 email

78
00:02:28,833 --> 00:02:29,433
所以……

79
00:02:30,233 --> 00:02:32,066
所以就这样 我买了这个 Mac 这个笔记本

80
00:02:32,166 --> 00:02:33,299
上一年我不在这里

81
00:02:33,300 --> 00:02:34,000
上一年我在新加坡

82
00:02:34,000 --> 00:02:35,133
我在有事情在

83
00:02:35,400 --> 00:02:36,133
在地球的另一边 

84
00:02:36,133 --> 00:02:37,599
我想搞清楚航班情况

85
00:02:37,800 --> 00:02:39,433
我没办法两头飞

86
00:02:39,900 --> 00:02:40,933
这不会

87
00:02:41,366 --> 00:02:43,866
这样做 对我或对你都没啥意思

88
00:02:44,200 --> 00:02:45,000
这样的一次旅行

89
00:02:45,433 --> 00:02:47,466
所以我当时在新加坡

90
00:02:47,466 --> 00:02:48,632
很遗憾错过了上一年的（Devoxx)

91
00:02:48,900 --> 00:02:50,766
上一年我买了这个 MacBook Pro

92
00:02:50,933 --> 00:02:52,033
所以上一次我来这里的时候

93
00:02:52,033 --> 00:02:54,233
我用的是一个很不错的 Linux 笔记本

94
00:02:54,233 --> 00:02:56,166
但我这次用 MacBook Pro

95
00:02:56,166 --> 00:02:58,832
它有 32G 的内存

96
00:02:58,833 --> 00:03:00,666
我买这个笔记本的原因是

97
00:03:01,033 --> 00:03:02,799
是因为我怀疑

98
00:03:02,900 --> 00:03:04,166
终于 终于 终于

99
00:03:04,600 --> 00:03:07,333
我可以同时运行 Slack 和 Chrome 了

100
00:03:09,166 --> 00:03:10,166
在同一时间

101
00:03:10,300 --> 00:03:11,800
实际上那是不可能的

102
00:03:11,800 --> 00:03:12,900
用不了的

103
00:03:12,900 --> 00:03:13,566
但是

104
00:03:14,133 --> 00:03:14,899
你发现没

105
00:03:15,333 --> 00:03:18,166
可能我是果粉吧

106
00:03:18,366 --> 00:03:19,799
你看到他们发布新的

107
00:03:19,900 --> 00:03:20,800
Mac Pro 吗？

108
00:03:21,000 --> 00:03:23,700
1.5 T 的内存

109
00:03:24,766 --> 00:03:25,499
噢……

110
00:03:25,666 --> 00:03:26,266
上面说

111
00:03:26,433 --> 00:03:30,066
你可以渲染好莱坞大片

112
00:03:30,166 --> 00:03:31,632
而且你可以运行 Slack 和 Chrome

113
00:03:32,033 --> 00:03:33,766
在那个机器上

114
00:03:33,866 --> 00:03:34,766
所以那很让人兴奋

115
00:03:34,933 --> 00:03:36,733
只需要 32000 美元

116
00:03:36,833 --> 00:03:38,066
不过如果你下次见到我

117
00:03:38,500 --> 00:03:39,533
用一台 Mac Pro

118
00:03:40,100 --> 00:03:42,433
在台上的话 你就知道我想做什么了

119
00:03:42,900 --> 00:03:44,133
我想跑那两个程序

120
00:03:44,566 --> 00:03:45,499
在同一时间

121
00:03:45,933 --> 00:03:47,266
额 同时

122
00:03:47,466 --> 00:03:48,566
电子邮件比那个好

123
00:03:48,566 --> 00:03:49,799
我想如果你有得选的话

124
00:03:49,900 --> 00:03:50,333
Twitter

125
00:03:50,533 --> 00:03:51,066
Email

126
00:03:51,366 --> 00:03:51,999
传真

127
00:03:52,266 --> 00:03:52,766
信鸽

128
00:03:52,766 --> 00:03:53,632
然后才是 Slack

129
00:03:54,066 --> 00:03:54,366
对吧

130
00:03:54,633 --> 00:03:55,366
按照那个顺序

131
00:03:55,933 --> 00:03:57,199
好了朋友们 我们没多少时间

132
00:03:57,200 --> 00:03:58,233
所以演示代码

133
00:03:58,466 --> 00:03:59,466


134
00:03:59,500 --> 00:04:00,733
等会要跟着操作的 不是现在

135
00:04:00,733 --> 00:04:02,966
是的 不是现在

136
00:04:03,433 --> 00:04:05,433
因为如果你们其中有人在这个房间

137
00:04:05,733 --> 00:04:06,833
用 Maven 下载

138
00:04:07,833 --> 00:04:09,199
在我演示的时候

139
00:04:09,966 --> 00:04:10,866
那体验就不好了

140
00:04:11,533 --> 00:04:12,299
体验不会好

141
00:04:12,433 --> 00:04:12,733
尽管

142
00:04:13,066 --> 00:04:13,599
公平地说

143
00:04:13,600 --> 00:04:15,000
在另一个房间

144
00:04:15,333 --> 00:04:18,999
我朋友 Jams 和 Ray 在演示 Kubernetes

145
00:04:19,700 --> 00:04:22,133
可能这边还不是最糟糕的情况

146
00:04:22,133 --> 00:04:23,433
可能用 Maven 下载的影响不是最糟糕的

147
00:04:24,433 --> 00:04:25,533
对 WiFi 的影响

148
00:04:25,533 --> 00:04:26,799
OK 牛逼

149
00:04:27,100 --> 00:04:30,433
噢 在我们开始之前 既然我们都在这

150
00:04:30,600 --> 00:04:32,166
我想来张自拍 可以吗？

151
00:04:33,133 --> 00:04:33,999
大家没意见吧？

152
00:04:34,533 --> 00:04:35,233
有人说不要？

153
00:04:37,966 --> 00:04:39,832
好吧 你可以遮住你的脸

154
00:04:40,133 --> 00:04:42,466
我想来张自拍 原因是

155
00:04:42,633 --> 00:04:43,733
因为我有个女儿

156
00:04:44,066 --> 00:04:46,366
然后她超聪明

157
00:04:46,500 --> 00:04:47,466
肯定比我聪明

158
00:04:47,700 --> 00:04:50,900
然后 额 她现在是青少年

159
00:04:51,133 --> 00:04:52,099
所以她非常聪明

160
00:04:52,166 --> 00:04:54,266
而且是青少年 所以我拍这些照片

161
00:04:54,633 --> 00:04:56,799
我去世界各地 然后拍这些小照片

162
00:04:57,033 --> 00:05:00,933
在台上 或是在这次是在影院萤幕前

163
00:05:01,066 --> 00:05:03,399
我拍这些照片 然后回家

164
00:05:03,400 --> 00:05:05,100
并给她看照片并说

165
00:05:05,333 --> 00:05:07,499
看！ 他们听我讲话

166
00:05:09,966 --> 00:05:11,166
所以这就是我想做的事 好吗

167
00:05:12,066 --> 00:05:15,599
好吧 ok ok

168
00:05:16,233 --> 00:05:17,099
可以了 好的

169
00:05:17,400 --> 00:05:20,100
听我口令 当我说 open source 你们也说

170
00:05:20,333 --> 00:05:21,199
准备了

171
00:05:21,200 --> 00:05:21,333
1

172
00:05:21,333 --> 00:05:21,499
2

173
00:05:21,500 --> 00:05:22,000
3

174
00:05:22,366 --> 00:05:23,732
Open Source...

175
00:05:24,900 --> 00:05:26,133
额 这很糟糕

176
00:05:27,600 --> 00:05:29,733
额 Ok 好吧

177
00:05:30,333 --> 00:05:31,933
OK 好东西

178
00:05:32,533 --> 00:05:34,333
好东西 让我们看一下

179
00:05:36,066 --> 00:05:38,066
关于我的一些信息 我名字是 Josh Long

180
00:05:38,066 --> 00:05:39,332
我在...... 噢又有人进来了 欢迎

181
00:05:39,666 --> 00:05:42,232
我在 Spring 团队工作 我是 Spring 团队的布道师

182
00:05:42,533 --> 00:05:44,166
我在 Spring 团队已经

183
00:05:44,466 --> 00:05:45,699
差不多 10 年了（官方）

184
00:05:45,700 --> 00:05:47,800
除此以外还有非官方的几年

185
00:05:48,100 --> 00:05:49,366
在社区之类的

186
00:05:49,500 --> 00:05:52,000
在中国他们为我做了一个人偶 有点意思

187
00:05:52,366 --> 00:05:53,332
嗯 中国

188
00:05:53,533 --> 00:05:55,199
我在 Safari 上面有视频课程

189
00:05:55,266 --> 00:05:59,399
这是你们的线上技术市场

190
00:06:00,300 --> 00:06:02,833
我写了本书 《云原生 Java》

191
00:06:02,833 --> 00:06:06,166
是关于如何构建在云生存并发展的应用

192
00:06:06,166 --> 00:06:07,466
使用 Spring Boot 和 Spring Cloud

193
00:06:07,833 --> 00:06:11,199
额 这本书 目前据我所知

194
00:06:11,300 --> 00:06:12,233
还没有佛兰芒语版

195
00:06:12,233 --> 00:06:13,099
不过

196
00:06:13,433 --> 00:06:14,299
可能某天会有

197
00:06:15,200 --> 00:06:15,833
嗯

198
00:06:16,300 --> 00:06:18,533
还有一个播客 每周五只是我

199
00:06:19,000 --> 00:06:20,233
访谈更聪明的人

200
00:06:20,366 --> 00:06:22,066
非常让人惊讶的人

201
00:06:22,400 --> 00:06:23,633
所以这一周我们有

202
00:06:23,900 --> 00:06:26,200
上一周我们有 Vald

203
00:06:26,200 --> 00:06:28,000
搞 Hibernate 的 非常出名

204
00:06:28,400 --> 00:06:31,933
非常神奇的在 Hibernate 的生态的布道者

205
00:06:32,366 --> 00:06:33,699
是这些东西

206
00:06:33,900 --> 00:06:35,500
每周二我要写博客

207
00:06:35,500 --> 00:06:37,066
顺便提一下 今天我要写这篇博文

208
00:06:37,200 --> 00:06:38,533
称为这周的 Spring

209
00:06:38,533 --> 00:06:40,133
就是一些集合最新的资讯

210
00:06:40,133 --> 00:06:42,399
我已经做了大概 10 年了

211
00:06:42,400 --> 00:06:43,433
一直坚持每周二更新博客

212
00:06:43,733 --> 00:06:45,099
然后每周三

213
00:06:45,100 --> 00:06:48,200
当季的时候 这有季节性的

214
00:06:48,200 --> 00:06:50,966
我做一个Spring Tips总结录屏

215
00:06:51,333 --> 00:06:53,566
我每周三在 YouTube 频道更新

216
00:06:53,733 --> 00:06:56,933
除了这个演讲以外还有很多内容在那里

217
00:06:57,366 --> 00:06:58,999
如果你想深入这些主题

218
00:06:59,233 --> 00:07:01,033
我鼓励你在网上找这些内容

219
00:07:01,400 --> 00:07:05,066
还有我正在写一本书 Reactive Spring

220
00:07:05,066 --> 00:07:07,532
朋友们 那就是我今天要讲的话题

221
00:07:07,533 --> 00:07:09,699
额 可能没必要买这本书

222
00:07:09,700 --> 00:07:11,266
我们会讲三个小时

223
00:07:11,266 --> 00:07:13,966
嗯 还有 我知道你们是聪明人 所以

224
00:07:13,966 --> 00:07:16,266
我很兴奋 就今天的演讲而已

225
00:07:16,500 --> 00:07:19,666
你可以跟着操作 并到生产环境

226
00:07:19,933 --> 00:07:20,833
非常容易

227
00:07:20,833 --> 00:07:24,233
不过这本书还在写

228
00:07:24,233 --> 00:07:26,033
如果你真想买了 想要反馈

229
00:07:26,033 --> 00:07:28,099
你现在可以买早期预览版

230
00:07:28,300 --> 00:07:30,266
然后你可以告诉我 这个可以改进

231
00:07:30,266 --> 00:07:31,366
这里讲得不清楚之类的

232
00:07:31,566 --> 00:07:33,666
我会很感谢的

233
00:07:33,933 --> 00:07:36,666
这本书全是关于如何使用响应式编程的

234
00:07:36,833 --> 00:07:38,766
然后 朋友们那就是我们今天演讲的内容

235
00:07:39,000 --> 00:07:43,533
响应式编程 不是一个特别新的话题

236
00:07:44,266 --> 00:07:46,299
不是一个新的概念

237
00:07:46,533 --> 00:07:47,899
你们这里的很多人 实际上

238
00:07:48,200 --> 00:07:50,566
会记得我们已经讨论响应式编程

239
00:07:50,900 --> 00:07:52,100
大概 5 年前就开始了

240
00:07:52,100 --> 00:07:55,066
6 7 年前了在这个 Devoxx 对吧

241
00:07:55,266 --> 00:07:58,466
响应式编程不是一个特别新的概念

242
00:07:58,966 --> 00:08:01,366
这是一个答案

243
00:08:01,933 --> 00:08:03,699
一个更老的问题的答案

244
00:08:03,700 --> 00:08:05,966
一个已经存在很久了的问题

245
00:08:05,966 --> 00:08:08,532
一个横着我们面前的

246
00:08:08,533 --> 00:08:12,733
让要生产环境软件的开发者烦恼的

247
00:08:12,733 --> 00:08:14,466
问题就是

248
00:08:14,466 --> 00:08:15,766
系统如何扩展

249
00:08:15,766 --> 00:08:17,199
如何处理更多用户

250
00:08:17,200 --> 00:08:20,466
如何处理更多进入系统的请求

251
00:08:20,466 --> 00:08:22,466
问题当然不在于

252
00:08:22,466 --> 00:08:24,099
正如我所说 不是一个新问题

253
00:08:24,100 --> 00:08:27,733
相对地更多是新的答案

254
00:08:27,733 --> 00:08:29,333
而答案很简单对吧

255
00:08:31,666 --> 00:08:33,866
响应式编程时一种表达方式

256
00:08:34,500 --> 00:08:36,833
一种新的答案

257
00:08:37,500 --> 00:08:39,366
而答案的本身

258
00:08:39,800 --> 00:08:41,100
并不是很新颖

259
00:08:41,366 --> 00:08:42,599
响应式编程

260
00:08:43,033 --> 00:08:45,266
更多的关于线程的使用效率

261
00:08:45,800 --> 00:08:47,833
是关于更好地使用线程

262
00:08:47,833 --> 00:08:50,333
是关于让你的系统 让你的软件

263
00:08:50,333 --> 00:08:54,333
一种方式在 JVM 上处理线程 

264
00:08:54,333 --> 00:08:58,699
这是很重要的 因为线程代价高

265
00:08:59,400 --> 00:09:00,700
JVM 的线程开销大

266
00:09:01,000 --> 00:09:02,800
所以现在问题是

267
00:09:03,200 --> 00:09:05,166
为什么 我们为什么关心这个 对吧

268
00:09:05,733 --> 00:09:08,133
首先什么促使我们扩展

269
00:09:08,833 --> 00:09:11,233
我们支持更多用户的动机是什么

270
00:09:11,366 --> 00:09:13,132
这问题不是特别难回答

271
00:09:13,133 --> 00:09:15,799
我保证你们能够指出一些方面

272
00:09:15,800 --> 00:09:18,033
在过去 10 年 或是 12年

273
00:09:18,033 --> 00:09:20,033
促使我们扩展的原因

274
00:09:20,333 --> 00:09:21,533
并处理更多的用户

275
00:09:21,533 --> 00:09:23,699
并不难找到这类东西

276
00:09:24,033 --> 00:09:26,666
我才用这东西自拍了 iPhone 对吧

277
00:09:26,933 --> 00:09:28,299
还有安卓设备

278
00:09:28,300 --> 00:09:30,633
各种这些智能设备

279
00:09:30,866 --> 00:09:33,932
这又促使了一大波

280
00:09:33,933 --> 00:09:37,699
还有物联网的浪潮 这些联网设备

281
00:09:37,700 --> 00:09:39,500
随着我们连接更多的东西到互联网

282
00:09:39,500 --> 00:09:41,900
随着我们逐步地迁移到

283
00:09:41,900 --> 00:09:44,066
一个HTTP 请求的世界

284
00:09:44,066 --> 00:09:45,632
并加上 CSS 和 JavaScript

285
00:09:45,633 --> 00:09:47,066
构成一个视图的年代

286
00:09:47,400 --> 00:09:50,100
我们从那个世界 迁移到了另一个世界

287
00:09:50,333 --> 00:09:51,933
现在单独的一个用户界面

288
00:09:52,666 --> 00:09:53,699
可以由

289
00:09:53,700 --> 00:09:55,166
十几个网络请求的

290
00:09:55,166 --> 00:09:56,666
一系列的网络请求

291
00:09:56,966 --> 00:10:00,966
最终才组合组成你看到的视图 对吧

292
00:10:01,966 --> 00:10:04,632
而且这对于不同的连接设备都不同

293
00:10:05,100 --> 00:10:06,666
当我们进到新的世界

294
00:10:06,966 --> 00:10:09,966
现在一个用户界面又十几个网络请求组成

295
00:10:10,466 --> 00:10:12,466
我们后端的服务变得更加棘手

296
00:10:12,866 --> 00:10:16,732
尤其是这些服务没花什么时间

297
00:10:16,733 --> 00:10:17,799
产生结果

298
00:10:18,133 --> 00:10:19,299
原因是正确的

299
00:10:20,100 --> 00:10:21,800
传统构建软件的方式

300
00:10:21,800 --> 00:10:25,366
在JVM构建软件的传统方式一直比较简单

301
00:10:25,366 --> 00:10:27,132
当请求进来的时候

302
00:10:27,133 --> 00:10:28,933
你得到一个 java.net.ServerSocket

303
00:10:29,300 --> 00:10:30,733
监听在 8080 端口

304
00:10:30,966 --> 00:10:32,399
并且当这些请求进来的时候

305
00:10:32,633 --> 00:10:36,033
ServerSocket 接受客户端进来的 socket 请求

306
00:10:36,300 --> 00:10:39,900
然后客户端将载荷发送到服务器

307
00:10:39,900 --> 00:10:41,200
服务器接收

308
00:10:41,433 --> 00:10:44,366
给与 SeverSocket 和 socket

309
00:10:44,366 --> 00:10:46,366
都有 InputStream 和 OutputStream

310
00:10:46,633 --> 00:10:47,799
然后他们开始相互通信了

311
00:10:47,800 --> 00:10:49,166
它们来回传输字节

312
00:10:49,366 --> 00:10:50,099
通过网络

313
00:10:50,500 --> 00:10:53,300
然后 当那个请求到达服务器

314
00:10:53,733 --> 00:10:57,966
在传统的服务器 15 年前

315
00:10:58,400 --> 00:11:00,366
那是非常简单的 while 循环

316
00:11:00,666 --> 00:11:03,532
一个 while(serversocket.accept()==true)

317
00:11:03,900 --> 00:11:06,233
接受请求 创建一个新线程

318
00:11:06,500 --> 00:11:07,366
在线程中

319
00:11:07,366 --> 00:11:09,132
你从请求中读取输入的字节

320
00:11:09,400 --> 00:11:11,433
你在输出流产生响应

321
00:11:11,433 --> 00:11:12,266
然后你发送回去

322
00:11:12,266 --> 00:11:14,066
产生一个响应需要什么？

323
00:11:14,366 --> 00:11:16,999
现今 要做什么产生一个响应

324
00:11:17,633 --> 00:11:21,999
嗯 你要做很多事情 你要调用数据库

325
00:11:22,000 --> 00:11:23,133
你要调用 Web 服务

326
00:11:23,133 --> 00:11:25,566
你要调用 额 其它的 API

327
00:11:25,566 --> 00:11:28,266
传统的做法使用输入输出流

328
00:11:28,266 --> 00:11:30,966
所以全部的while循环都在这个线程

329
00:11:31,500 --> 00:11:34,833
你发出一个请求 并等待数据返回

330
00:11:35,100 --> 00:11:37,666
只能停在那里等 等 等

331
00:11:37,966 --> 00:11:39,432
你在等待这些字节返回

332
00:11:39,700 --> 00:11:41,433
同一时间 你在那个线程做什么

333
00:11:42,466 --> 00:11:44,499
没事干 只是等 空闲状态

334
00:11:44,833 --> 00:11:46,466
然后 这就是真正的犯罪

335
00:11:46,933 --> 00:11:48,299
这是真正的问题

336
00:11:48,500 --> 00:11:50,800
因为占用线程不做任何事情

337
00:11:50,800 --> 00:11:53,000
这是非常不高效的线程使用方法

338
00:11:53,333 --> 00:11:56,299
线程代价高 我们不能无限地创建它们

339
00:11:57,000 --> 00:11:58,866
对吧 所以这是第一个问题

340
00:11:59,966 --> 00:12:01,799
希望还是有的 对吧

341
00:12:02,166 --> 00:12:02,932
在视野之内

342
00:12:03,100 --> 00:12:07,000
几年内 幸运的话 我们有望迎来纤程 对吧

343
00:12:07,166 --> 00:12:10,466
我不知道什么时候才有 算他两年吧 最快的情况

344
00:12:10,766 --> 00:12:12,632
但愿这能让你创建更多的线程

345
00:12:13,000 --> 00:12:14,666
另一个问题 当然

346
00:12:15,133 --> 00:12:16,466
假设你部署

347
00:12:16,966 --> 00:12:18,966
最新版本的 JVM 到生产环境

348
00:12:20,200 --> 00:12:20,933
我是这样做的

349
00:12:21,566 --> 00:12:22,232
你也应该这样做

350
00:12:22,700 --> 00:12:23,466
如果不

351
00:12:23,700 --> 00:12:26,800
我可以看到你们一些人有点不自在

352
00:12:27,566 --> 00:12:28,799
所以我就不问了

353
00:12:29,500 --> 00:12:31,566
你们还有多少人还在用 Java 8 不过……

354
00:12:32,800 --> 00:12:33,400
我们可能

355
00:12:35,066 --> 00:12:36,799
哦哦 我看到你们有些人不自在了

356
00:12:37,100 --> 00:12:37,700
好不管怎样

357
00:12:38,166 --> 00:12:40,299
关键是假设你们有

358
00:12:40,466 --> 00:12:41,866
使用最新版的 Java

359
00:12:42,000 --> 00:12:46,000
并且假设我们在未来两年或三年有纤程之类的

360
00:12:46,266 --> 00:12:47,832
额 然后

361
00:12:48,200 --> 00:12:51,133
现在我们需要解决另一个问题 构建分布式系统

362
00:12:51,800 --> 00:12:54,066
现在我们思考数据跨越网络的情况

363
00:12:54,066 --> 00:12:56,832
考虑服务之间通过线路交互

364
00:12:57,033 --> 00:12:59,866
是傻子的想法傻子的做法

365
00:13:00,000 --> 00:13:03,733
去认为当我们请求的时候立即就能获取数据

366
00:13:03,933 --> 00:13:06,699
就好像数据在打个响指就在那了

367
00:13:06,900 --> 00:13:07,300
对吧

368
00:13:07,500 --> 00:13:08,400
傻子才这么想

369
00:13:08,600 --> 00:13:11,200
才会认为 服务响应迅速

370
00:13:11,300 --> 00:13:12,833
快捷 或者是可靠的

371
00:13:12,833 --> 00:13:14,033
而且一直是高可用的

372
00:13:14,400 --> 00:13:15,566
而且不会出错

373
00:13:16,500 --> 00:13:20,500
当构建分布式系统这些交互情况是常见的

374
00:13:20,700 --> 00:13:24,000
而且这种方式 这种传统方式 读取下一个字节

375
00:13:24,200 --> 00:13:26,266
并不断地等待下一个字节

376
00:13:26,533 --> 00:13:28,599
忽视那样的现实

377
00:13:28,833 --> 00:13:30,466
忽视网络是不稳的

378
00:13:30,633 --> 00:13:33,033
不稳定的 有时候还有问题的地方

379
00:13:33,033 --> 00:13:35,033
数据可能会丢包

380
00:13:35,466 --> 00:13:38,066
所以我们需要更好的范式 更好的沟通方式

381
00:13:38,333 --> 00:13:40,499
用于处理这样特别的现实情况

382
00:13:40,833 --> 00:13:43,933
所以 我们面对的是…… 噢

383
00:13:46,000 --> 00:13:46,500
好东西

384
00:13:46,666 --> 00:13:48,432
我们面对这样的需求

385
00:13:48,433 --> 00:13:50,166
构建更好的系统 构建更好的软件

386
00:13:50,400 --> 00:13:51,566
要支持它

387
00:13:52,166 --> 00:13:54,866
目前 我们使用响应式编程

388
00:13:55,233 --> 00:13:57,299
响应式编程 使得我们可以

389
00:13:57,466 --> 00:14:00,032
处理更好利用我们线程的需求

390
00:14:00,233 --> 00:14:03,233
并允许我们编写更多消息传递风格的代码

391
00:14:03,666 --> 00:14:08,132
将世界想象成为一系列的异步事件

392
00:14:08,400 --> 00:14:11,266
事实确是如此 世界是异步的 是充满事件的

393
00:14:11,466 --> 00:14:15,466
不是一系列的同步数据 你随意能获取想要的

394
00:14:16,600 --> 00:14:20,733
所以 我们有这样的目标 目标是我们有一堆线程

395
00:14:20,866 --> 00:14:22,032
随着请求进来

396
00:14:22,333 --> 00:14:26,266
我们不想占着线程等待下一个字节到来

397
00:14:26,500 --> 00:14:28,800
我们得有些转变

398
00:14:28,800 --> 00:14:30,233
我们要改变传统方式

399
00:14:30,233 --> 00:14:31,799
处理数据流的方式

400
00:14:31,800 --> 00:14:34,166
而不是坐在那里等待数据到来

401
00:14:34,400 --> 00:14:38,000
随着我们将数据从输入流取出来

402
00:14:38,000 --> 00:14:39,600
而不是这样操作

403
00:14:40,333 --> 00:14:41,599
让我们切换到另一个世界

404
00:14:41,766 --> 00:14:45,232
比如说 我们等待数据推送给我们

405
00:14:45,766 --> 00:14:50,366
我们等待数据的生产者发布数据给我们

406
00:14:50,800 --> 00:14:52,433
然而这是很难的概念对吧

407
00:14:52,433 --> 00:14:55,366
想一下我们所做的事情可能阻塞线程

408
00:14:55,800 --> 00:14:58,066
我们有什么东西是阻塞线程的

409
00:14:58,533 --> 00:15:01,233
额 当然啦 有很多显而易见的事情

410
00:15:01,700 --> 00:15:04,166
例如占用CPU的任务

411
00:15:04,166 --> 00:15:06,399
像计算斐波那契数列

412
00:15:06,866 --> 00:15:09,466
或者是加密，挖矿对吧

413
00:15:09,733 --> 00:15:13,166
额 额…… 安全之类的东西

414
00:15:13,300 --> 00:15:14,566
因为那需要加密

415
00:15:14,766 --> 00:15:16,032
会符合这一类型

416
00:15:16,366 --> 00:15:17,966
额…… 运行 Slack

417
00:15:18,066 --> 00:15:19,399
对吧 需要很多CPU 资源

418
00:15:19,566 --> 00:15:21,066
基本上全占用了 对吧

419
00:15:21,366 --> 00:15:24,232
你不希望这些东西独占 CPU

420
00:15:24,233 --> 00:15:26,299
这是很显然的 而且你不能解决这个问题

421
00:15:26,300 --> 00:15:27,200
使用响应式编程

422
00:15:27,566 --> 00:15:30,799
有些东西就是要占用 CPU 的

423
00:15:30,933 --> 00:15:34,933
但是有些东西是 IO 密集的 受限于输入输出的

424
00:15:35,533 --> 00:15:37,333
然后这些东西是天然适合

425
00:15:37,800 --> 00:15:40,133
我们现时所作的一些修改

426
00:15:40,633 --> 00:15:42,866
你发现 我们不需要做同步的

427
00:15:43,200 --> 00:15:44,366
阻塞的输入输出

428
00:15:44,366 --> 00:15:46,266
没理由让我们查询数据

429
00:15:46,466 --> 00:15:49,132
从输入流 我们可以让数据准备好给我们

430
00:15:49,400 --> 00:15:51,833
我们可以告诉操作系统 看这里操作系统

431
00:15:52,100 --> 00:15:53,266
这是一个文件描述符

432
00:15:53,900 --> 00:15:55,666
它有数据但是目前还不可用

433
00:15:55,833 --> 00:15:58,366
请给我一个消息 给我一个中断

434
00:15:58,366 --> 00:15:59,566
回调我

435
00:15:59,833 --> 00:16:01,066
当数据可用的时候

436
00:16:01,500 --> 00:16:04,400
对吧 这是操作系统很容易做到的事情

437
00:16:04,533 --> 00:16:06,266
它可以查询可以管理

438
00:16:06,433 --> 00:16:08,466
它可以高效地选择

439
00:16:08,666 --> 00:16:11,066
成千上万的文件描述符

440
00:16:11,266 --> 00:16:13,466
但它不能创建成千上万的线程

441
00:16:14,033 --> 00:16:14,899
这就是问题所作

442
00:16:15,200 --> 00:16:18,100
所以更好的情况是 嘿操作系统

443
00:16:18,100 --> 00:16:20,000
给我一个回调当数据可用的时候

444
00:16:20,166 --> 00:16:21,599
我会当它现在可用的状态继续工作

445
00:16:21,800 --> 00:16:23,333
而不是更早的时候 同时

446
00:16:23,566 --> 00:16:25,866
之前我用于询问数据的线程

447
00:16:26,100 --> 00:16:27,466
我已经离开了那个线程

448
00:16:27,666 --> 00:16:31,999
并让操作系统的其它用户使用那线程做其它事情

449
00:16:32,766 --> 00:16:34,399
这仍然不是什么新东西

450
00:16:34,533 --> 00:16:37,366
它有个老术语叫多线程协作

451
00:16:37,666 --> 00:16:38,399
很简单的概念

452
00:16:38,400 --> 00:16:39,500
我们说 嘿

453
00:16:39,733 --> 00:16:41,299
我将会这样写代码

454
00:16:41,500 --> 00:16:42,600
去告诉系统

455
00:16:42,866 --> 00:16:44,666
我什么时候用完这个线程

456
00:16:44,933 --> 00:16:47,133
我会表达更加明确

457
00:16:47,133 --> 00:16:49,933
我会多花些功夫使得

458
00:16:49,933 --> 00:16:53,333
那是一个多租户的系统

459
00:16:53,733 --> 00:16:56,199
这是一个很简单的概念

460
00:16:56,366 --> 00:16:58,766
响应式编程出现的原因是

461
00:16:58,766 --> 00:17:00,766
给我们一种编程范式、模式

462
00:17:00,933 --> 00:17:03,666
去让我们这样的表达这个世界

463
00:17:03,666 --> 00:17:04,966
可以让我们这样说 嘿

464
00:17:05,266 --> 00:17:07,699
我请求了这个数据 但是它还不存在这里

465
00:17:07,833 --> 00:17:09,699
这是异步的 它现在还不在这里

466
00:17:09,866 --> 00:17:12,332
还未被解决 但最终会到来的

467
00:17:12,700 --> 00:17:16,600
而且 可能不止一个值

468
00:17:17,033 --> 00:17:18,999
这就是事情变得有点不同的原因

469
00:17:19,200 --> 00:17:21,733
我要怎么说 我有一个值需要获取

470
00:17:22,500 --> 00:17:24,700
使用现在的 JDK

471
00:17:25,066 --> 00:17:26,432
你说我有个 Future

472
00:17:26,700 --> 00:17:29,500
Future<String> 或 Future<Integer> 随意啦

473
00:17:30,100 --> 00:17:31,600
甚至 CompletableFuture 更好

474
00:17:32,466 --> 00:17:33,399
会给你一个值

475
00:17:33,766 --> 00:17:35,899
等了这么久还缺的是 一种方式表达

476
00:17:36,133 --> 00:17:39,766
我有一连串的异步解决的值

477
00:17:40,633 --> 00:17:44,633
所以我们需要一种范式 一种计算方面的模式

478
00:17:44,833 --> 00:17:46,633
允许我们去描述这样的一种数据

479
00:17:46,833 --> 00:17:49,066
这就是 Reactive Stream 规范的作用

480
00:17:49,400 --> 00:17:52,566
Reactive Stream 规范是一些通用的底层接口

481
00:17:52,566 --> 00:17:59,032
由这些组织提出 Pivotal, Netflix, LightBean, eclipse 基金会还有其它的

482
00:17:59,266 --> 00:18:01,799
这是 4 不同的接口和一个类

483
00:18:01,966 --> 00:18:03,532
给你能力

484
00:18:03,966 --> 00:18:06,332
异步的数据串流

485
00:18:06,500 --> 00:18:08,766
而且它们是非常基础 非常非常基础的

486
00:18:09,033 --> 00:18:11,933
它允许我们说 嘿 有数据进来了

487
00:18:12,166 --> 00:18:13,566
除此以外并没有给你什么了

488
00:18:13,566 --> 00:18:16,566
它不支持我们常用的操作

489
00:18:16,733 --> 00:18:18,499
我们处理数据时期待的操作

490
00:18:19,066 --> 00:18:22,166
我将它们比作数组 就像 Java 的数组

491
00:18:22,166 --> 00:18:25,199
你们有多少人写代码用到数组的

492
00:18:25,700 --> 00:18:26,366
大多数时候

493
00:18:26,933 --> 00:18:30,433
是的 数组常常用到 对吧

494
00:18:30,433 --> 00:18:32,066
通常你不会这样做的

495
00:18:32,233 --> 00:18:35,933
如果我要描述一系列数字或什么的 我使用 List

496
00:18:36,133 --> 00:18:37,433
或者 Set 随意吧 对吧

497
00:18:37,433 --> 00:18:38,433
那会使用数据类型

498
00:18:38,433 --> 00:18:43,233
因为这样处理数据方便惯用

499
00:18:43,233 --> 00:18:45,033
我可以扩展它们 可以操作它们

500
00:18:45,033 --> 00:18:46,999
可以流式操作 可以过滤它们之类的

501
00:18:47,900 --> 00:18:52,166
所以这是非常常见的抽象 对吧

502
00:18:52,466 --> 00:18:53,999
Java 数组不太好用

503
00:18:54,400 --> 00:18:55,400
你们这些不看的

504
00:18:55,766 --> 00:18:57,199
你们大概有二十人

505
00:18:57,200 --> 00:19:00,000
举手了 然后我说 “大多数时候”

506
00:19:00,000 --> 00:19:01,000
大部分人放低手了

507
00:19:01,433 --> 00:19:03,966
因为大部分人没有经常使用数组

508
00:19:03,966 --> 00:19:05,832
我们使用更高层次的数据类型

509
00:19:05,833 --> 00:19:07,699
这里也有同样的需求

510
00:19:07,866 --> 00:19:09,466
对于这些响应式流

511
00:19:09,466 --> 00:19:12,366
它们非常基础 作为一种基石

512
00:19:12,566 --> 00:19:15,099
但我不会在生产环境只是要这些

513
00:19:15,433 --> 00:19:16,566
我需要操作符

514
00:19:16,566 --> 00:19:20,899
使用，组合处理流数据

515
00:19:21,066 --> 00:19:23,699
更加容易 这就是Project Reactor 的意义

516
00:19:24,300 --> 00:19:26,500
Project Reactor 来自 Pivotal

517
00:19:26,733 --> 00:19:29,666
它类似于 RxJava

518
00:19:29,666 --> 00:19:31,366
它为你提供了这些好用的操作符

519
00:19:32,366 --> 00:19:34,366
好 我们完事了吗？

520
00:19:34,933 --> 00:19:35,966
可以回家了吗？

521
00:19:36,933 --> 00:19:38,366
还不行 当然不了，对吧

522
00:19:38,833 --> 00:19:40,199
这是我们迎来另一个问题的情况

523
00:19:40,866 --> 00:19:43,632
假设，只是假设

524
00:19:43,933 --> 00:19:45,633
出于某种原因

525
00:19:45,833 --> 00:19:47,399
只是假象 好吧 好吧

526
00:19:47,666 --> 00:19:49,999
我不承诺任何事情 但想象一下

527
00:19:50,333 --> 00:19:53,599
在一条时间线上

528
00:19:54,366 --> 00:19:55,699
技术

529
00:19:56,200 --> 00:19:58,133
你用着熟悉的技术

530
00:19:58,466 --> 00:20:02,866
了解的并使用了很多年 几十年的 对吧

531
00:20:02,866 --> 00:20:06,466
想象这些技术例如 Spring 例如 Hibernate

532
00:20:06,666 --> 00:20:08,066
想象由于某种原因

533
00:20:08,333 --> 00:20:10,766
这些你们已经熟悉的技术

534
00:20:11,866 --> 00:20:13,532
不能理解

535
00:20:14,600 --> 00:20:16,033
java.util.Collection

536
00:20:16,266 --> 00:20:17,599
或者是 java.util.Set

537
00:20:17,766 --> 00:20:19,266
java.util.Map 之类的

538
00:20:19,433 --> 00:20:22,699
假设想象一下 例如

539
00:20:22,966 --> 00:20:24,432
只是假想一下

540
00:20:24,433 --> 00:20:26,799
你想要映射一对多的关系

541
00:20:26,800 --> 00:20:30,033
在 Hibernate 的实体里面 使用 java.util.Set

542
00:20:30,700 --> 00:20:34,233
想象一下 当你这样做的时候 Hibernate 不仅

543
00:20:34,933 --> 00:20:35,966
抛出异常

544
00:20:37,366 --> 00:20:38,599
想象一下你这样做了

545
00:20:38,900 --> 00:20:40,566
Hibernate 不仅抛出异常

546
00:20:40,633 --> 00:20:44,233
它实际上还渲染一个纯文本组成的竖中指

547
00:20:45,866 --> 00:20:46,832
在控制台

548
00:20:47,266 --> 00:20:49,566
并引起你机器的内核恐慌

549
00:20:50,666 --> 00:20:51,466
帮你关机

550
00:20:51,833 --> 00:20:54,166
它非常讨厌

551
00:20:54,800 --> 00:20:55,866
java.util.Set

552
00:20:57,766 --> 00:21:00,832
你还会继续在Hibernate 继续用 java.util.Set 吗？

553
00:21:01,000 --> 00:21:03,000
如果你知道会出现这样的情况

554
00:21:04,200 --> 00:21:05,400
当然不会啦 对吧

555
00:21:05,600 --> 00:21:07,000
你不会弃用 Hibernate

556
00:21:07,266 --> 00:21:09,499
如果你想做的是同步地阻塞

557
00:21:09,766 --> 00:21:12,332
并映射对象到JDBC的数据结构

558
00:21:12,333 --> 00:21:13,333
没有比这更好的了

559
00:21:13,800 --> 00:21:16,166
那是现有最好的东西了

560
00:21:16,166 --> 00:21:17,632
你不会重造 Hibernate 的轮子

561
00:21:17,900 --> 00:21:20,833
你只是使用阻力最小的方式而已

562
00:21:21,100 --> 00:21:23,333
如果这意味着使用其它数据类型

563
00:21:23,333 --> 00:21:24,433
那就使用吧

564
00:21:24,433 --> 00:21:26,466
因为那会让你可以到生产环境

565
00:21:26,866 --> 00:21:28,466
最终那才是最重要的

566
00:21:28,666 --> 00:21:32,066
它可以让你使用你熟悉的数据访问技术

567
00:21:32,266 --> 00:21:34,932
去到生产环境 所以我们有同样的需求

568
00:21:35,066 --> 00:21:38,332
我想要处理的我的日常需求

569
00:21:38,333 --> 00:21:40,866
我希望可以构建数据访问层

570
00:21:40,866 --> 00:21:43,599
能支持安全 Web 服务

571
00:21:43,833 --> 00:21:47,466
还有其它的作为开发者的日常

572
00:21:47,466 --> 00:21:49,232
开发交付到生产环境的东西

573
00:21:49,533 --> 00:21:52,233
但我不想放弃所有那些

574
00:21:52,500 --> 00:21:54,333
只是为了支持响应式类型

575
00:21:54,333 --> 00:21:57,866
所以这就是 Spring 团队的第一步

576
00:21:58,200 --> 00:21:59,833
在 2017 年 我们发布了

577
00:21:59,966 --> 00:22:01,266
Spring 框架 5.0

578
00:22:01,400 --> 00:22:04,366
5.0 是首个版本整合了

579
00:22:04,933 --> 00:22:07,033
Pivotal Project 原生地

580
00:22:07,033 --> 00:22:09,333
与此同时还有 Reactive Stream 规范

581
00:22:10,066 --> 00:22:12,832
在此基础上我们构建了响应式 Web 运行时

582
00:22:12,833 --> 00:22:15,833
 我们整合了对

583
00:22:15,833 --> 00:22:17,199
Spring Data 的支持

584
00:22:17,200 --> 00:22:19,633
还有 Spring Security 还有 Spring Boot 和 Spring Cloud

585
00:22:19,633 --> 00:22:21,599
所以今天在 2019 年

586
00:22:22,000 --> 00:22:23,600
快到 2020 年了

587
00:22:24,366 --> 00:22:27,166
我们可以构建端到端的微服务系统

588
00:22:27,566 --> 00:22:28,566
在Sping的生态系统

589
00:22:28,566 --> 00:22:31,866
朋友们 那就是我们今天要走的旅程

590
00:22:31,966 --> 00:22:33,366
一起来 那么

591
00:22:34,433 --> 00:22:35,733
让我们看一下

592
00:22:37,133 --> 00:22:38,899
为了做这件事

593
00:22:40,033 --> 00:22:40,899
我要到

594
00:22:41,833 --> 00:22:43,166
网络上我第二喜欢的地方

595
00:22:44,600 --> 00:22:45,733
排在生产环境之后

596
00:22:46,166 --> 00:22:49,799
在网上我最喜欢的地方 当然是 生产环境

597
00:22:50,266 --> 00:22:51,399
我爱生产环境

598
00:22:51,566 --> 00:22:53,399
你也应该爱生产环境

599
00:22:53,400 --> 00:22:55,466
你应该尽早到生产环境 越频繁越好

600
00:22:55,666 --> 00:22:58,699
带上家人和孩子 那里天气很好 那是地球上最欢乐的地方

601
00:22:58,700 --> 00:23:00,000
那里比迪士尼乐园还好

602
00:23:01,366 --> 00:23:03,932
是的 即使我很了解迪士尼还是这样说

603
00:23:05,200 --> 00:23:07,700
不过如果你未到过生产环境 你可以从这里开始

604
00:23:07,766 --> 00:23:10,232
start.spring.io

605
00:23:11,466 --> 00:23:12,499
如果你需要灵感

606
00:23:12,500 --> 00:23:14,533
在早晨喝杯咖啡或茶之前

607
00:23:15,233 --> 00:23:18,133
start.spring.io

608
00:23:20,700 --> 00:23:21,600
如果你的孩子

609
00:23:21,933 --> 00:23:23,666
休息不好 睡不着

610
00:23:24,566 --> 00:23:27,232
start.spring.io

611
00:23:28,833 --> 00:23:30,599
如果你消化不良

612
00:23:32,100 --> 00:23:34,166
经历一晚上酗酒之后

613
00:23:35,366 --> 00:23:36,366
还有 PHP

614
00:23:38,833 --> 00:23:41,699
start.spring.io

615
00:23:42,500 --> 00:23:43,866
我们将在这里构建一个应用

616
00:23:43,866 --> 00:23:45,166
使用 start.spring.io

617
00:23:45,166 --> 00:23:47,699
有些注意事项 首先

618
00:23:48,233 --> 00:23:48,799
暗色模式

619
00:23:50,500 --> 00:23:52,233
这很牛逼 额……

620
00:23:52,800 --> 00:23:57,333
第二 我们要构建一个服务称为 reservasion-service

621
00:23:58,366 --> 00:23:59,732
额 我们要构建

622
00:23:59,900 --> 00:24:01,066
一个新的应用

623
00:24:01,066 --> 00:24:03,599
我想充分利用这些选项

624
00:24:03,600 --> 00:24:05,666
这里有一些选择我们需要指定的

625
00:24:05,666 --> 00:24:07,699
这边有两种不同的选择

626
00:24:07,700 --> 00:24:10,500
在我们进入下一步之前要确认的

627
00:24:10,500 --> 00:24:14,200
而我只是想花点时间讲一下这些选项

628
00:24:14,466 --> 00:24:15,799
人们有时候会感到疑惑

629
00:24:16,466 --> 00:24:17,599
所有这些

630
00:24:17,833 --> 00:24:19,499
所以让我们讲一下 首先

631
00:24:19,700 --> 00:24:21,700
我们有打包方式的选择

632
00:24:21,700 --> 00:24:23,566
当下我们应该怎么打包应用

633
00:24:23,566 --> 00:24:24,999
在2019年

634
00:24:25,200 --> 00:24:26,700
人们经常为此问题烦恼

635
00:24:26,700 --> 00:24:27,933
让我冷静地好好说

636
00:24:28,033 --> 00:24:30,133
在这里解释何时何地选择哪个选项

637
00:24:30,666 --> 00:24:32,666
如果有些奇怪现象

638
00:24:32,666 --> 00:24:34,866
物理反常现在 恐怖的灾难

639
00:24:35,100 --> 00:24:37,400
戏剧性的 时空意外

640
00:24:37,500 --> 00:24:41,600
你突然发现你被传输到很远很远的过去

641
00:24:48,600 --> 00:24:49,833
那么选择 .war

642
00:24:51,966 --> 00:24:52,932
不过如果你在这里

643
00:24:53,600 --> 00:24:54,566
跟我在一起

644
00:24:55,366 --> 00:24:57,032
在 2019 年

645
00:24:57,033 --> 00:24:58,166
快到2020年了

646
00:24:59,166 --> 00:25:00,399
那就选择 .jar

647
00:25:00,833 --> 00:25:01,933
这是重要的一部分

648
00:25:02,200 --> 00:25:03,900
是我的顶层设计 指导

649
00:25:03,900 --> 00:25:06,666
个人哲学 —— make jar not war!

650
00:25:07,200 --> 00:25:07,833
还有

651
00:25:08,133 --> 00:25:09,833
你能做的有很多

652
00:25:10,000 --> 00:25:10,733
选择在于你

653
00:25:10,933 --> 00:25:12,666
但我鼓励你选择默认的

654
00:25:13,066 --> 00:25:15,666
好了 然后我们要选择 Java 版本

655
00:25:15,666 --> 00:25:18,832
你现在想要用什么版本的 JVM ？

656
00:25:19,300 --> 00:25:23,666
朋友们 这些选择中只有两个是正确的

657
00:25:25,100 --> 00:25:26,466
我给你点提示

658
00:25:26,766 --> 00:25:29,632
一点提示 哪个是不正确的

659
00:25:30,433 --> 00:25:31,433
是这个

660
00:25:31,933 --> 00:25:33,766
这是不正确的版本 朋友们

661
00:25:34,400 --> 00:25:35,133
就在这里

662
00:25:35,800 --> 00:25:37,233
就在这里 你看到吗

663
00:25:37,933 --> 00:25:38,633
这是说 8 吗？

664
00:25:39,600 --> 00:25:40,100
这是错的

665
00:25:41,000 --> 00:25:43,966
这边你有两个选择 Java 13 和 Java 11

666
00:25:43,966 --> 00:25:46,899
Java 11 是目前的长期支持版

667
00:25:47,133 --> 00:25:48,433
这是个可接受的答案

668
00:25:48,433 --> 00:25:49,399
但在我看来

669
00:25:49,566 --> 00:25:50,966
因为这是目前

670
00:25:51,166 --> 00:25:55,166
面向生产环境的 受支持的 Java 版本

671
00:25:55,166 --> 00:25:59,366
因为它有很好的新特性 和好的性能提升

672
00:25:59,766 --> 00:26:01,666
我会选择 Java 13

673
00:26:02,000 --> 00:26:04,000
这是正确的事情

674
00:26:04,000 --> 00:26:05,766
我的朋友们 不仅是技术上来说

675
00:26:06,233 --> 00:26:07,166
道德上来说也是

676
00:26:08,033 --> 00:26:08,666
道德上

677
00:26:09,200 --> 00:26:10,566
你准备回家了吗

678
00:26:10,866 --> 00:26:14,199
以生产环境使用 Java 8 的事实去面对孩子？

679
00:26:15,000 --> 00:26:16,666
你要展开这这样的对话吗?

680
00:26:17,233 --> 00:26:18,099
我认为你不会

681
00:26:18,633 --> 00:26:20,199
所以现在 使用 Java 13

682
00:26:20,666 --> 00:26:21,566
然后我的朋友们

683
00:26:21,833 --> 00:26:23,033
我们有选择

684
00:26:23,100 --> 00:26:24,233
关于依赖的选择

685
00:26:24,233 --> 00:26:26,566
我们需要用什么依赖

686
00:26:26,566 --> 00:26:27,799
我们加入响应式 Web支持

687
00:26:27,800 --> 00:26:29,100
添加入 Lombok

688
00:26:29,100 --> 00:26:31,533
添加 Reactive MongoDB

689
00:26:32,500 --> 00:26:34,633
然后加入 R2DBC

690
00:26:34,866 --> 00:26:36,532
加入 PostgreSQL 支持

691
00:26:36,966 --> 00:26:38,932
加入 RSocket 支持

692
00:26:39,333 --> 00:26:40,833
然后我认为我开心

693
00:26:41,133 --> 00:26:42,199
有这些选项

694
00:26:42,400 --> 00:26:43,633
有了 Reactive Web, Lombok

695
00:26:43,633 --> 00:26:46,166
Reactive MongoDB, R2DBC, PostgreSQL

696
00:26:46,300 --> 00:26:47,300
还有 RSocket

697
00:26:47,400 --> 00:26:48,800
有了这些 我就点生成

698
00:26:49,033 --> 00:26:50,866
这会给我一个全新的项目

699
00:26:51,100 --> 00:26:52,866
我会在我的 IDE 打开

700
00:26:52,866 --> 00:26:54,299
用什么 IDE 没关系

701
00:26:54,533 --> 00:26:56,999
我使用... 一切都会顺利运行的

702
00:26:57,300 --> 00:26:58,333
现在我将它打开

703
00:26:58,333 --> 00:27:00,066
现在你能看到那字体吗

704
00:27:00,800 --> 00:27:01,600
比我还高

705
00:27:02,333 --> 00:27:03,933
好吧 我们将字体设大一点

706
00:27:03,933 --> 00:27:04,933
以防万一好吧

707
00:27:05,833 --> 00:27:06,399
那么

708
00:27:07,266 --> 00:27:07,666
字体

709
00:27:09,966 --> 00:27:10,332
喔

710
00:27:11,233 --> 00:27:11,499
OK

711
00:27:12,133 --> 00:27:12,599
Font

712
00:27:13,733 --> 00:27:14,833
Chrome 在运行吗？ 是的

713
00:27:17,100 --> 00:27:17,533
我就知道是

714
00:27:18,633 --> 00:27:19,066
好了

715
00:27:20,700 --> 00:27:21,333
好吧

716
00:27:25,866 --> 00:27:26,232
这是

717
00:27:26,533 --> 00:27:28,433
我在上台前刚构建过这个

718
00:27:29,100 --> 00:27:29,633
好吧

719
00:27:36,133 --> 00:27:37,033
谁在下种子？

720
00:27:44,566 --> 00:27:45,566
噢 嗯 好了

721
00:27:45,800 --> 00:27:47,100
快行了 好

722
00:27:47,266 --> 00:27:49,332
额 我们现在有

723
00:27:49,500 --> 00:27:51,366
一个全新的项目 Spring Boot 项目

724
00:27:51,600 --> 00:27:53,433
最新最好的Java版本

725
00:27:53,566 --> 00:27:54,599
我要注释掉

726
00:27:54,600 --> 00:27:55,933
一些我现在还不需要的东西

727
00:27:55,933 --> 00:27:57,166
我去掉这些，我不需要这些

728
00:27:57,400 --> 00:27:58,200
我要注释掉

729
00:27:58,466 --> 00:27:59,932
R2DBC 的依赖

730
00:28:00,133 --> 00:28:01,799
并注释掉 R2DBC 本身

731
00:28:02,266 --> 00:28:03,332
我们留下

732
00:28:03,566 --> 00:28:04,999
设置自动导入

733
00:28:05,200 --> 00:28:07,200
现在我的选择满足了

734
00:28:07,200 --> 00:28:08,400
让我们去到我们的应用

735
00:28:08,600 --> 00:28:11,066
我们的应用只是一个main方法入口

736
00:28:11,066 --> 00:28:12,799
我们应用程序的入口

737
00:28:12,833 --> 00:28:13,733
只是一个全新的应用

738
00:28:13,733 --> 00:28:16,633
它所作的全部只是一个普通的 Spring Boot 应用

739
00:28:16,633 --> 00:28:19,566
我们所要作的是写数据到数据库

740
00:28:19,733 --> 00:28:20,899
通过创建一个实体

741
00:28:21,033 --> 00:28:23,333
我要像这样地创建一个实体好吧

742
00:28:25,733 --> 00:28:27,333
这个实体

743
00:28:28,333 --> 00:28:29,733
这是个实体 但是需要

744
00:28:29,900 --> 00:28:31,566
你懂得 需要一些常规东西

745
00:28:31,766 --> 00:28:34,199
getter 和 setter， 我需要 toString

746
00:28:34,200 --> 00:28:36,200
我需要 equals 和 hashCode

747
00:28:36,200 --> 00:28:39,300
我需要构造器等东西

748
00:28:39,666 --> 00:28:40,766
还有这个

749
00:28:41,000 --> 00:28:42,500
OK 另一个构造器 好

750
00:28:42,766 --> 00:28:44,566
好东西 对吧 我需要这些 这就是 Java

751
00:28:44,966 --> 00:28:46,632
额 这非常现代

752
00:28:47,666 --> 00:28:48,566
非常现代

753
00:28:49,766 --> 00:28:50,466
如何现代... 

754
00:28:51,066 --> 00:28:51,932
我不那么做

755
00:28:52,200 --> 00:28:52,833
那很糟糕

756
00:28:53,066 --> 00:28:54,199
我是用 Lombok

757
00:28:54,200 --> 00:28:56,666
Lombok 是一个编译时注解处理器

758
00:28:56,833 --> 00:28:59,133
Lombok 使得我可以整合

759
00:28:59,133 --> 00:29:00,033
getter 和 setter

760
00:29:00,166 --> 00:29:01,899
toString, equals, hashCode 之类的

761
00:29:02,233 --> 00:29:05,099
在此之上我加入 Spring Data 的 @id 注解

762
00:29:05,100 --> 00:29:07,866
它会告诉 MongoDB

763
00:29:07,866 --> 00:29:10,032
这个文档 这个实体 这个对象

764
00:29:10,300 --> 00:29:11,266
我在这里描述的

765
00:29:11,366 --> 00:29:12,466
将会被持久化

766
00:29:12,700 --> 00:29:15,733
到一个单独行 称之为集合

767
00:29:15,900 --> 00:29:16,666
在 MongoDB 里面

768
00:29:16,833 --> 00:29:19,466
在那个世界 在MongoDB 里的叫法

769
00:29:19,600 --> 00:29:21,900
一个记录被称为文档

770
00:29:22,033 --> 00:29:23,433
所以这是一个文档

771
00:29:23,566 --> 00:29:24,366
在一个集合中

772
00:29:24,633 --> 00:29:26,699
这个文档有一个 id 字段

773
00:29:26,833 --> 00:29:29,533
还有name字段 它们都在这里描述了

774
00:29:29,800 --> 00:29:32,433
这基本上就是我要做的

775
00:29:32,633 --> 00:29:33,199
让这个能用

776
00:29:33,433 --> 00:29:35,033
现在我要创建一个

777
00:29:35,133 --> 00:29:36,066
repository

778
00:29:36,166 --> 00:29:37,766
repository 只是一个东西

779
00:29:37,766 --> 00:29:39,799
会将数据存储到数据库的东西

780
00:29:39,900 --> 00:29:41,366
会处理无聊的

781
00:29:41,366 --> 00:29:43,132
到掉土渣的

782
00:29:43,333 --> 00:29:45,533
读/写 更新/删除 的生命周期方法

783
00:29:45,800 --> 00:29:48,433
支持处理我们数据的方法

784
00:29:48,666 --> 00:29:49,732
这个 repository

785
00:29:49,900 --> 00:29:51,533
支持所有可能的操作

786
00:29:51,533 --> 00:29:52,166
在这你可以看到

787
00:29:52,300 --> 00:29:53,566
所有这些常用方法

788
00:29:53,566 --> 00:29:54,666
你在生产环境需要的

789
00:29:54,866 --> 00:29:57,232
并将任务完成 例如save, saveAll

790
00:29:57,433 --> 00:29:59,266
count, delete, findById

791
00:29:59,266 --> 00:30:00,366
检查是否存在

792
00:30:00,533 --> 00:30:01,033
诸如此类的

793
00:30:01,166 --> 00:30:03,099
所有这些方法我猜想

794
00:30:03,100 --> 00:30:04,133
对于你们来说应该很熟悉了

795
00:30:04,333 --> 00:30:06,433
一些现在还未熟悉的是

796
00:30:06,533 --> 00:30:08,633
是参数的类型

797
00:30:08,633 --> 00:30:09,466
第一个参数是一个 Publisher

798
00:30:09,866 --> 00:30:11,299
这个Publisher 你可以看到

799
00:30:12,566 --> 00:30:13,266
来自于

800
00:30:13,466 --> 00:30:15,166
org.reactivestreams:reactive-streams

801
00:30:15,266 --> 00:30:16,266
这是一个Publisher

802
00:30:16,433 --> 00:30:19,033
产生 0 到 n 个记录

803
00:30:19,266 --> 00:30:19,532
对吧

804
00:30:19,800 --> 00:30:21,200
是一个产生记录的Publisher

805
00:30:21,633 --> 00:30:23,233
异步地 不受限地

806
00:30:23,533 --> 00:30:24,633
输出到一个订阅者

807
00:30:25,466 --> 00:30:26,166
Subscriber

808
00:30:26,900 --> 00:30:28,200
当它首次订阅

809
00:30:28,366 --> 00:30:30,266
它会给一个指针到一个Subscription

810
00:30:30,600 --> 00:30:32,400
在这里看到我们有这个Subscription

811
00:30:32,533 --> 00:30:34,066
等下我们再回头看这个 Subscription

812
00:30:34,266 --> 00:30:35,099
稍后再看

813
00:30:35,200 --> 00:30:36,933
这个可以说是最重要的部分了

814
00:30:38,000 --> 00:30:39,066
当数据到来的时候

815
00:30:39,066 --> 00:30:40,399
1 2 3

816
00:30:40,633 --> 00:30:41,833
十亿，万亿

817
00:30:41,833 --> 00:30:43,766
无限的数据 当它们到达的时候

818
00:30:44,033 --> 00:30:45,466
onNext 方法会被调用

819
00:30:45,733 --> 00:30:47,099
是在onNext 方法里面

820
00:30:47,233 --> 00:30:50,333
我们才能 消耗并处理到达的数据流

821
00:30:50,433 --> 00:30:52,866
那些来自Publisher 的数据

822
00:30:53,433 --> 00:30:54,399
如果遇到错误

823
00:30:54,566 --> 00:30:55,432
当出现错误

824
00:30:55,666 --> 00:30:56,866
onError方法会被调用

825
00:30:56,866 --> 00:30:59,299
就是在这个onError方法我们有机会

826
00:30:59,533 --> 00:31:02,299
去 额…… 处理一些错误

827
00:31:02,833 --> 00:31:03,666
请记住 错误

828
00:31:04,400 --> 00:31:05,266
可在任何地方发生

829
00:31:05,700 --> 00:31:06,700
但是堆栈追踪信息

830
00:31:06,933 --> 00:31:08,066
那个 try-catch 机制

831
00:31:08,633 --> 00:31:09,666
是限制在单个线程的

832
00:31:10,266 --> 00:31:13,266
所以我们而是通过这个机制传播错误

833
00:31:13,266 --> 00:31:14,766
因为请记住 我们的代码

834
00:31:14,900 --> 00:31:18,166
会轻易地从一个线程切换到另一个线程

835
00:31:18,400 --> 00:31:20,000
随着我们在响应式管道中执行代码

836
00:31:20,166 --> 00:31:22,132
所以我们不能假设它们在同一个地方

837
00:31:22,366 --> 00:31:25,166
所以这是非常能用的，自然的方式去处理数据

838
00:31:25,166 --> 00:31:26,966
我们将错误作为另一种数据

839
00:31:27,266 --> 00:31:30,999
而且这也是多线程代码中处理错误的自然方式

840
00:31:31,566 --> 00:31:33,966
最后当我们处理完的数据

841
00:31:33,966 --> 00:31:35,332
onComplete方法会被调用

842
00:31:35,333 --> 00:31:37,033
就是在onComplete 方法里面我们知道

843
00:31:37,033 --> 00:31:39,666
我们无异常地完成了所有事情

844
00:31:40,033 --> 00:31:41,666
你懂得 没有错误

845
00:31:41,933 --> 00:31:45,266
现在 让我们回到这个 onSubscribe 方法

846
00:31:45,266 --> 00:31:47,932
这个我之前说了 应该是最重要的部分了

847
00:31:49,133 --> 00:31:49,866
这个订阅

848
00:31:50,166 --> 00:31:51,799
对于这个订阅者是唯一的

849
00:31:51,800 --> 00:31:52,766
每个订阅者

850
00:31:53,033 --> 00:31:55,233
当订阅到一个发布者

851
00:31:55,600 --> 00:31:57,000
获得一个新的订阅

852
00:31:57,266 --> 00:31:58,299
这个订阅

853
00:31:58,300 --> 00:31:59,433
代表链接

854
00:31:59,833 --> 00:32:01,166
联系 会话可以这样想的话

855
00:32:01,166 --> 00:32:03,066
存在于生产者于消费者之间的

856
00:32:03,066 --> 00:32:04,566
Subscriber 和 Publisher

857
00:32:04,566 --> 00:32:06,266
就是在这个订阅当中

858
00:32:06,266 --> 00:32:08,966
消费者或者订阅者才可以请求

859
00:32:09,633 --> 00:32:10,799
更多的数据或者

860
00:32:11,066 --> 00:32:12,599
另一方面 去取消

861
00:32:13,233 --> 00:32:14,199
数据的产生

862
00:32:14,333 --> 00:32:15,499
所以这是很重要的

863
00:32:15,633 --> 00:32:16,666
订阅者

864
00:32:17,233 --> 00:32:18,633
通过使用订阅

865
00:32:19,033 --> 00:32:20,866
控制消耗的速率

866
00:32:20,966 --> 00:32:23,266
订阅者说 嘿 我在要多十个记录

867
00:32:23,400 --> 00:32:24,100
然后 哇啦

868
00:32:24,733 --> 00:32:26,399
如果有多十个记录的话

869
00:32:26,400 --> 00:32:28,166
就会发给订阅者

870
00:32:28,466 --> 00:32:31,332
但是不会给多 而且时间也不能确定

871
00:32:31,700 --> 00:32:31,933
对吧

872
00:32:32,233 --> 00:32:34,866
在规范里面没有提到这十个记录

873
00:32:35,166 --> 00:32:37,599
会在未来一秒到达之类的

874
00:32:38,066 --> 00:32:39,732
你可能在十年获得十个记录

875
00:32:39,866 --> 00:32:41,032
你不知道 对吧

876
00:32:41,566 --> 00:32:43,432
未来十年你可能每年得到一个记录

877
00:32:43,566 --> 00:32:44,466
是没有保证的

878
00:32:44,933 --> 00:32:46,999
或者你在下一纳秒就得到了十个记录

879
00:32:47,466 --> 00:32:48,666
还是 没有保证的

880
00:32:49,000 --> 00:32:49,933
所以你选择一个数字

881
00:32:50,066 --> 00:32:51,999
那是 一个你可以想象到的

882
00:32:52,100 --> 00:32:54,466
同一时间舒适地 安全地处理

883
00:32:54,466 --> 00:32:55,366
或接近于同一时间

884
00:32:55,366 --> 00:32:56,099
对吧

885
00:32:56,100 --> 00:32:57,466
这是很重要的

886
00:32:57,700 --> 00:32:59,100
有你掌控

887
00:32:59,333 --> 00:33:00,699
消耗的速率

888
00:33:00,966 --> 00:33:03,466
你控制发布者的速率

889
00:33:03,666 --> 00:33:04,566
给你数据的速率

890
00:33:04,900 --> 00:33:06,800
这意味着 如果你受不了

891
00:33:07,066 --> 00:33:08,699
如果你的订阅者 消费者

892
00:33:09,166 --> 00:33:11,066
受不了这么多数据

893
00:33:11,433 --> 00:33:12,099
那是谁的错？

894
00:33:13,200 --> 00:33:13,666
那是你的错

895
00:33:14,566 --> 00:33:15,432
其实这还好

896
00:33:15,433 --> 00:33:18,066
我宁愿你能掌控自己的命运

897
00:33:18,266 --> 00:33:21,499
而不让过于积极的发布者主宰我命运

898
00:33:21,933 --> 00:33:22,166
对吧

899
00:33:22,433 --> 00:33:23,633
所以这给我了这种能力

900
00:33:23,933 --> 00:33:25,966
它给我了数据的客户端

901
00:33:26,466 --> 00:33:30,032
去管理控制流的能力

902
00:33:30,466 --> 00:33:33,066
我控制数据流

903
00:33:33,633 --> 00:33:34,233
这称为

904
00:33:34,600 --> 00:33:36,266
客户端管理的流控制

905
00:33:36,400 --> 00:33:38,466
这 绝对不是什么新概念

906
00:33:38,733 --> 00:33:38,966
对吧

907
00:33:39,333 --> 00:33:42,566
自从同一个网络中有一个计算机和另一个

908
00:33:42,833 --> 00:33:44,199
我们就有了这个概念 流控制

909
00:33:44,600 --> 00:33:46,733
确保方程的一端

910
00:33:46,733 --> 00:33:48,633
产生数据不会比另一端快

911
00:33:48,933 --> 00:33:50,599
绝不是什么新概念

912
00:33:50,733 --> 00:33:51,766
新的东西只是

913
00:33:51,900 --> 00:33:54,533
现在我们在这个概念套了一层表面 API

914
00:33:54,533 --> 00:33:55,933
作为顶层的结构

915
00:33:56,200 --> 00:33:59,166
这是我们可以在 API 显示地做的事情

916
00:33:59,633 --> 00:34:00,433
好吧？

917
00:34:00,533 --> 00:34:01,599
如果我们想要取消

918
00:34:01,800 --> 00:34:02,600
取消数据流

919
00:34:02,600 --> 00:34:04,566
我们同样也可以 这也是很重要的

920
00:34:04,900 --> 00:34:08,900
你不希望卡在一种情形 无法阻止数据太多

921
00:34:09,800 --> 00:34:10,466
流控制

922
00:34:11,200 --> 00:34:12,633
在响应式编程的世界

923
00:34:12,933 --> 00:34:15,066
有时候 多亏营销

924
00:34:15,266 --> 00:34:16,532
被称为 背压式

925
00:34:16,866 --> 00:34:19,366
如果你有听过背压式这个词的话

926
00:34:19,633 --> 00:34:22,366
你可以将其与客户端管理流控制交替使用

927
00:34:22,366 --> 00:34:25,699
这就是已经存在了数十年的概念 对吧

928
00:34:26,233 --> 00:34:26,866
从世界起源开始

929
00:34:27,533 --> 00:34:28,299
哪个世界并不重要

930
00:34:29,600 --> 00:34:31,566
在过去的 70 80 年里的任何东西 对吧？

931
00:34:34,800 --> 00:34:35,233
好了

932
00:34:36,300 --> 00:34:36,866
现在

933
00:34:38,000 --> 00:34:39,200
哈 我们有

934
00:34:39,666 --> 00:34:41,299
发布者 订阅者 和订阅

935
00:34:41,533 --> 00:34:43,399
那是三个 我说有四个的

936
00:34:43,600 --> 00:34:44,366
第四个类型是

937
00:34:44,633 --> 00:34:45,599
是Processor

938
00:34:45,733 --> 00:34:46,399
而处理器

939
00:34:46,766 --> 00:34:48,732
是一个桥梁 一个水源和水槽

940
00:34:48,866 --> 00:34:49,999
在订阅者与发布者之间

941
00:34:50,100 --> 00:34:53,500
消费者 和…… 生产者

942
00:34:53,733 --> 00:34:54,533
ok？ 就是这样

943
00:34:55,100 --> 00:34:55,733
它就是一个桥梁

944
00:34:56,033 --> 00:34:58,266
这就是完整的 Reactive Streams 规范

945
00:34:58,433 --> 00:35:00,333
早告诉你了 很简单的规范

946
00:35:00,533 --> 00:35:01,566
很荒芜的没什么东西

947
00:35:01,566 --> 00:35:04,366
那里边没有什么值得关心的内容的

948
00:35:04,566 --> 00:35:05,499
非常简单的 API

949
00:35:05,500 --> 00:35:06,833
如果你理解所有这些

950
00:35:07,400 --> 00:35:09,000
就目前来说的话 我毫不怀疑你们都懂了

951
00:35:09,000 --> 00:35:11,800
那么恭喜你们 你们是已认证的响应式编程人员

952
00:35:12,300 --> 00:35:13,166
走 去硅谷

953
00:35:13,466 --> 00:35:14,866
筹集数百万资金

954
00:35:15,433 --> 00:35:16,833
炸了各种傻逼派对

955
00:35:17,200 --> 00:35:17,666
你已经准备好了

956
00:35:18,333 --> 00:35:18,899
你可以的了

957
00:35:19,266 --> 00:35:20,832
你已经走在很多硅谷人之前了

958
00:35:21,266 --> 00:35:21,432
ok 

959
00:35:22,000 --> 00:35:23,100
现在 我们有

960
00:35:23,733 --> 00:35:24,599
这四种类型

961
00:35:25,033 --> 00:35:26,566
正如我所说 它们是非常基础的

962
00:35:26,566 --> 00:35:28,166
非常原始的

963
00:35:29,000 --> 00:35:30,566
够了吗？ 这些类型够了吗？

964
00:35:31,666 --> 00:35:33,666
我会说 额…… 不够

965
00:35:33,966 --> 00:35:35,966
是吧？ 我们没有简单的方式可以

966
00:35:36,333 --> 00:35:39,633
支持操作 例如支持 mapping 和 flatmapping 之类

967
00:35:39,800 --> 00:35:42,200
因此 我们有特别实现

968
00:35:42,400 --> 00:35:44,233
首先是 Flux

969
00:35:44,566 --> 00:35:47,299
Flux 来自 Project Reactor

970
00:35:47,300 --> 00:35:48,366
那是一个 pivotal 的项目

971
00:35:48,733 --> 00:35:52,666
它构建在响应式流规范的 Publisher 之上

972
00:35:52,666 --> 00:35:55,999
你可看到 CorePublisher 最终是实现 Publisher

973
00:35:56,500 --> 00:35:57,700
所以你可以看到 Flux

974
00:35:57,866 --> 00:35:59,399
说到底只是一个 Publisher

975
00:35:59,633 --> 00:36:02,866
但同时它也提供了很多，很多，很多操作符

976
00:36:02,866 --> 00:36:03,566
你看到吗？

977
00:36:04,200 --> 00:36:05,066
很多不同的东西

978
00:36:05,200 --> 00:36:05,700
相信我

979
00:36:06,200 --> 00:36:08,833
你不想花费太多时间在这些代码里

980
00:36:09,333 --> 00:36:11,166
你会晕头转向的

981
00:36:12,333 --> 00:36:14,933
所以 只需相信它做了你期望的事情

982
00:36:15,133 --> 00:36:16,299
你想要做什么

983
00:36:16,433 --> 00:36:20,433
OK? 这些代码支持像map 和 flatmap 的操作

984
00:36:20,433 --> 00:36:23,366
还有 filter 所有这些你需要的处理流数据的东西

985
00:36:23,933 --> 00:36:27,399
Flux 是生产者 但它产生 0 到 n 个值

986
00:36:27,400 --> 00:36:28,866
可能不受限的

987
00:36:29,133 --> 00:36:29,799
OK ?

988
00:36:30,766 --> 00:36:32,999
另一方面  Mono

989
00:36:34,466 --> 00:36:36,532
也是一个发布者

990
00:36:37,000 --> 00:36:40,400
它也有这些很多不同的操作符 很多很多操作符

991
00:36:40,400 --> 00:36:41,466
哇！ 对吧？

992
00:36:41,633 --> 00:36:42,866
你可以使用很多东西

993
00:36:43,566 --> 00:36:47,099
但是 Mono 最多产生一个值

994
00:36:47,100 --> 00:36:48,200
0 个 或 1 个

995
00:36:48,200 --> 00:36:50,400
有点像 CompletableFuture

996
00:36:50,566 --> 00:36:51,632
但它支持背压式

997
00:36:51,866 --> 00:36:53,899
OK？ 而且它是基于推的

998
00:36:53,900 --> 00:36:56,233
区别于基于拉的 

999
00:36:56,400 --> 00:36:59,300
好的 那么这就是CorePublisher

1000
00:36:59,500 --> 00:37:01,633
这是一个 Mono 现在我们有这两种不同的东西

1001
00:37:01,633 --> 00:37:04,099
问题是公平起见

1002
00:37:04,433 --> 00:37:06,266
为什么我使用其中一种？

1003
00:37:06,266 --> 00:37:07,832
有人让你渲染一个用户界面

1004
00:37:07,833 --> 00:37:10,299
然后给你一个Publisher<Customer>

1005
00:37:11,200 --> 00:37:12,900
你怎么知道该怎么做？

1006
00:37:13,666 --> 00:37:15,132
如果它们给你一个Mono发布者

1007
00:37:15,433 --> 00:37:17,866
那么你就知道这是单个详细记录

1008
00:37:17,866 --> 00:37:20,966
他们可能想让我渲染这个记录的详情

1009
00:37:21,300 --> 00:37:24,600
对吧 这区别于Flux<Customer>

1010
00:37:25,033 --> 00:37:28,799
那样的话 他们可能想让你渲染所有用户概况列表

1011
00:37:29,200 --> 00:37:30,600
对吧 其中之一

1012
00:37:31,000 --> 00:37:32,566
现在我们有这两种不同的类型

1013
00:37:32,566 --> 00:37:35,432
我们可以用它们写一些样例数据到数据库

1014
00:37:35,433 --> 00:37:37,566
我要创建SampleDataInitializer

1015
00:37:37,666 --> 00:37:39,466
它会监听一些事件

1016
00:37:39,466 --> 00:37:41,866
就像这样 @EvenListener

1017
00:37:45,266 --> 00:37:46,932
然后我们说

1018
00:37:47,533 --> 00:37:48,299
OK？

1019
00:37:48,633 --> 00:37:50,166
我们要写些数据到数据库

1020
00:37:50,166 --> 00:37:52,499
所以 @Component

1021
00:37:53,666 --> 00:37:55,099
只是一个普通的 Spring Bean

1022
00:37:55,100 --> 00:37:57,800
我们在这里注入 reservationRepository

1023
00:37:58,100 --> 00:37:59,100
注入到构造器

1024
00:37:59,100 --> 00:38:01,200
我需要 @RequireArgsConstructor

1025
00:38:01,200 --> 00:38:03,000
还有参数 定义这些数据

1026
00:38:03,000 --> 00:38:04,800
然后我将数据写入到数据库

1027
00:38:04,800 --> 00:38:06,200
通过创建一些名字 好吗？

1028
00:38:06,200 --> 00:38:07,366
所以我要过一遍

1029
00:38:07,366 --> 00:38:10,199
并获取一些名字

1030
00:38:10,200 --> 00:38:12,333
这些是在 Spirng 团队的人

1031
00:38:12,333 --> 00:38:15,099
显然我在其中 很高兴见到你们 我是 Josh

1032
00:38:15,100 --> 00:38:18,100
额... 还有谁？ 我们有 Madhura

1033
00:38:18,100 --> 00:38:19,700
她很厉害 我们有

1034
00:38:19,966 --> 00:38:22,399
Mark Paul Luke 他也很厉害

1035
00:38:22,400 --> 00:38:25,000
我们还有 Olga 她也很厉害

1036
00:38:25,000 --> 00:38:27,466
我们还有 四个了

1037
00:38:27,466 --> 00:38:29,332
还要四个 我们有……

1038
00:38:29,333 --> 00:38:31,933
Spencer 他很厉害

1039
00:38:31,933 --> 00:38:34,299
还有Ria 她很厉害

1040
00:38:34,300 --> 00:38:40,700
Stéphane 法国的不是荷兰的 虽然他也很厉害

1041
00:38:40,933 --> 00:38:42,199
OK 有那么一个人

1042
00:38:42,966 --> 00:38:43,999
额 还有

1043
00:38:45,366 --> 00:38:46,899
额……

1044
00:38:48,000 --> 00:38:48,833
还有谁

1045
00:38:49,766 --> 00:38:50,599
还有谁

1046
00:38:51,866 --> 00:38:54,299
我说的是在 Devoxx 那位

1047
00:38:54,666 --> 00:38:57,032
不是那个 我觉得还有一个在我们 Spring 团队的

1048
00:38:57,033 --> 00:38:58,633
尽管 也欢迎他

1049
00:38:58,966 --> 00:39:00,532
额…… 不对

1050
00:39:00,533 --> 00:39:02,233
额…… 还有谁呢?

1051
00:39:02,233 --> 00:39:06,633
还有额 Violetta 好吧？

1052
00:39:07,000 --> 00:39:08,200
她也很厉害 好了

1053
00:39:08,200 --> 00:39:08,866
现在我们有 

1054
00:39:09,600 --> 00:39:10,666
所有这些不同的名字

1055
00:39:11,933 --> 00:39:12,466
好吧

1056
00:39:13,233 --> 00:39:14,066
好东西

1057
00:39:14,066 --> 00:39:15,932
要开始了 就是这些名字

1058
00:39:16,266 --> 00:39:17,499
我们要做的是

1059
00:39:17,500 --> 00:39:18,800
我们要访问这每一个名字

1060
00:39:18,800 --> 00:39:21,133
我们有由名字组成的响应式流

1061
00:39:21,133 --> 00:39:22,933
我们要访问每一个 并将它变成

1062
00:39:22,933 --> 00:39:24,766
reservation的数据流

1063
00:39:24,766 --> 00:39:26,299
OK 所以 reservations 就这样

1064
00:39:26,533 --> 00:39:27,799
我们将访问其中每一个

1065
00:39:27,800 --> 00:39:29,333
我想要将它们保存到数据库

1066
00:39:29,333 --> 00:39:30,833
我可以写 map

1067
00:39:30,833 --> 00:39:31,966
我可以这样做 我可以写

1068
00:39:31,966 --> 00:39:34,232
然后 我这样做会怎样？

1069
00:39:34,233 --> 00:39:34,866
额 map

1070
00:39:36,133 --> 00:39:38,266
返回 Mone<Reservation>

1071
00:39:38,666 --> 00:39:38,999
OK

1072
00:39:39,233 --> 00:39:41,433
而我不想一个 Mono<Reservation>

1073
00:39:41,433 --> 00:39:42,333
因为如果我这样做

1074
00:39:42,333 --> 00:39:43,566
我会得到这个

1075
00:39:43,733 --> 00:39:45,533
Flux<Mono<Reservation>>

1076
00:39:46,133 --> 00:39:47,066
不是很理想

1077
00:39:47,333 --> 00:39:50,299
而是 我想取出这个内部的发布者

1078
00:39:50,300 --> 00:39:52,100
我有个内部的发布者被这个

1079
00:39:52,433 --> 00:39:54,066
这个Lambda 的返回值创建的

1080
00:39:54,266 --> 00:39:56,499
而且我想压平这个 压平它

1081
00:39:56,500 --> 00:39:58,666
所以我只有 Flux<Mono>

1082
00:39:58,666 --> 00:40:01,166
为了达到目的 你使用 flatMap

1083
00:40:01,200 --> 00:40:04,566
OK？ 就像这样 你可以替换为方法引用

1084
00:40:04,566 --> 00:40:09,232
哇啦 这就是你的新的响应式流 好吧

1085
00:40:09,400 --> 00:40:10,600
所以 现在这是我们的数据

1086
00:40:10,600 --> 00:40:12,666
我要将它存到数据库里

1087
00:40:12,666 --> 00:40:14,666
额 我现在有了这些数据

1088
00:40:14,666 --> 00:40:16,399
如果我现在运行这个程序

1089
00:40:16,633 --> 00:40:18,466
啥都不会发生 你可以看到

1090
00:40:18,733 --> 00:40:20,733
这个响应式流

1091
00:40:20,733 --> 00:40:24,366
这是我们所说的冷的数据流 什么都还未发生

1092
00:40:24,366 --> 00:40:26,299
我们需要实际激活它 对吧

1093
00:40:26,300 --> 00:40:28,833
这有一个终端函数需要被调用

1094
00:40:28,833 --> 00:40:30,266
我们的终端方法就像

1095
00:40:30,266 --> 00:40:31,399
就像 Java 8 Streams API

1096
00:40:31,400 --> 00:40:31,900
所以我们说

1097
00:40:35,100 --> 00:40:38,700
或者我们可以提供一个消费者或者订阅者 对吧

1098
00:40:38,700 --> 00:40:40,000
不要提供订阅者

1099
00:40:40,000 --> 00:40:40,700
太多方法了

1100
00:40:40,700 --> 00:40:42,133
最近我使用 Consumer

1101
00:40:42,133 --> 00:40:43,266
对吧 非常简单

1102
00:40:43,266 --> 00:40:44,532
当然这可以是

1103
00:40:44,533 --> 00:40:45,833
Java 8 lambda

1104
00:40:46,233 --> 00:40:47,433
所以 哇啦

1105
00:40:47,600 --> 00:40:49,066
log.info OK？

1106
00:40:50,866 --> 00:40:52,099
Log4j2

1107
00:40:53,166 --> 00:40:55,766
然后是 reservations

1108
00:40:56,366 --> 00:40:58,532
好 这可以是一个方法引用

1109
00:40:59,833 --> 00:41:01,199
所以 就是这样 OK？

1110
00:41:01,200 --> 00:41:02,166
这就是所有东西

1111
00:41:02,733 --> 00:41:04,266
现在 我可以那样做

1112
00:41:04,600 --> 00:41:05,433
但在我做之前

1113
00:41:05,433 --> 00:41:06,699
让我们想一下会发生什么

1114
00:41:06,966 --> 00:41:08,199
我要运行这个程序

1115
00:41:08,200 --> 00:41:10,433
它是 额…… 顺便设置一下

1116
00:41:11,666 --> 00:41:13,699
我懒 我希望我的代码也是

1117
00:41:14,000 --> 00:41:15,166
所以就这样 现在

1118
00:41:15,466 --> 00:41:16,832
我要运行这个程序

1119
00:41:17,333 --> 00:41:19,466
它会将一串数据

1120
00:41:19,866 --> 00:41:21,766
它会创建一个预约流

1121
00:41:21,766 --> 00:41:23,766
并会保存每一个到数据库

1122
00:41:23,933 --> 00:41:25,133
当我运行这个程序

1123
00:41:25,333 --> 00:41:27,433
多次运行 经过连续的迭代

1124
00:41:27,666 --> 00:41:29,799
我会看到数据库反映同样的数据

1125
00:41:29,900 --> 00:41:30,666
多次

1126
00:41:30,900 --> 00:41:33,066
那不是我想要的 我想先清理一下

1127
00:41:33,200 --> 00:41:34,733
所以我先删除所有东西

1128
00:41:34,933 --> 00:41:35,566
所以让我们写

1129
00:41:38,266 --> 00:41:39,999
这会返回一个Mono

1130
00:41:40,133 --> 00:41:41,833
那是一个异步的 Void

1131
00:41:42,266 --> 00:41:42,899
那么之后

1132
00:41:43,500 --> 00:41:45,266
不是订阅

1133
00:41:45,266 --> 00:41:46,632
我可以写.subscribe

1134
00:41:47,233 --> 00:41:48,199
但那就会很奇怪了

1135
00:41:48,200 --> 00:41:48,933
我会有一个嵌套的

1136
00:41:48,933 --> 00:41:50,833
我会有一个嵌套的回调

1137
00:41:51,000 --> 00:41:51,800
而不是做

1138
00:41:52,000 --> 00:41:53,533
嵌套的回调之类的东西

1139
00:41:53,800 --> 00:41:54,833
我是用操作符

1140
00:41:54,833 --> 00:41:55,899
将各种串联起来

1141
00:41:55,900 --> 00:41:57,133
一个发布者到另一个

1142
00:41:57,400 --> 00:41:59,100
所以我要写 saved

1143
00:41:59,333 --> 00:42:00,199
然后

1144
00:42:00,833 --> 00:42:01,599
我想写

1145
00:42:01,866 --> 00:42:02,732
找到数据

1146
00:42:02,733 --> 00:42:04,166
然后当且仅当

1147
00:42:04,366 --> 00:42:05,532
我才想打印日志出结果

1148
00:42:05,733 --> 00:42:06,466
所以我实际上

1149
00:42:06,466 --> 00:42:08,099
所以我实际上使用操作符去保证

1150
00:42:08,100 --> 00:42:09,366
所有东西都删除了

1151
00:42:09,633 --> 00:42:10,533
异步地

1152
00:42:10,800 --> 00:42:11,466
加个限制

1153
00:42:11,666 --> 00:42:13,399
仅当它全部完成了

1154
00:42:13,566 --> 00:42:15,066
之后我才管保存数据

1155
00:42:15,266 --> 00:42:16,166
仅当那个时候

1156
00:42:16,166 --> 00:42:17,899
在我保存了所有东西之后 才管

1157
00:42:17,900 --> 00:42:19,566
问数据库取数据

1158
00:42:19,666 --> 00:42:21,366
另一个要注意的是

1159
00:42:21,533 --> 00:42:23,799
正如我在这串起的管道

1160
00:42:24,033 --> 00:42:26,399
你也可以  你更经常

1161
00:42:26,400 --> 00:42:29,200
你会在这里串起这些东西

1162
00:42:29,433 --> 00:42:30,533
所以在管道的定义

1163
00:42:30,533 --> 00:42:31,766
让我们看一下那个代码

1164
00:42:32,133 --> 00:42:33,199
因此 OK

1165
00:42:33,866 --> 00:42:34,566
现在就是这样

1166
00:42:34,800 --> 00:42:35,566
完成了这部分

1167
00:42:35,666 --> 00:42:36,232
这就变成

1168
00:42:36,433 --> 00:42:37,233
一个 Reservation

1169
00:42:37,600 --> 00:42:38,366
OK 这就是

1170
00:42:38,700 --> 00:42:39,500
新的管道

1171
00:42:39,600 --> 00:42:41,000
保存数据记录的管道

1172
00:42:41,333 --> 00:42:41,566
额

1173
00:42:42,500 --> 00:42:43,200
老实说

1174
00:42:43,933 --> 00:42:44,766
这是正确的做法

1175
00:42:45,166 --> 00:42:45,366
对吧

1176
00:42:46,200 --> 00:42:46,666
Java

1177
00:42:47,133 --> 00:42:47,799
有 var

1178
00:42:48,500 --> 00:42:49,100
前缀了

1179
00:42:49,700 --> 00:42:50,100
所以

1180
00:42:50,866 --> 00:42:51,599
你应该用那个

1181
00:42:51,833 --> 00:42:52,133
OK？

1182
00:42:52,633 --> 00:42:52,933
现在

1183
00:42:53,466 --> 00:42:53,899
额

1184
00:42:54,400 --> 00:42:54,966
这边

1185
00:42:55,900 --> 00:42:56,733
我的管道

1186
00:42:57,200 --> 00:42:57,600
额

1187
00:42:58,633 --> 00:42:59,199
你可以看到

1188
00:42:59,366 --> 00:42:59,832
这个

1189
00:42:59,833 --> 00:43:00,533
这些操作符

1190
00:43:00,533 --> 00:43:01,399
让使用

1191
00:43:02,033 --> 00:43:03,266
响应式流的类型

1192
00:43:03,666 --> 00:43:04,399
非常有用

1193
00:43:04,600 --> 00:43:05,933
对吧 而响应式流类型

1194
00:43:06,233 --> 00:43:07,933
是 它们是 JDK 8

1195
00:43:08,333 --> 00:43:08,699
友好的

1196
00:43:08,966 --> 00:43:09,132
对吧

1197
00:43:09,533 --> 00:43:11,133
这并不是说必须要用 Java 8

1198
00:43:11,133 --> 00:43:12,533
你可以用更早的版本 对吧

1199
00:43:12,833 --> 00:43:13,766
顺便说一下 它们是

1200
00:43:14,033 --> 00:43:14,833
而且这很重要

1201
00:43:15,100 --> 00:43:15,566
它们是

1202
00:43:16,233 --> 00:43:17,333
这些等价的类

1203
00:43:17,333 --> 00:43:18,499
在 Java 本身里面了

1204
00:43:18,600 --> 00:43:19,533
自从 Java 9 开始

1205
00:43:19,533 --> 00:43:21,899
所以你可以看到 java.util.concurrent Flow

1206
00:43:22,466 --> 00:43:23,166
.Processor

1207
00:43:23,600 --> 00:43:24,266
Flow

1208
00:43:24,700 --> 00:43:25,700
Flow.Subscription

1209
00:43:26,033 --> 00:43:28,899
Flow.Subscriber 还有 Flow.Publisher

1210
00:43:29,233 --> 00:43:31,466
这些类型被镜像到 JDK 里面了

1211
00:43:31,666 --> 00:43:32,699
已经超过两年了

1212
00:43:33,466 --> 00:43:34,032
每行都一样的

1213
00:43:34,166 --> 00:43:35,332
唯一不同的只是

1214
00:43:35,600 --> 00:43:36,333
包不同

1215
00:43:36,833 --> 00:43:38,433
所以当你谈论响应式流

1216
00:43:38,533 --> 00:43:39,733
重要的是要注意

1217
00:43:39,966 --> 00:43:42,299
你可能说的是 Java 9 的响应式流

1218
00:43:42,600 --> 00:43:42,966
或者是

1219
00:43:43,166 --> 00:43:44,999
或者是响应式流规范本身

1220
00:43:45,000 --> 00:43:46,933
那个给了 Java 9 响应式流灵感的

1221
00:43:47,366 --> 00:43:49,032
大部分 API 例如 Reactor

1222
00:43:49,333 --> 00:43:51,766
支持从一种切换到另一个

1223
00:43:51,766 --> 00:43:52,332
你可以适配

1224
00:43:52,600 --> 00:43:54,166
Java Flow 的 Publisher 到

1225
00:43:54,266 --> 00:43:55,466
到普通的 Publisher

1226
00:43:55,466 --> 00:43:56,266
反之亦然

1227
00:43:56,433 --> 00:43:56,766
OK?

1228
00:43:59,866 --> 00:44:00,999
现在

1229
00:44:02,200 --> 00:44:03,533
让我们运行这些代码 看有什么结果

1230
00:44:10,800 --> 00:44:11,300
现在好了

1231
00:44:12,466 --> 00:44:13,099
编译

1232
00:44:13,533 --> 00:44:14,299
我们看看

1233
00:44:15,400 --> 00:44:15,966
你看看

1234
00:44:17,666 --> 00:44:18,432
朋友们看到吗

1235
00:44:19,600 --> 00:44:20,333
数据在这呢

1236
00:44:20,500 --> 00:44:20,866
这行得通

1237
00:44:21,233 --> 00:44:22,166
你可以看到这数据

1238
00:44:23,766 --> 00:44:24,599
已经反映出来了

1239
00:44:24,766 --> 00:44:25,999
在这里并显示在控制台上

1240
00:44:26,666 --> 00:44:27,066
这行得通

1241
00:44:27,900 --> 00:44:28,966
这当然行啦

1242
00:44:30,100 --> 00:44:30,633
因为这是个dmeo

1243
00:44:32,833 --> 00:44:33,666
你还期待什么呢？

1244
00:44:34,700 --> 00:44:36,266
这总是行得通的

1245
00:44:36,266 --> 00:44:38,766
这并没有很有趣对吗

1246
00:44:38,766 --> 00:44:42,032
我们可以看到那个 id 是 UUID

1247
00:44:42,033 --> 00:44:44,266
那与 MongoDB 里的相匹配

1248
00:44:44,266 --> 00:44:45,599
如果我到这里

1249
00:44:46,333 --> 00:44:49,999
输入 db.reservation.find({ })；

1250
00:44:52,500 --> 00:44:53,466
然后这是数据

1251
00:44:53,466 --> 00:44:53,832
你可以看到

1252
00:44:54,200 --> 00:44:56,166
Mark Stéphane 等等

1253
00:44:56,466 --> 00:44:57,132
所有这些名字

1254
00:44:57,366 --> 00:44:59,232
都反映在数据库里

1255
00:44:59,233 --> 00:45:01,533
但并没有按照特定的顺序出现 对吧？

1256
00:45:02,400 --> 00:45:02,600
对吧？

1257
00:45:03,266 --> 00:45:03,966
那是因为

1258
00:45:04,133 --> 00:45:04,766
我们使用

1259
00:45:05,533 --> 00:45:05,999
flatMap

1260
00:45:06,533 --> 00:45:06,766
好吧?

1261
00:45:07,233 --> 00:45:07,766
所以 flatMap

1262
00:45:08,100 --> 00:45:08,900
压扁了所有东西

1263
00:45:09,200 --> 00:45:11,800
但它这样做乱串了结果

1264
00:45:11,800 --> 00:45:13,166
一样东西被压扁

1265
00:45:13,300 --> 00:45:14,466
如果一样东西解决了

1266
00:45:14,633 --> 00:45:14,933
首先

1267
00:45:15,233 --> 00:45:16,733
在内部的发布者

1268
00:45:17,100 --> 00:45:19,133
那么解释的数据流 saved

1269
00:45:19,800 --> 00:45:21,166
可能会是乱序的

1270
00:45:21,266 --> 00:45:22,366
我可能有 1 2 3

1271
00:45:22,366 --> 00:45:23,399
但我可能得到 3 2 1

1272
00:45:23,800 --> 00:45:25,433
然后最后的东西被 flatMap

1273
00:45:25,733 --> 00:45:25,866
OK?

1274
00:45:26,400 --> 00:45:26,800
这就是

1275
00:45:27,166 --> 00:45:28,732
这很有趣 我们有数据在数据库

1276
00:45:28,900 --> 00:45:31,133
这能运行 这当然能运行啦 像我所说那样 这是demo

1277
00:45:31,466 --> 00:45:32,032
肯定能跑的

1278
00:45:32,366 --> 00:45:34,232
这真的不是我在这里的原因

1279
00:45:34,700 --> 00:45:35,233
如往常一样

1280
00:45:36,100 --> 00:45:37,433
我想重点指出的是这个

1281
00:45:38,033 --> 00:45:38,466
这个

1282
00:45:38,600 --> 00:45:40,000
是 Spring Boot 的纯文本艺术字

1283
00:45:40,600 --> 00:45:41,966
这艺术字花很长时间才弄好哇

1284
00:45:41,966 --> 00:45:44,132
在我们Spring 团队有很不少人是博士来的

1285
00:45:44,466 --> 00:45:44,866
还有 PhD

1286
00:45:44,866 --> 00:45:49,332
这些人的前半生从事核物理

1287
00:45:50,866 --> 00:45:52,399
让我很开心地想象

1288
00:45:52,400 --> 00:45:53,666
某日某处突然

1289
00:45:53,900 --> 00:45:55,600
有个 GitHub issue 说讨厌这东西

1290
00:45:56,266 --> 00:45:58,199
所以我们需要有好看的纯文本艺术字

1291
00:45:59,033 --> 00:46:00,733
我想你会认同他们做了很好的工作

1292
00:46:01,300 --> 00:46:03,066
因此我想花点时间

1293
00:46:03,066 --> 00:46:03,999
如此少的时间

1294
00:46:04,000 --> 00:46:06,733
谈一下明显的缺陷

1295
00:46:06,733 --> 00:46:08,633
在 IntelliJ Jetbrains 产品

1296
00:46:09,033 --> 00:46:10,099
即便我是他家粉丝

1297
00:46:10,333 --> 00:46:10,999
我认为这个

1298
00:46:11,266 --> 00:46:12,166
这个特别的复选框

1299
00:46:12,366 --> 00:46:14,232
特别的没远见

1300
00:46:15,533 --> 00:46:16,333
你看到这个复选框吗

1301
00:46:16,866 --> 00:46:17,632
这边这个

1302
00:46:17,633 --> 00:46:18,266
你看到这个复选框吗

1303
00:46:18,266 --> 00:46:18,999
这边这个

1304
00:46:19,000 --> 00:46:19,333
你看到吗？

1305
00:46:19,333 --> 00:46:19,699
你看到吗？

1306
00:46:19,700 --> 00:46:21,300
你看到这个复选框吗

1307
00:46:21,733 --> 00:46:22,099
就是这个

1308
00:46:22,833 --> 00:46:23,233
就在这

1309
00:46:24,166 --> 00:46:24,499
那个

1310
00:46:25,933 --> 00:46:26,599
如果你想点这个

1311
00:46:26,866 --> 00:46:27,332
不要点它

1312
00:46:28,900 --> 00:46:30,400
如果你勾选这个复选框

1313
00:46:30,966 --> 00:46:31,966
禁止输出

1314
00:46:32,366 --> 00:46:33,399
纯文本艺术字

1315
00:46:35,400 --> 00:46:35,866
搞什么鬼?

1316
00:46:38,533 --> 00:46:39,399
为什么会有这个复选框？

1317
00:46:40,466 --> 00:46:41,766
这是一个很傻的特性

1318
00:46:42,566 --> 00:46:43,532
甚至没有人想要这样的特性

1319
00:46:43,766 --> 00:46:44,099
好吗

1320
00:46:45,000 --> 00:46:45,800
不知道为什么会有这个

1321
00:46:45,800 --> 00:46:47,866
我做了这情况下一般人都会做的事情

1322
00:46:48,066 --> 00:46:48,866
我上网

1323
00:46:49,233 --> 00:46:50,066
并哭诉

1324
00:46:50,366 --> 00:46:51,499
然而一个让人有信心的消息

1325
00:46:51,733 --> 00:46:53,233
来自我的朋友Yann Céborn

1326
00:46:53,233 --> 00:46:54,899
这就是 Yann 在这里 噢不在

1327
00:46:56,200 --> 00:46:57,366
好吧 推特 干活吧

1328
00:46:58,766 --> 00:46:59,266
来了

1329
00:46:59,700 --> 00:47:00,800
这个是 Yann Céborn

1330
00:47:04,066 --> 00:47:04,499
Yann

1331
00:47:04,800 --> 00:47:06,433
是 Jetbrains 公司的开发布道者

1332
00:47:07,500 --> 00:47:08,033
这就是他

1333
00:47:25,700 --> 00:47:26,833
他给我发这条让人感到希望的消息

1334
00:47:26,833 --> 00:47:28,266
我想跟大家分享一下

1335
00:47:28,600 --> 00:47:29,333
今天在这里

1336
00:47:44,633 --> 00:47:45,899
我认识 Yann 很久了

1337
00:47:45,900 --> 00:47:46,766
我们是朋友

1338
00:47:47,500 --> 00:47:48,433
而且我很欣赏他

1339
00:47:48,633 --> 00:47:49,333
而每次

1340
00:47:49,533 --> 00:47:51,066
每次有个新版本的 IntelliJ

1341
00:47:51,066 --> 00:47:53,332
他会说，不要担心 Josh 那会在下个版本修复的

1342
00:47:53,600 --> 00:47:54,733
一切都会好的 Josh

1343
00:47:54,966 --> 00:47:55,766
不用担心 Josh

1344
00:47:56,066 --> 00:47:58,632
下个版本就会修复的了 我想你保证

1345
00:47:58,833 --> 00:48:00,399
你知道吗，他每次这样说我都想相信他

1346
00:48:00,533 --> 00:48:02,599
我相信他 因为我认识他很久了

1347
00:48:02,800 --> 00:48:03,833
他是个好人

1348
00:48:04,000 --> 00:48:05,600
我想相信他 但是你知道吗？

1349
00:48:05,933 --> 00:48:07,366
你知道吗 我就开始在想

1350
00:48:07,366 --> 00:48:09,399
可能…… 可能 可能……

1351
00:48:09,766 --> 00:48:11,066
他在耍我

1352
00:48:11,666 --> 00:48:12,032
好吧

1353
00:48:12,800 --> 00:48:13,833
我不感激他了

1354
00:48:14,766 --> 00:48:15,866
随意吧 不管怎样

1355
00:48:16,300 --> 00:48:17,366
我有很好的纯文本艺术字

1356
00:48:17,366 --> 00:48:18,166
人们经常问的是

1357
00:48:18,500 --> 00:48:20,133
人们经常问的是 嘿

1358
00:48:20,866 --> 00:48:22,232
我可以修改纯文本艺术字吗

1359
00:48:22,366 --> 00:48:23,099
我可以将它重写吗

1360
00:48:24,166 --> 00:48:25,166
这是很糟糕的想法

1361
00:48:25,300 --> 00:48:26,500
你不可能做得比这个好的

1362
00:48:26,933 --> 00:48:27,433
有点自知之明

1363
00:48:27,833 --> 00:48:28,399
但还是要说

1364
00:48:28,933 --> 00:48:31,299
如果那是你的特别想法 那是你想做的事情

1365
00:48:31,666 --> 00:48:32,632
那么那是可能的

1366
00:48:32,933 --> 00:48:34,166
而且有好几种方式可以做到

1367
00:48:34,166 --> 00:48:36,132
你实际上可以创建你自己的纯文本艺术字横幅

1368
00:48:36,400 --> 00:48:37,200
我现在就演示这个

1369
00:48:38,700 --> 00:48:39,700
去到你的构建目录

1370
00:48:48,533 --> 00:48:49,333
我要来这里

1371
00:48:49,666 --> 00:48:50,632
停止应用

1372
00:48:53,133 --> 00:48:55,333
我们刚过完万圣节 这个吓人的骷髅

1373
00:48:57,433 --> 00:48:57,633
OK

1374
00:48:58,066 --> 00:49:01,599
有了那个 我现在运行：mvn spring-boot:run

1375
00:49:03,933 --> 00:49:04,633
就是这样

1376
00:49:09,300 --> 00:49:09,800
哦耶

1377
00:49:12,033 --> 00:49:12,999
对吧 好很多了

1378
00:49:13,366 --> 00:49:14,866
一些值得欣赏的地方 首先

1379
00:49:15,100 --> 00:49:15,933
很好的 纯文本艺术

1380
00:49:16,200 --> 00:49:16,933
其次的话

1381
00:49:17,733 --> 00:49:18,466
其次的话

1382
00:49:22,166 --> 00:49:22,499
喵

1383
00:49:24,100 --> 00:49:25,000
然后我最喜欢的部分

1384
00:49:34,033 --> 00:49:34,499
很牛逼

1385
00:49:35,966 --> 00:49:36,666
我喜欢这个

1386
00:49:37,166 --> 00:49:38,399
所以 不管怎样 这是好东西

1387
00:49:38,400 --> 00:49:40,100
那是旧的东西 你之前就可以这样做了

1388
00:49:40,100 --> 00:49:41,200
这完全不是什么新花样

1389
00:49:41,433 --> 00:49:43,733
所以人们经常问的是 我可以做得更好吗

1390
00:49:43,733 --> 00:49:46,399
有什么东西 下一代的看起来是怎样的？

1391
00:49:46,700 --> 00:49:48,766
然后 朋友们 就是这个了

1392
00:49:51,366 --> 00:49:51,599
好吗

1393
00:49:52,933 --> 00:49:55,233
我们现在玩的是 gif 动图

1394
00:49:56,100 --> 00:49:57,866
现在我用 curl 下载它

1395
00:50:06,266 --> 00:50:06,766
OK 

1396
00:50:07,433 --> 00:50:08,299
很快的WiFI

1397
00:50:09,166 --> 00:50:09,566
OK

1398
00:50:14,100 --> 00:50:15,133
然后 运行

1399
00:50:23,300 --> 00:50:23,700
很不错

1400
00:50:24,466 --> 00:50:25,432
你们可以鼓掌

1401
00:50:29,500 --> 00:50:30,433
这太漂亮了

1402
00:50:33,300 --> 00:50:34,566
这并不是对我没影响

1403
00:50:34,566 --> 00:50:35,699
噢 我没有做清除

1404
00:50:35,866 --> 00:50:37,066
并不是对我没有啥影响

1405
00:50:37,700 --> 00:50:42,600
但是在一个异步响应式的世界的代码里

1406
00:50:43,433 --> 00:50:46,199
这个东西 特别阻塞

1407
00:50:46,800 --> 00:50:47,033
对吧

1408
00:50:47,600 --> 00:50:48,466
在所有事情中

1409
00:50:48,800 --> 00:50:51,833
不过 没错 这似乎增加了三十秒启动时间

1410
00:50:52,133 --> 00:50:52,766
我甚至都不关心

1411
00:50:53,166 --> 00:50:53,766
完全是值得的

1412
00:50:54,300 --> 00:50:55,566
绝对是令人惊叹的对吧

1413
00:50:56,400 --> 00:50:59,033
哈 但是还是因为我们只有很少时间

1414
00:50:59,400 --> 00:51:02,400
我要移除这东西了 承受不了留着这东西在代码里 

1415
00:51:02,566 --> 00:51:03,599
OK 所以我将要

1416
00:51:06,900 --> 00:51:08,200
banner.gif

1417
00:51:08,600 --> 00:51:09,133
拜拜

1418
00:51:09,700 --> 00:51:11,200
mvn clean 拜拜

1419
00:51:12,000 --> 00:51:14,800
OK 那么现在我们有很漂亮的纯文本艺术字

1420
00:51:14,800 --> 00:51:16,300
我们有很漂亮的纯文本艺术字

1421
00:51:16,600 --> 00:51:17,600
我们有数据在数据库里面

1422
00:51:17,766 --> 00:51:19,066
目前为止我使用的是 MongoDB

1423
00:51:19,066 --> 00:51:21,699
MongoDB 是一个不错的数据库

1424
00:51:21,700 --> 00:51:23,200
用于响应式处理

1425
00:51:23,266 --> 00:51:24,566
它有不少特性

1426
00:51:24,900 --> 00:51:26,200
有点有趣

1427
00:51:26,300 --> 00:51:28,566
我认为我已经表达的很清楚了

1428
00:51:28,766 --> 00:51:29,699
在响应式的世界里

1429
00:51:29,866 --> 00:51:32,199
例如 有些东西称为 Tailable 查询

1430
00:51:32,200 --> 00:51:34,000
你可以告诉MongoDB 

1431
00:51:34,566 --> 00:51:35,799
我想问你一个问题

1432
00:51:36,066 --> 00:51:38,166
我想你一直检查自己

1433
00:51:38,566 --> 00:51:39,899
等待一个答案

1434
00:51:40,433 --> 00:51:43,366
例如一个小时之后 如果有匹配问题

1435
00:51:43,500 --> 00:51:45,733
那么请告诉我，给我一个结果集

1436
00:51:45,733 --> 00:51:48,699
解释的结果与断言匹配

1437
00:51:48,866 --> 00:51:52,099
而不是一直在拉取数据库

1438
00:51:52,100 --> 00:51:54,133
我可以让MongoDB 告诉我

1439
00:51:54,133 --> 00:51:55,566
这是一个很自然的事情

1440
00:51:55,566 --> 00:51:57,232
在响应式的世界里

1441
00:51:57,233 --> 00:52:01,333
嘿 在我的数据仓库里面 你说 你只需要添加 @Tailable

1442
00:52:02,666 --> 00:52:04,632
你可以写 我想表达一个

1443
00:52:05,066 --> 00:52:07,232
一个查询 额 一个finder方法

1444
00:52:07,666 --> 00:52:08,799
findByName

1445
00:52:10,300 --> 00:52:10,566
OK ?

1446
00:52:10,866 --> 00:52:12,166
这就能用了

1447
00:52:12,166 --> 00:52:14,899
你只需要 你需要确保你已经启用 MongoDB

1448
00:52:15,200 --> 00:52:16,333
在一个集群模式

1449
00:52:16,333 --> 00:52:17,766
这个我还没有设置好 所以我不演示了

1450
00:52:18,066 --> 00:52:20,266
但 在那之后你只需要

1451
00:52:20,633 --> 00:52:22,299
你可以在你的代码仓库运行这个方法

1452
00:52:22,466 --> 00:52:25,066
然后它就会给你发送符合断言的结果

1453
00:52:25,300 --> 00:52:27,233
非常有用 额……

1454
00:52:27,666 --> 00:52:29,432
MongoDB 是个很好的体验

1455
00:52:29,433 --> 00:52:30,799
你可以做各种酷事情

1456
00:52:31,000 --> 00:52:32,666
在响应式的世界里 不过

1457
00:52:33,366 --> 00:52:34,499
这不是唯一的选择

1458
00:52:34,666 --> 00:52:36,299
我们在Spring Data 的世界里

1459
00:52:36,533 --> 00:52:40,866
有很多项目现在支持响应式 NoSQL 数据访问

1460
00:52:41,033 --> 00:52:42,999
包含但不仅限于 MongoDB

1461
00:52:43,000 --> 00:52:44,600
我们有 Cassandra

1462
00:52:44,600 --> 00:52:45,733
有 CouchBase

1463
00:52:45,733 --> 00:52:47,399
我们有 Redis

1464
00:52:47,400 --> 00:52:50,733
这些都已经是 GA 了的响应式支持 NoSQL 选择

1465
00:52:50,733 --> 00:52:52,499
但更进一步

1466
00:52:52,500 --> 00:52:53,933
我们有 azure cosmos db

1467
00:52:53,933 --> 00:52:55,866
现在也支持响应式数据访问了

1468
00:52:55,966 --> 00:52:58,332
来自微软的 微软 Azure Cosmos DB

1469
00:52:58,333 --> 00:53:00,266
我们有Neo4J 2.0

1470
00:53:00,266 --> 00:53:04,199
对吧 新的Rx Neo4J

1471
00:53:04,200 --> 00:53:05,400
Spring Data 项目

1472
00:53:05,800 --> 00:53:09,866
那也支持响应式NoSQL 之类的数据访问

1473
00:53:09,866 --> 00:53:11,099
用于那个图数据库

1474
00:53:11,100 --> 00:53:12,366
我们有很多选择

1475
00:53:12,366 --> 00:53:14,766
包括已经 GA 的和还在开发的

1476
00:53:14,766 --> 00:53:15,832
那正在向前看的

1477
00:53:15,833 --> 00:53:19,566
我们甚至有更多 除了我不太能确定可以说的

1478
00:53:19,566 --> 00:53:21,632
OK 这些都在出来

1479
00:53:22,166 --> 00:53:23,699
但是人们经常问的问题是

1480
00:53:23,866 --> 00:53:25,132
OK 这很好

1481
00:53:25,433 --> 00:53:26,666
我可以做 SQL 数据访问吗

1482
00:53:26,933 --> 00:53:28,666
这是很多人在问的对吧

1483
00:53:28,800 --> 00:53:31,333
所以你们有多少人用 MongoDB 的？

1484
00:53:32,600 --> 00:53:35,766
OK 比我想象中的人多 你懂得

1485
00:53:36,033 --> 00:53:37,233
五年前 额

1486
00:53:37,833 --> 00:53:39,466
你们有多少人使用 Cassandra？

1487
00:53:40,933 --> 00:53:45,699
这有 一些人 我可以给你们买啤酒都不觉得破费

1488
00:53:46,400 --> 00:53:49,533
额 你们有多少人用 Redis

1489
00:53:49,833 --> 00:53:52,999
我猜 这个估计是最受欢迎的了 嗯 是的 OK

1490
00:53:53,333 --> 00:53:56,933
但 仍然是 我们讨论的只是少数人

1491
00:53:56,933 --> 00:53:59,166
我认为没有 10% 我会说

1492
00:53:59,466 --> 00:54:00,299
大概 5% 对吧

1493
00:54:00,533 --> 00:54:02,599
所以不是很多人使用那东西

1494
00:54:02,600 --> 00:54:03,733
couchbase 呢?

1495
00:54:04,000 --> 00:54:05,200
CouchBase 好东西

1496
00:54:05,533 --> 00:54:07,566
啊 大概有五六个人啊

1497
00:54:07,700 --> 00:54:10,133
OK 你们有多少人有 SQL 存储的？

1498
00:54:10,133 --> 00:54:11,766
在你的代码里

1499
00:54:12,166 --> 00:54:14,599
呀 OK 大多数人对吧

1500
00:54:15,133 --> 00:54:17,033
只是小的大多数 但还是大多数人

1501
00:54:17,933 --> 00:54:21,666
所以 问题是在响应式我们怎么支持 SQL 数据访问？

1502
00:54:21,900 --> 00:54:23,566
这是非常常见的问题

1503
00:54:23,566 --> 00:54:24,532
所以几年前

1504
00:54:24,800 --> 00:54:26,433
我们创建了 R2DBC

1505
00:54:26,800 --> 00:54:27,666
OK R2DBC

1506
00:54:27,900 --> 00:54:30,033
是…… 额 是一个抽象层

1507
00:54:30,033 --> 00:54:32,299
支持响应式关系数据库链接

1508
00:54:32,600 --> 00:54:34,266
那里有个核心的 SPI

1509
00:54:34,466 --> 00:54:37,166
还有数个不同的实现

1510
00:54:37,166 --> 00:54:39,732
有不同的驱动 如果你这样想的话

1511
00:54:39,733 --> 00:54:42,033
支持对像PostgresSQL等的访问

1512
00:54:42,233 --> 00:54:43,366
微软的 SQL Server

1513
00:54:43,533 --> 00:54:44,199
还有 H2

1514
00:54:44,200 --> 00:54:46,733
现在也有一个第三方项目

1515
00:54:46,933 --> 00:54:49,033
支持 MySQL

1516
00:54:49,300 --> 00:54:49,633
对吧？

1517
00:54:49,700 --> 00:54:51,033
这里还有更多

1518
00:54:51,233 --> 00:54:52,566
R2DBC 实现

1519
00:54:52,933 --> 00:54:53,966
在路上（正在开发中）

1520
00:54:54,233 --> 00:54:55,233
额 Mark

1521
00:54:55,933 --> 00:54:56,966
我们还有什么实现

1522
00:54:58,733 --> 00:54:59,366
那个我已经提到过了

1523
00:55:02,166 --> 00:55:03,599
Spenner Google Cloud Spenner 是的

1524
00:55:05,033 --> 00:55:05,533
SAP Hive

1525
00:55:05,533 --> 00:55:07,766
所以我们也有这些进来

1526
00:55:07,766 --> 00:55:09,199
所以有很多正在开发

1527
00:55:09,400 --> 00:55:10,833
还有很多我们不能提及的

1528
00:55:11,100 --> 00:55:12,700
那些正在开发中的 对吧

1529
00:55:12,700 --> 00:55:14,500
这些是所有不同的 R2DBC 实现

1530
00:55:14,500 --> 00:55:15,766
R2DBC

1531
00:55:16,466 --> 00:55:17,366
在目前

1532
00:55:18,066 --> 00:55:19,766
还有没有 GA

1533
00:55:20,300 --> 00:55:21,533
还没有 GA 的

1534
00:55:21,833 --> 00:55:23,133
所以我在这一刻

1535
00:55:23,533 --> 00:55:24,333
在这一刻

1536
00:55:24,566 --> 00:55:25,666
我希望你觉得

1537
00:55:25,933 --> 00:55:29,799
持有像对待PHP一样的犹豫怀疑态度

1538
00:55:30,600 --> 00:55:31,333
PHP

1539
00:55:32,933 --> 00:55:33,866
这边是生产环境

1540
00:55:34,500 --> 00:55:35,266
这边是 PHP

1541
00:55:35,600 --> 00:55:36,300
他们不应该相遇的

1542
00:55:37,266 --> 00:55:37,799
OK?

1543
00:55:38,666 --> 00:55:39,732
不过 不过

1544
00:55:40,333 --> 00:55:41,499
我刚被通知

1545
00:55:42,400 --> 00:55:46,033
这个很快就会 GA 了

1546
00:55:46,266 --> 00:55:47,666
那是什么时候？我的朋友

1547
00:55:49,066 --> 00:55:49,666
感恩节

1548
00:55:49,933 --> 00:55:51,133
不是加拿大的感恩节

1549
00:55:52,000 --> 00:55:53,733
OK 那是更加往后的 大概在那一周后

1550
00:55:54,033 --> 00:55:55,133
所以这个月的下旬

1551
00:55:55,233 --> 00:55:57,033
十一月底 最后一个星期四

1552
00:55:57,466 --> 00:56:01,699
额 或者是差不多的时候 我们应该会有 GA 的

1553
00:56:01,833 --> 00:56:03,166
那会包含存储过程吗？

1554
00:56:04,600 --> 00:56:06,066
没有 所以它会有 基本上

1555
00:56:06,466 --> 00:56:09,999
按照我的理解 它会支持大多数东西 除了存储过程

1556
00:56:10,000 --> 00:56:14,366
我们会让 API 稳定下来再看看那会是怎么样

1557
00:56:14,633 --> 00:56:15,499
在我们实现那个之前

1558
00:56:15,500 --> 00:56:17,766
所以你能够像 GA 的风格使用它

1559
00:56:17,900 --> 00:56:19,433
去做几乎所有你想做的事情

1560
00:56:19,733 --> 00:56:20,466
用这些 API

1561
00:56:20,633 --> 00:56:21,433
R2DBC

1562
00:56:21,633 --> 00:56:22,866
现在已经可用了 你可以尝试

1563
00:56:22,866 --> 00:56:27,266
我们在大会上已经宣布了在华盛顿 DC

1564
00:56:27,533 --> 00:56:28,566
在 2018 年的时候

1565
00:56:28,566 --> 00:56:30,032
就是那时候我们向公众发布的

1566
00:56:30,033 --> 00:56:32,699
所以自我们发布到现在几乎有一年了 对吧

1567
00:56:32,700 --> 00:56:34,500
在此之前已经不止一年了

1568
00:56:34,500 --> 00:56:36,000
因为我们一直在开发它

1569
00:56:36,266 --> 00:56:38,699
我们知道它已经经过考验了 有经过迭代了的

1570
00:56:38,933 --> 00:56:40,099
而且它很有用

1571
00:56:40,100 --> 00:56:41,133
你总能从现今开始使用它

1572
00:56:41,133 --> 00:56:43,999
这就是我们已经做了的 当我在 start.spring.io

1573
00:56:44,000 --> 00:56:47,833
在那 Spring Initializr 我勾选了R2DBC这项

1574
00:56:48,133 --> 00:56:49,066
OK 所以我要在这里

1575
00:56:49,300 --> 00:56:52,033
将它放进来 放进这个

1576
00:56:52,933 --> 00:56:53,799
好东西

1577
00:56:54,033 --> 00:56:56,833
然后我要注释掉 MongoDB OK?

1578
00:56:57,533 --> 00:56:59,733
这会添加依赖 就这样

1579
00:57:01,766 --> 00:57:02,566
然后在这里添加这个

1580
00:57:02,633 --> 00:57:05,699
然后这里我们需要重构一下代码

1581
00:57:05,700 --> 00:57:07,266
还有 我不想建议

1582
00:57:07,766 --> 00:57:12,332
通过我的做法 我的说法 你应该按某种方式写代码

1583
00:57:12,333 --> 00:57:16,433
然后能够从 MongoDB 迁移到 R2DBC 没意义对吧

1584
00:57:16,566 --> 00:57:18,632
我的代码是非常简单

1585
00:57:19,266 --> 00:57:20,932
要让它能够跑起来

1586
00:57:21,200 --> 00:57:24,000
总的来说 如果你有场景发现 MongoDB 是最适合的话

1587
00:57:24,400 --> 00:57:30,233
可能那个应用场景不是 R2BC 或 SQL 适合的

1588
00:57:30,233 --> 00:57:31,766
或者等价的替换 好吧

1589
00:57:32,533 --> 00:57:36,266
嗯 额…… Spring Data 的目的

1590
00:57:36,266 --> 00:57:40,032
并不是支持这种奇葩的可移植性 OK？

1591
00:57:40,100 --> 00:57:41,266
所以我有这代码

1592
00:57:41,633 --> 00:57:42,766
移除 @Docuemt

1593
00:57:43,100 --> 00:57:45,333
额 我的实体 我的东西

1594
00:57:45,333 --> 00:57:46,099
我的记录

1595
00:57:46,233 --> 00:57:49,933
将会被存储在单调递增的主键

1596
00:57:49,933 --> 00:57:52,533
作为数据库中的主键

1597
00:57:52,533 --> 00:57:53,633
所以我将它从 String

1598
00:57:54,233 --> 00:57:55,366
也就是 UUID

1599
00:57:55,533 --> 00:57:57,799
支持 UUID 的改成 Integer 好吗

1600
00:57:58,000 --> 00:58:01,000
改完之后 我的代码又可以运行了

1601
00:58:01,000 --> 00:58:03,166
我们可以再次运行这个程序

1602
00:58:05,166 --> 00:58:05,666
就是这样

1603
00:58:11,233 --> 00:58:12,799
它抱怨了 因为我没有

1604
00:58:13,100 --> 00:58:15,666
一个指向我的数据库的属性

1605
00:58:15,833 --> 00:58:17,899
我要去到我的属性文件 application.properties

1606
00:58:18,266 --> 00:58:19,032
然后我要指定

1607
00:58:19,366 --> 00:58:20,866
r2dbc url 对吧

1608
00:58:20,866 --> 00:58:22,066
所以 r2dbc

1609
00:58:22,600 --> 00:58:23,033
url

1610
00:58:23,366 --> 00:58:23,832
而这是

1611
00:58:24,133 --> 00:58:26,499
这是我们之间的小秘密 OK 你不能告诉别人

1612
00:58:26,966 --> 00:58:28,599
这是我小小的生产环境的密码

1613
00:58:33,633 --> 00:58:34,566
OK 我们要

1614
00:58:35,133 --> 00:58:36,266
指定用户名

1615
00:58:36,533 --> 00:58:37,466
现在当然

1616
00:58:37,833 --> 00:58:40,399
你会被建议

1617
00:58:40,633 --> 00:58:42,699
记住你可以使用环境变量

1618
00:58:42,700 --> 00:58:45,133
你可以使用 Spring Cloud 配置服务器  

1619
00:58:45,466 --> 00:58:47,932
也可以用 Azure 配置服务器

1620
00:58:47,933 --> 00:58:50,633
你可以用很多方式外部化你的用户名和密码

1621
00:58:50,833 --> 00:58:51,566
但就我们演示目的

1622
00:58:51,866 --> 00:58:53,132
这应该可以用

1623
00:58:53,133 --> 00:58:53,999
让我们再次运行这个

1624
00:58:56,166 --> 00:58:56,466
OK

1625
00:58:56,866 --> 00:58:57,599
然后这是数据

1626
00:58:57,833 --> 00:58:59,633
在数据库你可以看到已经反映在那了

1627
00:58:59,966 --> 00:59:00,899
额 在控制台

1628
00:59:01,100 --> 00:59:02,433
在这里 我们单调递增地

1629
00:59:02,733 --> 00:59:05,099
增加主键也反映在数据库上

1630
00:59:05,300 --> 00:59:07,833
psql -Uorders orders

1631
00:59:09,700 --> 00:59:11,033
\d reservation 

1632
00:59:11,900 --> 00:59:13,233
然后可以看到那个模式

1633
00:59:13,500 --> 00:59:14,966
有个主键 是integer类型

1634
00:59:14,966 --> 00:59:16,932
然后有一个列称为 name 

1635
00:59:16,933 --> 00:59:17,766
类型为 varchar

1636
00:59:17,966 --> 00:59:19,766
我可以敲入

1637
00:59:21,133 --> 00:59:21,599
来吧

1638
00:59:24,500 --> 00:59:25,200
好东西

1639
00:59:25,366 --> 00:59:26,732
OK 这也行得通

1640
00:59:27,066 --> 00:59:28,832
现在我们可以响应式地

1641
00:59:29,066 --> 00:59:33,066
我们响应式地写数据到 MongoDB 和 SQL 数据存储

1642
00:59:33,200 --> 00:59:34,066
那是好东西

1643
00:59:34,266 --> 00:59:36,332
下一个 人们经常问的问题是

1644
00:59:36,833 --> 00:59:38,799
你懂得 你说得很好听

1645
00:59:38,800 --> 00:59:41,633
但是我还是要保证我数据的完整性的

1646
00:59:41,633 --> 00:59:45,633
在此背后我有这些很好的数据存储

1647
00:59:45,633 --> 00:59:48,066
有些东西正如我期望那样运行

1648
00:59:48,066 --> 00:59:50,932
而在旧的方式却不能这样期望 例如

1649
00:59:51,133 --> 00:59:53,933
数据的原子性如何？

1650
00:59:53,933 --> 00:59:56,633
我如何保证当我往数据库写入十样东西

1651
00:59:56,633 --> 00:59:58,799
全部都写入或者全都不写入 对吧

1652
00:59:58,900 --> 01:00:00,633
这就是事务的应用场景

1653
01:00:01,233 --> 01:00:02,999
嗯 事务正如你们可能知道的

1654
01:00:03,166 --> 01:00:05,699
在传统的那个世界

1655
01:00:05,833 --> 01:00:08,433
我们基于 ThreadLocal 对吧？

1656
01:00:08,966 --> 01:00:10,432
你创建… 有代码

1657
01:00:10,700 --> 01:00:12,733
保存与当前线程相关联的 ThreadLocal

1658
01:00:13,000 --> 01:00:16,000
那个 ThreadLocal 存储你的事务的状态

1659
01:00:16,066 --> 01:00:17,599
当前正在进行的事务

1660
01:00:17,933 --> 01:00:18,666
而 ThreadLocal

1661
01:00:19,100 --> 01:00:20,900
在当前线程的任何地方都可以解决

1662
01:00:21,100 --> 01:00:21,866
你只需请求

1663
01:00:21,866 --> 01:00:22,532
通常只是

1664
01:00:22,766 --> 01:00:24,332
通常是某个东西

1665
01:00:24,500 --> 01:00:26,666
在框架里面 例如Spring 会为你做这事

1666
01:00:26,866 --> 01:00:28,932
它们一直追踪那个 ThreadLocal

1667
01:00:29,166 --> 01:00:31,466
并在线程结束的时候清除掉它

1668
01:00:31,866 --> 01:00:34,566
并在 ThreadLocal 安装当前事务

1669
01:00:34,733 --> 01:00:35,699
当一个新事务开始

1670
01:00:36,033 --> 01:00:37,066
那个机制

1671
01:00:37,233 --> 01:00:38,699
用于这方面很久了

1672
01:00:38,866 --> 01:00:41,799
而那个机制最终是被

1673
01:00:42,466 --> 01:00:44,332
PlatformTransactionManager 解决

1674
01:00:44,466 --> 01:00:46,332
这只是一个非常简单的接口

1675
01:00:46,333 --> 01:00:47,333
给你三个选项

1676
01:00:47,500 --> 01:00:49,566
给我一个事务 给我一个定义

1677
01:00:49,866 --> 01:00:51,732
提交事务或者回滚

1678
01:00:52,233 --> 01:00:53,533
这种抽象允许我们

1679
01:00:53,700 --> 01:00:55,866
可以抽象大部分不同的 API

1680
01:00:55,866 --> 01:00:57,266
很多不同的 API

1681
01:00:57,533 --> 01:01:01,233
都有它们自己相应的资源本地事务

1682
01:01:01,466 --> 01:01:04,532
问题是所有这些都假设 ThreadLocal

1683
01:01:04,766 --> 01:01:06,566
所有都基于一种概念

1684
01:01:06,766 --> 01:01:10,032
那会有一种存储机制附着在当前线程

1685
01:01:10,266 --> 01:01:12,632
我可以在往后任意时间解决它

1686
01:01:13,100 --> 01:01:16,166
那是非常不好的假设

1687
01:01:16,800 --> 01:01:18,100
尤其是在响应式的世界里

1688
01:01:18,600 --> 01:01:19,733
对吧 在响应式的世界里

1689
01:01:20,033 --> 01:01:21,866
我们不能保证

1690
01:01:22,100 --> 01:01:25,066
请求会从一个线程开始 并保持在那个线程

1691
01:01:25,366 --> 01:01:27,032
在整个事务的生命周期

1692
01:01:27,466 --> 01:01:28,232
所以 而是

1693
01:01:28,800 --> 01:01:29,900
我们需要其它东西

1694
01:01:29,900 --> 01:01:31,866
所以在 Spring 框架 5.2.x

1695
01:01:32,033 --> 01:01:33,866
那是刚刚发布的

1696
01:01:34,100 --> 01:01:35,633
我们正在使用的 已经 GA 了

1697
01:01:35,800 --> 01:01:37,000
在 Spring 5.2.x

1698
01:01:37,233 --> 01:01:39,833
我们发布了一个 ReactiveTransactionManager

1699
01:01:40,033 --> 01:01:41,333
所以就算这边的这个东西

1700
01:01:41,900 --> 01:01:44,066
而那个 ReactiveTransactionManager

1701
01:01:44,066 --> 01:01:45,999
也是继承于 TransactionManager 的

1702
01:01:46,166 --> 01:01:47,699
对吧 它们都只是标记性接口

1703
01:01:48,000 --> 01:01:49,333
额 它继承了那个接口

1704
01:01:49,900 --> 01:01:51,800
并且它有对应的响应式

1705
01:01:51,800 --> 01:01:54,300
就如你所见的在 PlatformTransactionManager里面的

1706
01:01:54,533 --> 01:01:56,499
包括给我一个当前的事务

1707
01:01:56,700 --> 01:01:57,866
或给我一个新的事务

1708
01:01:58,066 --> 01:01:59,532
提交事务还有回滚

1709
01:01:59,533 --> 01:02:02,066
OK? 这个ReactiveTransactionManager

1710
01:02:02,400 --> 01:02:04,933
允许我们做事务的包裹

1711
01:02:04,933 --> 01:02:06,599
以熟悉的方式

1712
01:02:06,600 --> 01:02:08,633
让我们创建一个 @service

1713
01:02:09,800 --> 01:02:11,866
在这里我们添加 ReservationService

1714
01:02:12,033 --> 01:02:15,399
而这个服务会让我们可以写数据到数据库里

1715
01:02:15,700 --> 01:02:18,800
给定的一系列的数据流的名字

1716
01:02:18,800 --> 01:02:21,433
这是变长参数的名字数组

1717
01:02:21,666 --> 01:02:22,866
所以为了这样做

1718
01:02:22,866 --> 01:02:25,566
我要注入我们的 ReservationRepository

1719
01:02:25,566 --> 01:02:26,466
正如往常一样

1720
01:02:26,766 --> 01:02:29,832
让它是 @RequireArgsConstructor 就会合成了

1721
01:02:30,000 --> 01:02:30,966
由 Lombok 合成

1722
01:02:30,966 --> 01:02:32,832
所以我想从那里获取数据

1723
01:02:32,833 --> 01:02:36,266
所以 Flux.fromArray...

1724
01:02:37,300 --> 01:02:37,533
OK?

1725
01:02:38,366 --> 01:02:39,866
这是我的 String 类型的发布者

1726
01:02:40,066 --> 01:02:41,166
我将取其中的每一个

1727
01:02:41,433 --> 01:02:43,766
我要 map 每个名字都 Reservation 里面

1728
01:02:43,766 --> 01:02:46,366
我们在创建某些方面我们之前就有了东西

1729
01:02:46,600 --> 01:02:48,566
这是一系列的已经 map 了的数据

1730
01:02:48,566 --> 01:02:51,766
我要写 对于它们每一个 我要 flatMap 每个记录

1731
01:02:52,266 --> 01:02:53,132
存入到数据库里面

1732
01:02:53,800 --> 01:02:55,066
这它传入进去

1733
01:02:55,666 --> 01:02:57,266
额 这会给我

1734
01:02:57,266 --> 01:02:58,899
我想要验证每一个

1735
01:02:58,900 --> 01:03:00,033
我想要写

1736
01:03:00,366 --> 01:03:02,332
reservatoin.doOnEach(...

1737
01:03:02,466 --> 01:03:03,532
OK 我写 doOnNext(...

1738
01:03:03,966 --> 01:03:05,432
所以对于每个reservation

1739
01:03:05,433 --> 01:03:06,999
我想要断言测试一下它

1740
01:03:07,233 --> 01:03:08,766
我想要判断它

1741
01:03:09,000 --> 01:03:11,300
每个记录都有一个有效的名字

1742
01:03:11,733 --> 01:03:13,599
给定一个reservation

1743
01:03:13,800 --> 01:03:15,000
返回 true 或 false

1744
01:03:15,300 --> 01:03:17,500
如果那个名字是由大写字母开始的

1745
01:03:17,733 --> 01:03:19,633
getName().charAt(...

1746
01:03:20,900 --> 01:03:22,633
0... 然后我要写

1747
01:03:22,766 --> 01:03:24,466
然后我断言判断它应该是

1748
01:03:24,633 --> 01:03:25,299
一个大写字母

1749
01:03:25,300 --> 01:03:26,600
如果不是的话 我想让它失败

1750
01:03:26,866 --> 01:03:28,299
测试

1751
01:03:28,566 --> 01:03:28,832
好吗

1752
01:03:29,100 --> 01:03:30,100
所以我们应该这样做

1753
01:03:30,666 --> 01:03:32,799
doOnNext(...

1754
01:03:36,500 --> 01:03:37,233
传入 r

1755
01:03:38,900 --> 01:03:39,433
然后

1756
01:03:40,166 --> 01:03:43,466
the name ... 

1757
01:03:49,800 --> 01:03:50,100
OK?

1758
01:03:50,800 --> 01:03:53,333
哇啦 这是我已更新了的管道

1759
01:03:54,233 --> 01:03:56,666
额 很明显你可以将这些都串联起来

1760
01:03:56,666 --> 01:03:58,932
就像我这样 我想做这样的事情

1761
01:03:59,300 --> 01:04:01,166
串联起来那样我更容易读

1762
01:04:01,633 --> 01:04:04,066
即使我想将它拆开看看正在发生什么事情

1763
01:04:05,600 --> 01:04:06,266
然后就是这样

1764
01:04:06,266 --> 01:04:06,999
这是已经更新的代码

1765
01:04:07,000 --> 01:04:09,633
现在我们有了一个管道基本上是跟之前一样的

1766
01:04:09,633 --> 01:04:10,399
问题是

1767
01:04:11,200 --> 01:04:12,166
我首先读入数据

1768
01:04:12,166 --> 01:04:14,866
然后再当且仅当这样我才做验证

1769
01:04:15,166 --> 01:04:16,332
更加重要的是

1770
01:04:16,600 --> 01:04:18,000
如果我写两个记录的话会怎样

1771
01:04:18,766 --> 01:04:20,432
或者是十个、五个 随意吧

1772
01:04:20,633 --> 01:04:22,433
然后第三个记录有个小写的名字

1773
01:04:22,800 --> 01:04:24,333
我真的想写入前面两个记录吗？

1774
01:04:25,033 --> 01:04:27,166
可能我更希望那是原子性的对吧

1775
01:04:27,300 --> 01:04:28,600
这取决于你 额是

1776
01:04:28,766 --> 01:04:30,199
风格选择问我我觉得 但是

1777
01:04:30,333 --> 01:04:32,733
让我们假设我真的想要原子性操作

1778
01:04:32,733 --> 01:04:34,299
我想要保证要么

1779
01:04:34,466 --> 01:04:35,699
全部名字都写入

1780
01:04:35,700 --> 01:04:36,633
或者全部都不写入

1781
01:04:36,833 --> 01:04:38,733
为了支持这个 我是用了

1782
01:04:38,733 --> 01:04:40,599
这个新的 ReactiveTransactionManager 支持

1783
01:04:40,600 --> 01:04:41,500
所以我能够创建一个

1784
01:04:41,500 --> 01:04:44,000
ReactiveTransactionManager 实例

1785
01:04:45,200 --> 01:04:46,200
像这样

1786
01:04:46,366 --> 01:04:47,199
然后这个需要

1787
01:04:47,666 --> 01:04:49,332
这里边有很多不同的实现 顺便说一下

1788
01:04:49,333 --> 01:04:52,066
我们有 ReactiveTransactionManager 的实现

1789
01:04:52,300 --> 01:04:54,600
在 在 额 R2DBC

1790
01:04:54,600 --> 01:04:55,866
给我也给 MongoDB 实现了

1791
01:04:56,066 --> 01:04:57,466
还有 Neo4J

1792
01:04:57,700 --> 01:05:00,066
对吧 我确信还有一些我忘记了的

1793
01:05:00,400 --> 01:05:01,300
至少目前有这些

1794
01:05:01,900 --> 01:05:03,933
return new ...

1795
01:05:04,100 --> 01:05:06,533
注入来自 R2DBC 的连接工厂

1796
01:05:06,833 --> 01:05:08,299
然后 我们想要

1797
01:05:08,600 --> 01:05:10,166
创建一个 TransactionalOperator

1798
01:05:10,333 --> 01:05:10,633
好吗

1799
01:05:11,000 --> 01:05:12,266
而这个 transactionalOperator

1800
01:05:12,766 --> 01:05:14,732
需要 ReactiveTransactionManager 才能干活

1801
01:05:15,866 --> 01:05:16,666
所以我们创建那个

1802
01:05:16,800 --> 01:05:17,800
然后 哇啦 OK？

1803
01:05:18,300 --> 01:05:19,600
所以这是我们的事务管理者

1804
01:05:20,000 --> 01:05:21,333
嗯 就是这些东西

1805
01:05:21,566 --> 01:05:22,066
现在

1806
01:05:22,800 --> 01:05:23,766
我想要做的是

1807
01:05:24,000 --> 01:05:25,766
是我想要使用那个 TransactionalOperator

1808
01:05:25,766 --> 01:05:26,599
例如 private final

1809
01:05:27,333 --> 01:05:28,366
TransactionalOperator

1810
01:05:29,366 --> 01:05:30,232
然后我会写

1811
01:05:31,266 --> 01:05:34,299
this.transactionalOperator...

1812
01:05:35,500 --> 01:05:37,133
然后我将整个管道

1813
01:05:37,366 --> 01:05:39,066
放到这个事务分区里边

1814
01:05:39,366 --> 01:05:40,432
使用这个 transactionalOperator

1815
01:05:40,433 --> 01:05:41,233
所以 再次

1816
01:05:41,566 --> 01:05:42,966
所有东西在 transactional 里边的

1817
01:05:43,200 --> 01:05:44,633
在里面的整个发布者

1818
01:05:45,066 --> 01:05:46,799
会在一个事务当中

1819
01:05:46,966 --> 01:05:48,699
不在这里边的不会在一个事务里 对吧

1820
01:05:48,700 --> 01:05:50,100
我可以用另一种方式

1821
01:05:50,666 --> 01:05:52,366
写 @EnableTransactionalManagament

1822
01:05:52,633 --> 01:05:54,099
对吧 然后只需要

1823
01:05:54,466 --> 01:05:55,532
只要返回的是一个发布者

1824
01:05:55,533 --> 01:05:57,266
我只需要用 @Transactional

1825
01:05:57,533 --> 01:05:59,033
在这个例子中 它们是一样效果的

1826
01:05:59,700 --> 01:06:00,766
TransactionalOperator

1827
01:06:00,766 --> 01:06:02,799
很好如果你想要更细粒度的事务控制

1828
01:06:02,800 --> 01:06:05,100
什么需要事务控制 而什么不需要

1829
01:06:05,666 --> 01:06:07,832
所以现在然我们重写这里的代码

1830
01:06:08,000 --> 01:06:09,433
使用那个支持事务的服务

1831
01:06:09,800 --> 01:06:13,033
这里 private final ...

1832
01:06:14,800 --> 01:06:15,066
好吗

1833
01:06:15,733 --> 01:06:16,299
然后

1834
01:06:16,800 --> 01:06:20,166
我要写 this.reservationService...

1835
01:06:21,166 --> 01:06:21,466
好吗

1836
01:06:22,133 --> 01:06:22,533
哇啦

1837
01:06:23,433 --> 01:06:25,699
这是我们的服务 这是我们要写入数据库的数据

1838
01:06:26,333 --> 01:06:26,733
额……

1839
01:06:27,200 --> 01:06:28,100
这会是支持事务的

1840
01:06:28,100 --> 01:06:29,566
所以我要写数据到数据库

1841
01:06:29,866 --> 01:06:30,432
支持事务地

1842
01:06:30,633 --> 01:06:32,666
但我要删除所有在那个事务之外的东西

1843
01:06:32,700 --> 01:06:33,933
然后我要读取数据

1844
01:06:33,933 --> 01:06:35,499
在事务之外

1845
01:06:35,900 --> 01:06:37,100
所以这个

1846
01:06:37,500 --> 01:06:41,100
这行可能会显示 0 或 10，我们不清楚 或者 8 实际上

1847
01:06:41,100 --> 01:06:42,500
这是我们有的 8 个记录

1848
01:06:42,500 --> 01:06:43,166
所以这只是

1849
01:06:43,833 --> 01:06:45,299
让我们将

1850
01:06:45,566 --> 01:06:48,032
Mark 的名字 暂时地 只是暂时地

1851
01:06:48,466 --> 01:06:50,166
我们会将 Mark 的名字改成小写

1852
01:06:50,700 --> 01:06:51,466
而他是

1853
01:06:51,633 --> 01:06:54,366
操作中的第三个记录 对吧

1854
01:06:55,233 --> 01:06:56,099
所以现在

1855
01:06:56,900 --> 01:06:58,533
让我们返回到数据库这边

1856
01:06:58,666 --> 01:07:01,366
delete from reservation

1857
01:07:01,866 --> 01:07:03,232
对吧 现在里边什么都没有了

1858
01:07:03,900 --> 01:07:04,300
OK？

1859
01:07:05,533 --> 01:07:06,833
现在再次运行这个代码

1860
01:07:16,600 --> 01:07:17,933
这些只是日志

1861
01:07:17,933 --> 01:07:20,399
反映了这里有异常

1862
01:07:20,400 --> 01:07:23,300
但是这个应用没事能运行

1863
01:07:23,900 --> 01:07:24,833
额 现在

1864
01:07:25,800 --> 01:07:27,300
数据库里什么都没有 OK？

1865
01:07:28,033 --> 01:07:28,999
如果我恢复这个

1866
01:07:30,033 --> 01:07:30,699
大写字母

1867
01:07:32,566 --> 01:07:33,499
我们会看到全部 8 个

1868
01:07:36,766 --> 01:07:37,966
噢 就是这些

1869
01:07:38,533 --> 01:07:40,333
所以这里有数据 我们事务地

1870
01:07:40,700 --> 01:07:41,733
写入数据到数据库

1871
01:07:41,733 --> 01:07:42,733
正如我们期望的那样

1872
01:07:42,933 --> 01:07:44,833
OK 顺便问下 你们有注意到

1873
01:07:45,500 --> 01:07:46,866
这需要更多时间编译吗

1874
01:07:47,233 --> 01:07:49,099
相对比应用启动运行时间而言

1875
01:07:49,566 --> 01:07:49,932
对吧

1876
01:07:50,300 --> 01:07:51,700
我们目前所做的好处是

1877
01:07:51,700 --> 01:07:52,900
这是非常快

1878
01:07:52,900 --> 01:07:53,566
对吧 那么

1879
01:07:53,766 --> 01:07:55,499
我的大多数运行时间 你可以看到

1880
01:07:55,866 --> 01:07:58,366
少到 0.9 秒左右

1881
01:07:58,866 --> 01:07:59,299
额 ……

1882
01:08:00,500 --> 01:08:03,133
这是有帮助的 顺便提一下 我还跑着 Chrome 呢

1883
01:08:04,333 --> 01:08:05,766
即便如此 我还能获得那样的速度

1884
01:08:05,766 --> 01:08:07,032
可以想象到在生产环境会是怎样吗

1885
01:08:07,300 --> 01:08:08,000
肯定会更加好

1886
01:08:08,833 --> 01:08:09,966
OK 那么现在

1887
01:08:10,666 --> 01:08:12,899
我有这个事务分区

1888
01:08:12,900 --> 01:08:14,533
我将数据写入到了数据库

1889
01:08:14,800 --> 01:08:15,266
额

1890
01:08:16,966 --> 01:08:19,232
我想是时候写一个 HTTP API 了

1891
01:08:19,233 --> 01:08:22,066
OK 下一件事就是写一个简单 HTTP 服务

1892
01:08:22,500 --> 01:08:23,933
我们写 @RestController

1893
01:08:23,933 --> 01:08:25,166
这是非常常见的东西

1894
01:08:25,400 --> 01:08:26,900
毫无疑问的肯定见过了 RestController

1895
01:08:26,900 --> 01:08:28,100
所以你可以写 Reservation...

1896
01:08:28,366 --> 01:08:29,899
ReservationController 就像这样

1897
01:08:30,433 --> 01:08:31,799
你可以在这里注入它

1898
01:08:31,800 --> 01:08:33,233
可以写 private final ...

1899
01:08:36,133 --> 01:08:36,599
OK ?

1900
01:08:36,733 --> 01:08:38,833
我将一个 我要将它添加为

1901
01:08:39,700 --> 01:08:41,866
构造器注入依赖 使用 @RequiredArgsConstructor

1902
01:08:44,533 --> 01:08:46,433
然后我创建一个简单端点

1903
01:08:49,466 --> 01:08:51,032
Reservation 的发布者

1904
01:08:51,366 --> 01:08:52,499
然后我要读取所有数据

1905
01:08:52,966 --> 01:08:54,166
我写 this...

1906
01:08:54,533 --> 01:08:56,166
reservationRepository.findAll(...

1907
01:08:56,600 --> 01:08:57,500
重启一下

1908
01:09:01,033 --> 01:09:02,633
运行了吗？ 是的 跑起来了

1909
01:09:03,266 --> 01:09:04,999
所以 localhost:8080/reservations

1910
01:09:05,233 --> 01:09:05,966
这是我们的数据

1911
01:09:06,233 --> 01:09:07,866
好吗 这啥牛逼的

1912
01:09:07,866 --> 01:09:09,732
你以前就见过了 一点都不牛逼

1913
01:09:09,966 --> 01:09:12,632
非常简单 只是一个 RestController 返回一个发布者

1914
01:09:12,766 --> 01:09:13,799
这是很重要的 所以

1915
01:09:14,000 --> 01:09:15,933
尽管这看起来像 Spring MVC

1916
01:09:15,933 --> 01:09:17,566
然后你可能会觉得熟悉

1917
01:09:17,566 --> 01:09:19,466
如果你使用 Spring MVC

1918
01:09:19,466 --> 01:09:21,566
这个并不是 Spring MVC

1919
01:09:21,566 --> 01:09:24,132
这里边没有 Servlet API 在 classpath

1920
01:09:24,133 --> 01:09:25,833
对吧 我甚至都没有使用 Servlet API

1921
01:09:26,200 --> 01:09:28,066
这是全新的 Reactive Web 运行时

1922
01:09:28,700 --> 01:09:29,766
基于 Netty 的

1923
01:09:30,300 --> 01:09:32,100
从底层开始构建起来支持我们这里想做的

1924
01:09:32,100 --> 01:09:33,133
好吗 所以

1925
01:09:33,266 --> 01:09:35,299
我们这里有响应式支持

1926
01:09:36,000 --> 01:09:37,133
而有些东西

1927
01:09:37,333 --> 01:09:39,399
表面上是非常相似的 例如那些注解

1928
01:09:39,400 --> 01:09:41,000
将会感觉非常熟悉

1929
01:09:41,000 --> 01:09:43,666
其中不同的是 我们实际上返回 额

1930
01:09:44,533 --> 01:09:45,233
发布者

1931
01:09:45,666 --> 01:09:47,766
Spring MVC 控制器的返回值

1932
01:09:47,766 --> 01:09:48,699
典型的是

1933
01:09:48,800 --> 01:09:52,133
用于构造会被客户端渲染的响应的东西

1934
01:09:52,400 --> 01:09:54,133
这个实际上不是这样做的 是吗？

1935
01:09:54,433 --> 01:09:56,466
这个它本身就是一个响应了

1936
01:09:56,466 --> 01:09:59,632
这是一个东西 WebFlux 这个框架

1937
01:09:59,966 --> 01:10:02,199
可以用来到达结果的东西

1938
01:10:02,766 --> 01:10:05,266
两者是不同的 它们之间的区别是很重要的

1939
01:10:05,533 --> 01:10:07,099
它给了一个我们可以用的

1940
01:10:07,100 --> 01:10:08,866
然后得到结果的结果

1941
01:10:09,066 --> 01:10:10,166
但不是同样的东西

1942
01:10:10,366 --> 01:10:11,766
所以这次进入到了问题

1943
01:10:12,133 --> 01:10:14,833
OK 如果我想要一些东西一直活着

1944
01:10:15,066 --> 01:10:19,599
在一个管道的生命周期之内一直存活着

1945
01:10:20,000 --> 01:10:20,733
我应该怎样做？

1946
01:10:21,633 --> 01:10:22,966
我如何附着某物

1947
01:10:23,233 --> 01:10:25,599
到生命周期超越这东西的

1948
01:10:25,600 --> 01:10:28,133
记住我们不能使用 ThreadLocal 对吧

1949
01:10:28,133 --> 01:10:29,733
ThreadLocal 现在用不了啦

1950
01:10:30,100 --> 01:10:32,933
你可以看到 我们解决了事务的问题

1951
01:10:32,933 --> 01:10:33,899
就在几分钟前

1952
01:10:34,233 --> 01:10:36,666
我们可以做的方式是 如果你想做的话

1953
01:10:37,033 --> 01:10:39,766
是我们可以访问一个称为 context 的东西

1954
01:10:40,000 --> 01:10:41,933
OK 你可以创建一个订阅者上下文

1955
01:10:42,266 --> 01:10:44,299
而 context 是在底层支持的

1956
01:10:44,633 --> 01:10:47,499
我们的能力取附着一个例如

1957
01:10:48,533 --> 01:10:51,366
额 事务附着到目前的管道

1958
01:10:51,366 --> 01:10:53,532
不管那个管道是在哪个线程执行的

1959
01:10:53,733 --> 01:10:55,899
这是一个可以支持我们做分布式跟踪的东西

1960
01:10:55,900 --> 01:11:00,000
去持续画出沿着不同线程的路线

1961
01:11:00,000 --> 01:11:01,766
那是可以允许我们做

1962
01:11:01,766 --> 01:11:03,199
安全扩散的

1963
01:11:03,200 --> 01:11:06,166
你可以在数个不同线程间传播认证信息

1964
01:11:06,400 --> 01:11:09,300
你可以创建一个与管道有关的上下文

1965
01:11:09,633 --> 01:11:10,899
就像这样

1966
01:11:10,900 --> 01:11:12,133
所以我在这里做的是

1967
01:11:12,133 --> 01:11:13,266
创建一个 context

1968
01:11:13,266 --> 01:11:14,599
以一个键和值

1969
01:11:15,300 --> 01:11:16,466
分别等于 a 和 b 的

1970
01:11:16,633 --> 01:11:17,033
对吧

1971
01:11:17,800 --> 01:11:19,200
它可以一直可见

1972
01:11:19,433 --> 01:11:22,199
在这个管道之中 我可以访问这个上下文

1973
01:11:22,533 --> 01:11:23,999
我的代码的任意地方 我可以写

1974
01:11:24,366 --> 01:11:25,032
doOn...

1975
01:11:25,900 --> 01:11:28,366
例如 ...Each...

1976
01:11:29,566 --> 01:11:31,632
然后我给个信号 从每个信号

1977
01:11:31,900 --> 01:11:33,566
我可以获取到当前的上下文

1978
01:11:33,900 --> 01:11:35,766
例如我可以打日志输出它

1979
01:11:35,766 --> 01:11:37,532
所以你自己可以做各种事情

1980
01:11:37,533 --> 01:11:39,533
你可以自己管理那种机制

1981
01:11:39,900 --> 01:11:41,766
但除此之外 这仍然是

1982
01:11:41,966 --> 01:11:43,999
一个 Spring MVC 风格的控制器而已

1983
01:11:44,300 --> 01:11:45,533
我喜欢这种风格

1984
01:11:45,533 --> 01:11:47,333
考虑到这只是一个简单的例子

1985
01:11:47,600 --> 01:11:49,000
我想要发起一个 HTTP GET 请求

1986
01:11:49,466 --> 01:11:51,432
然后想它返回 Reservation

1987
01:11:52,000 --> 01:11:54,500
就是这样而已 然而我一整个类和构造器

1988
01:11:54,800 --> 01:11:56,866
还有注解 方法之类的东西

1989
01:11:57,166 --> 01:11:58,732
只是为了支持那一个 HTTP 端点

1990
01:11:59,233 --> 01:12:02,099
额 你可能更喜欢这种替换的风格

1991
01:12:02,600 --> 01:12:04,433
称之为函数式响应式端点

1992
01:12:04,433 --> 01:12:06,433
在 Spring 5 及其后版本可用

1993
01:12:06,433 --> 01:12:08,733
所以我们支持它已经超过两年了

1994
01:12:08,733 --> 01:12:09,799
所以 routes

1995
01:12:10,933 --> 01:12:11,699
return ...

1996
01:12:16,200 --> 01:12:16,433
好吗

1997
01:12:17,400 --> 01:12:19,866
.GET(...

1998
01:12:26,000 --> 01:12:27,900
所以我正在做的是 我创建一个 Bean

1999
01:12:28,300 --> 01:12:29,066
在这个 Bean 里面

2000
01:12:29,400 --> 01:12:31,866
我定义一个函数式响应式路由

2001
01:12:32,266 --> 01:12:35,432
而我将它注入作为数据仓库的协作对象

2002
01:12:35,433 --> 01:12:37,533
我写 ...findAll(), Reservation.class...

2003
01:12:38,433 --> 01:12:39,366
然后 哇啦 OK？

2004
01:12:40,566 --> 01:12:41,266
就是这样子

2005
01:12:41,600 --> 01:12:42,733
我将使用 static import

2006
01:12:42,733 --> 01:12:44,633
然后这就是我整个 HTTP 端点

2007
01:12:44,933 --> 01:12:46,266
这只是一行 我说的是

2008
01:12:46,700 --> 01:12:48,700
让…… 当某人对/reservations 发起请求时

2009
01:12:49,066 --> 01:12:50,732
那么指派这个 Lambda 去干活

2010
01:12:51,033 --> 01:12:52,133
还有就是这是构建者方法

2011
01:12:52,133 --> 01:12:53,499
所以我实际上可以将这些串联起来

2012
01:12:53,500 --> 01:12:54,800
我可以做 .DELETE 我可以做... 

2013
01:12:55,133 --> 01:12:57,666
PUT 还有  POST 等所有这些东西

2014
01:12:57,666 --> 01:12:59,966
我可以编程地添加这些东西

2015
01:12:59,966 --> 01:13:01,432
我可以使用条件语句 while 循环之类 随意玩

2016
01:13:01,733 --> 01:13:03,133
去随意添加这些端点

2017
01:13:03,566 --> 01:13:05,899
所以 取决于你偏好的风格

2018
01:13:05,900 --> 01:13:07,466
但它们功能上来说是一样的

2019
01:13:07,466 --> 01:13:08,466
它们做的是同样的事情 OK？

2020
01:13:08,466 --> 01:13:10,332
所以让我们重新运行这个程序

2021
01:13:10,766 --> 01:13:12,032
然后看一下我们会得到什么

2022
01:13:13,200 --> 01:13:14,466
我？ 嗯 可以了

2023
01:13:15,066 --> 01:13:15,699
OK 就是这样

2024
01:13:16,100 --> 01:13:16,833
这就是数据

2025
01:13:17,133 --> 01:13:17,333
OK？

2026
01:13:17,666 --> 01:13:19,432
现在我们有了一个可用的响应式 HTTP 端点

2027
01:13:19,433 --> 01:13:20,633
我们有 额……

2028
01:13:21,233 --> 01:13:22,933
我们有 R2DBC

2029
01:13:22,933 --> 01:13:25,699
我们看到我们可以写 SQL 到数据库

2030
01:13:26,000 --> 01:13:28,900
额 当然这是一种非常常见的自然的事情

2031
01:13:28,900 --> 01:13:30,700
我们有这些非常……

2032
01:13:31,133 --> 01:13:31,666
额……

2033
01:13:32,033 --> 01:13:34,166
简单 易实现的用例对吧

2034
01:13:34,333 --> 01:13:36,133
我想写数据到 SQL 数据存储

2035
01:13:36,266 --> 01:13:38,166
然后我想从 HTTP 端点读取它们

2036
01:13:38,400 --> 01:13:39,300
然后问题当然是

2037
01:13:39,966 --> 01:13:40,399
那又怎样？

2038
01:13:41,200 --> 01:13:42,333
我以前就可以这样做了

2039
01:13:42,800 --> 01:13:46,366
我并不需要响应式去从数据库读取8个记录

2040
01:13:46,800 --> 01:13:48,533
然后将它暴露为 JSON 对吗？

2041
01:13:48,533 --> 01:13:51,899
这在以前做起来也不难 为什么今天我要这样做

2042
01:13:52,066 --> 01:13:52,799
这是个好问题

2043
01:13:52,933 --> 01:13:55,566
所以真实的用例 真实地使得

2044
01:13:55,766 --> 01:13:57,099
响应式编程如何迷人的

2045
01:13:57,300 --> 01:13:59,200
是它带来的能力和机遇

2046
01:13:59,500 --> 01:14:02,600
用于一些可能会独占线程的事情

2047
01:14:03,000 --> 01:14:03,700
那么有什么例子

2048
01:14:03,966 --> 01:14:05,199
什么会独占一个线程？

2049
01:14:05,200 --> 01:14:07,600
在一个典型的应用架构我们会怎么做？

2050
01:14:07,733 --> 01:14:08,933
可能会让一个线程一直开着

2051
01:14:08,933 --> 01:14:11,299
嗯 每当你需要客户端与服务器通信的时候

2052
01:14:11,300 --> 01:14:14,500
然后客户端想要活动地持续地更新

2053
01:14:14,966 --> 01:14:16,066
自是很自然的候选者

2054
01:14:16,300 --> 01:14:17,466
去让一个线程持续地打开

2055
01:14:17,633 --> 01:14:19,133
像服务端发送事件之类的

2056
01:14:19,466 --> 01:14:20,332
例如 WebSocket

2057
01:14:20,566 --> 01:14:24,199
然后这些协议支持的使用场景是什么？

2058
01:14:24,800 --> 01:14:27,266
它们支持的使用场景必须要

2059
01:14:27,833 --> 01:14:28,899
持续地更新 例如

2060
01:14:29,266 --> 01:14:31,932
聊天 presence 还有股票动态

2061
01:14:32,233 --> 01:14:35,366
这类型使用场景需要一直接入的

2062
01:14:35,533 --> 01:14:36,099
OK？

2063
01:14:36,666 --> 01:14:37,866
那么让我们创建

2064
01:14:38,966 --> 01:14:40,466
一个服务会产生

2065
01:14:40,766 --> 01:14:43,266
数据的一个永不停息的数据流

2066
01:14:43,433 --> 01:14:43,633
OK

2067
01:14:43,933 --> 01:14:45,299
我们将创建一个 WebSocket 端点

2068
01:14:45,666 --> 01:14:46,932
那会响应

2069
01:14:47,333 --> 01:14:51,966
一系列 WebSocket 数据流 一系列“问候”的数据流

2070
01:14:52,233 --> 01:14:55,066
当某如需要一个“问候”

2071
01:14:55,300 --> 01:14:57,633
给定一个“问候”请求， 我们将要

2072
01:14:58,000 --> 01:14:59,033
产生数据流

2073
01:14:59,233 --> 01:15:01,066
作为问候的响应 好吗

2074
01:15:04,033 --> 01:15:04,833
request

2075
01:15:05,933 --> 01:15:06,699
OK 然后

2076
01:15:07,100 --> 01:15:07,900
@service

2077
01:15:09,033 --> 01:15:10,066
将这个类型放到这里

2078
01:15:10,333 --> 01:15:10,833
class

2079
01:15:12,066 --> 01:15:12,999
将这个类型放到这里

2080
01:15:13,633 --> 01:15:13,899
这里

2081
01:15:15,733 --> 01:15:15,866
好

2082
01:15:16,500 --> 01:15:17,700
那个请求只是有

2083
01:15:17,700 --> 01:15:19,966
name 它的详细内容只是包含一个名字

2084
01:15:20,566 --> 01:15:21,899
然后响应会有

2085
01:15:22,266 --> 01:15:23,399
问候消息它本身

2086
01:15:23,566 --> 01:15:23,866
OK ?

2087
01:15:24,100 --> 01:15:25,266
现在当然是 @Data

2088
01:15:25,600 --> 01:15:26,233
哇 这是什么

2089
01:15:26,533 --> 01:15:26,866
@Data

2090
01:15:27,966 --> 01:15:30,032
@AllArgsConstructor @NoArgsConstructor 好东西

2091
01:15:31,700 --> 01:15:32,866
好东西 现在

2092
01:15:33,566 --> 01:15:34,666
我们要做的是

2093
01:15:34,666 --> 01:15:36,066
当某人请求一个“问候”

2094
01:15:36,066 --> 01:15:37,866
我们会返回一个不间断的数据流

2095
01:15:40,833 --> 01:15:42,466
new Greeting ... Request

2096
01:15:42,633 --> 01:15:43,599
额 不好意思 是 response

2097
01:15:45,433 --> 01:15:45,966
Hello

2098
01:15:53,166 --> 01:15:53,332
OK?

2099
01:15:53,633 --> 01:15:55,499
所以这将会是不间断的数据流

2100
01:15:55,800 --> 01:15:57,100
现在 那是一个不间断的数据流

2101
01:15:57,100 --> 01:15:58,400
让我们用这个替换它

2102
01:15:58,400 --> 01:15:59,433
然后用 Lambda 替代

2103
01:15:59,833 --> 01:16:01,533
然后我们也调用 delayElements...

2104
01:16:01,733 --> 01:16:02,099
我要写

2105
01:16:02,400 --> 01:16:04,700
我想要延迟它 1 秒

2106
01:16:04,700 --> 01:16:06,700
所以每一秒我都要产生一个新的值

2107
01:16:07,266 --> 01:16:07,566
现在

2108
01:16:08,200 --> 01:16:09,400
留意下我刚才做了什么

2109
01:16:10,433 --> 01:16:11,366
我引入了

2110
01:16:12,266 --> 01:16:13,699
一个永不间断的数据流

2111
01:16:13,700 --> 01:16:15,066
它将会产生新的响应

2112
01:16:15,366 --> 01:16:15,832
一直都会

2113
01:16:16,266 --> 01:16:18,066
那个数据流会

2114
01:16:18,066 --> 01:16:19,432
会很快地滚动下来很快占满控制台

2115
01:16:19,433 --> 01:16:20,333
我们不看看到终结的

2116
01:16:20,733 --> 01:16:24,199
所以我通过使用 delayElements 分散下结果

2117
01:16:24,500 --> 01:16:25,666
我可以这样

2118
01:16:25,666 --> 01:16:27,732
我可以在这里改变时间是因为

2119
01:16:28,066 --> 01:16:30,699
是因为在 Reactor 背后我们所做的一切

2120
01:16:30,866 --> 01:16:32,066
里边都有个调度器

2121
01:16:32,533 --> 01:16:33,733
通常你不会注意到它存在

2122
01:16:33,733 --> 01:16:34,833
你也不需要知道它存在

2123
01:16:35,033 --> 01:16:36,033
但它一直都在那里

2124
01:16:36,033 --> 01:16:36,599
那个调度器

2125
01:16:36,766 --> 01:16:38,099
就是允许我们控制

2126
01:16:38,266 --> 01:16:39,999
执行的动向

2127
01:16:40,200 --> 01:16:43,666
从一个线程无缝的切换到另一个线程

2128
01:16:43,833 --> 01:16:44,699
你不需要担忧这个

2129
01:16:45,166 --> 01:16:46,266
调度器

2130
01:16:46,500 --> 01:16:47,233
处理两件事

2131
01:16:47,233 --> 01:16:48,399
处理调度任务

2132
01:16:48,666 --> 01:16:49,932
然后它处理多线程

2133
01:16:49,933 --> 01:16:51,399
它实际... 它有点像个线程池

2134
01:16:51,700 --> 01:16:52,700
加上一个定时器 你可以这样想

2135
01:16:52,833 --> 01:16:53,499
OK ?

2136
01:16:53,566 --> 01:16:56,199
额 这是我们放进 Reactor 里的抽象

2137
01:16:56,433 --> 01:16:57,833
通常你不需要担忧这个

2138
01:16:57,833 --> 01:16:58,533
但是默认情况下

2139
01:16:58,733 --> 01:17:00,699
一个线程占一个 CUP 核

2140
01:17:01,166 --> 01:17:01,499
好吗？

2141
01:17:01,733 --> 01:17:02,866
所以你有每个线程一个核

2142
01:17:03,066 --> 01:17:04,166
在默认的应用程序

2143
01:17:04,500 --> 01:17:05,066
这意味着

2144
01:17:05,900 --> 01:17:06,533
如果你是

2145
01:17:07,033 --> 01:17:08,066
在一个机器

2146
01:17:08,066 --> 01:17:09,899
你只有四个核 那你就只有四个线程

2147
01:17:10,100 --> 01:17:11,600
所以非常重要

2148
01:17:11,733 --> 01:17:13,366
你不阻塞这些线程

2149
01:17:13,733 --> 01:17:14,833
如果你使用响应式代码

2150
01:17:15,033 --> 01:17:15,766
那么你不能阻塞

2151
01:17:16,233 --> 01:17:16,399
对吧

2152
01:17:16,766 --> 01:17:18,332
额 在这里你有调度器

2153
01:17:18,666 --> 01:17:19,866
如果你觉得需要的话

2154
01:17:20,133 --> 01:17:21,333
如果你需要重写调度器的话

2155
01:17:21,333 --> 01:17:22,466
如果你需要做一些事

2156
01:17:22,766 --> 01:17:24,132
那会阻塞的话

2157
01:17:24,133 --> 01:17:24,966
非常重要的是

2158
01:17:25,066 --> 01:17:26,032
你处理好

2159
01:17:26,533 --> 01:17:27,499
额

2160
01:17:28,266 --> 01:17:29,132
将那个任务

2161
01:17:29,466 --> 01:17:30,832
放到一个不同的调度器

2162
01:17:30,833 --> 01:17:31,899
所以 Schedulers...

2163
01:17:32,166 --> 01:17:33,066
额…… elastic() ...

2164
01:17:33,133 --> 01:17:34,599
或者是 fromExecutor(...

2165
01:17:34,600 --> 01:17:35,733
你懂得像这样

2166
01:17:35,733 --> 01:17:36,633
你提供你自己的 Executors

2167
01:17:37,000 --> 01:17:37,666
随你所想 对吧

2168
01:17:37,900 --> 01:17:39,300
很重要的是

2169
01:17:39,300 --> 01:17:41,166
你要处理好重写调度器

2170
01:17:41,400 --> 01:17:42,666
那某个管道的使用

2171
01:17:42,900 --> 01:17:45,833
要么 subscribeOn 或者是 publishOn 对吧

2172
01:17:46,266 --> 01:17:47,399
我通常使用 subscribeOn

2173
01:17:47,400 --> 01:17:50,000
但如果你有一个生产者它会

2174
01:17:50,233 --> 01:17:53,033
如果你有消费者比生产者更慢的话

2175
01:17:53,166 --> 01:17:54,199
你可以使用 publishOn 对吧

2176
01:17:55,166 --> 01:17:57,132
嗯 喔 这是

2177
01:17:58,000 --> 01:17:59,366
这被认为是代码臭味

2178
01:17:59,366 --> 01:18:00,466
我认为那会是代码臭味

2179
01:18:00,466 --> 01:18:02,199
如果你发现要经常这样做

2180
01:18:02,533 --> 01:18:04,633
如果你有代码在你的代码库里是阻塞的

2181
01:18:04,633 --> 01:18:06,199
与阻塞资源之间的交互

2182
01:18:06,633 --> 01:18:08,233
然后你要扩展开那个交互

2183
01:18:08,566 --> 01:18:09,732
通过添加更多线程的办法

2184
01:18:10,000 --> 01:18:11,066
这样是

2185
01:18:11,066 --> 01:18:11,899
我们尝试使用

2186
01:18:12,133 --> 01:18:13,299
响应式编程的初衷

2187
01:18:13,600 --> 01:18:14,800
我们想要的是

2188
01:18:15,066 --> 01:18:16,166
你懂得 不阻塞

2189
01:18:16,233 --> 01:18:18,133
我们想从中获益的

2190
01:18:18,333 --> 01:18:20,499
是在系统高效地复用线程

2191
01:18:20,833 --> 01:18:23,099
如果你只能通过增加线程扩展的话

2192
01:18:23,466 --> 01:18:24,232
有的问题了

2193
01:18:24,633 --> 01:18:26,299
你应该能找到那个代码

2194
01:18:26,533 --> 01:18:27,599
而且一点点

2195
01:18:27,866 --> 01:18:29,732
隔绝并从你的代码中移除

2196
01:18:30,066 --> 01:18:31,732
为帮助你做这样的事情

2197
01:18:32,100 --> 01:18:33,700
我们创建了称为 blockhound 的东西

2198
01:18:34,133 --> 01:18:35,899
是一个 Java 代理

2199
01:18:35,900 --> 01:18:37,300
你可以用它来检测

2200
01:18:37,433 --> 01:18:39,166
不阻塞线程的阻塞调用

2201
01:18:39,366 --> 01:18:40,599
你只需将它添加到 classpath

2202
01:18:41,033 --> 01:18:43,399
然后只需运行 BlockHound.install()

2203
01:18:43,700 --> 01:18:44,900
在你的 public static void main(... 方法里

2204
01:18:45,133 --> 01:18:46,433
在你启动 Spring Boot 之前

2205
01:18:46,666 --> 01:18:46,999
OK ？

2206
01:18:47,500 --> 01:18:47,833
额

2207
01:18:48,666 --> 01:18:50,466
这样做了之后

2208
01:18:50,466 --> 01:18:52,199
如果你干些傻事 例如 Thread.sleep() 或计算斐波那契数列

2209
01:18:52,400 --> 01:18:53,533
不管什么 额

2210
01:18:53,833 --> 01:18:55,066
你会得到这个阻塞的调用

2211
01:18:55,566 --> 01:18:56,666
对吧 这个阻塞的异常

2212
01:18:57,166 --> 01:18:59,766
它会抛出异常 帮助你知道那里有错误

2213
01:19:00,533 --> 01:19:00,999
就那么简单

2214
01:19:01,600 --> 01:19:02,900
然后你可以好好调试或者

2215
01:19:03,133 --> 01:19:04,699
将其隔离，或者至少处理好

2216
01:19:04,966 --> 01:19:06,132
将它放到它自己的调度器

2217
01:19:06,300 --> 01:19:08,366
这响应式的世界里这要做很重要

2218
01:19:08,566 --> 01:19:11,766
请记住 如果你有四个核心 你有四个线程

2219
01:19:11,966 --> 01:19:13,199
如果你阻塞了其中一个线程

2220
01:19:13,400 --> 01:19:14,766
那不只是一个请求

2221
01:19:14,766 --> 01:19:16,499
那是你 25% 的用户

2222
01:19:17,100 --> 01:19:18,733
对吧 你通常可能使用 PHP

2223
01:19:18,733 --> 01:19:20,466
去解决那样的问题 不 不要那样做

2224
01:19:20,800 --> 01:19:21,400
做正确的事情

2225
01:19:21,633 --> 01:19:22,866
OK ? 那么

2226
01:19:23,633 --> 01:19:24,933
我们有一个调度器

2227
01:19:25,600 --> 01:19:26,766
你可以使用它 如果你想的话

2228
01:19:27,100 --> 01:19:27,800
那个调度器

2229
01:19:28,400 --> 01:19:29,833
是一个允许我们

2230
01:19:30,533 --> 01:19:31,433
像这样做事情

2231
01:19:31,433 --> 01:19:32,799
我们可以增加时间

2232
01:19:33,000 --> 01:19:35,100
时间是我们的 API 的一个维度

2233
01:19:35,100 --> 01:19:37,400
这是响应式编程的一种好处

2234
01:19:37,400 --> 01:19:38,500
我们现在可以想象世界

2235
01:19:38,766 --> 01:19:42,199
真的作为一系列的时间  时间里一系列的事件

2236
01:19:42,733 --> 01:19:43,799
那么现在我们那样做了

2237
01:19:43,800 --> 01:19:44,966
让我们创建一个请求

2238
01:19:45,533 --> 01:19:46,633
额 WebSocket

2239
01:19:47,966 --> 01:19:48,866
端点 OK？

2240
01:19:49,033 --> 01:19:52,599
Websocket ...

2241
01:19:52,700 --> 01:19:54,200
好吧 ...Configuration

2242
01:19:54,666 --> 01:19:56,532
然后我们会在这创建一些 Beans

2243
01:19:56,766 --> 01:19:58,332
那个 WebSOcketHandleerAdapter

2244
01:19:58,900 --> 01:20:00,433
这是一个东西

2245
01:20:01,100 --> 01:20:01,833
我们需要

2246
01:20:02,400 --> 01:20:03,866
去告诉 Spring

2247
01:20:03,966 --> 01:20:06,266
去查找 WebSocket 支持 对吧

2248
01:20:06,566 --> 01:20:08,232
我们需要那个 WebSocketHandler 本身

2249
01:20:09,100 --> 01:20:10,500
然后这里边是我们的业务逻辑

2250
01:20:10,500 --> 01:20:12,000
等会我们再回头看看这个

2251
01:20:12,000 --> 01:20:14,133
这个是业务逻辑

2252
01:20:14,433 --> 01:20:16,033
然后我们实际上需要告诉

2253
01:20:16,333 --> 01:20:18,633
Spring 去装载我们的

2254
01:20:18,833 --> 01:20:19,833
WebSocket 端点

2255
01:20:20,200 --> 01:20:21,366
到一个 HTTP URL

2256
01:20:21,366 --> 01:20:22,366
我们需要这样做的原因是

2257
01:20:22,766 --> 01:20:24,666
额 WebSocket

2258
01:20:24,666 --> 01:20:25,766
是一个二进制协议

2259
01:20:26,200 --> 01:20:28,566
但当 WebSocket 客户端连接到服务器的时候

2260
01:20:29,166 --> 01:20:30,232
它会升级

2261
01:20:30,833 --> 01:20:31,899
到二进制协议

2262
01:20:31,900 --> 01:20:32,966
所以它先是连接到 HTTP

2263
01:20:33,300 --> 01:20:34,766
然后有握手 接着协议升级

2264
01:20:35,033 --> 01:20:35,999
我们需要告诉框架

2265
01:20:36,300 --> 01:20:37,966
嘿 映射这个端点

2266
01:20:38,866 --> 01:20:39,832
这个 HTTP 端点

2267
01:20:40,500 --> 01:20:41,800
到这个二进制协议

2268
01:20:41,866 --> 01:20:43,632
OK? 所以我要写 Map.of...

2269
01:20:44,233 --> 01:20:45,299
/ws/greetings

2270
01:20:46,333 --> 01:20:48,666
然后我要给它一个引用到 WebSocketHandler

2271
01:20:49,233 --> 01:20:50,566
它会延迟操作 对吧

2272
01:20:51,233 --> 01:20:51,799
我要给...

2273
01:20:52,233 --> 01:20:53,733
我要给这个特定的 URL

2274
01:20:53,933 --> 01:20:55,299
一个排序 只是为了确保它

2275
01:20:55,633 --> 01:20:56,999
确保它排在其它 URL 之前

2276
01:20:57,633 --> 01:20:58,366
OK 那么现在

2277
01:20:59,233 --> 01:21:00,466
这是我的 WebSocketHandler

2278
01:21:00,633 --> 01:21:02,433
这是业务逻辑所在的地方

2279
01:21:02,766 --> 01:21:04,732
条约很简单 当请求进来的时候

2280
01:21:05,166 --> 01:21:08,332
我们获得一个指向当前 WebSocket Session 的指针

2281
01:21:08,733 --> 01:21:10,733
而正是在那个 WebSocket Session 我们才可以

2282
01:21:11,100 --> 01:21:12,033
做一些像

2283
01:21:12,300 --> 01:21:13,566
询问传入的数据

2284
01:21:13,900 --> 01:21:15,100
那么什么是传入的数据

2285
01:21:15,200 --> 01:21:15,866
在这个例子当中

2286
01:21:16,133 --> 01:21:18,066
那将会是一个“问候”请求

2287
01:21:18,066 --> 01:21:19,232
将会是 String 类型的 name

2288
01:21:19,533 --> 01:21:20,899
我们可以将它变成一个问候请求

2289
01:21:21,200 --> 01:21:23,600
然后调用服务得到一系列的响应

2290
01:21:23,900 --> 01:21:25,466
再发送回给 WebSocket 客户端

2291
01:21:25,866 --> 01:21:26,499
所以我们将会说 嘿

2292
01:21:27,066 --> 01:21:28,032
给我们一个数据流

2293
01:21:28,333 --> 01:21:29,666
的 WebSocket 消息

2294
01:21:29,966 --> 01:21:31,866
接收当中的每一个

2295
01:21:33,033 --> 01:21:34,666
就像这样 获取载荷作为文本

2296
01:21:35,466 --> 01:21:35,932
就像这样

2297
01:21:36,266 --> 01:21:37,066
map 这里边的文本

2298
01:21:37,066 --> 01:21:38,366
这些是名字

2299
01:21:38,366 --> 01:21:40,299
实际情况只是会有一个名字

2300
01:21:40,300 --> 01:21:41,700
你知道的我们这里有个发布者

2301
01:21:42,500 --> 01:21:43,833
map 每一个名字

2302
01:21:44,200 --> 01:21:45,833
到 GreetingRequest

2303
01:21:45,833 --> 01:21:46,499
就像这样

2304
01:21:47,766 --> 01:21:47,999
OK

2305
01:21:50,466 --> 01:21:51,699
greetingRequestFlux

2306
01:21:51,966 --> 01:21:53,099
然后将当中的每一个

2307
01:21:53,300 --> 01:21:56,400
然后我们会将它变成对服务的一个调用

2308
01:21:56,733 --> 01:21:59,566
然后我们注入刚刚创建的“问候服务”到这里

2309
01:22:00,566 --> 01:22:01,632
就像这样 gs

2310
01:22:04,233 --> 01:22:05,299
.greet( gr ...

2311
01:22:06,266 --> 01:22:06,866
然后我们将要

2312
01:22:07,533 --> 01:22:08,666
创建一个“问候响应”

2313
01:22:08,900 --> 01:22:10,100
现在对于其中每一个响应

2314
01:22:10,333 --> 01:22:11,866
我想要将它转换成 WebSocket 消息

2315
01:22:11,866 --> 01:22:13,632
我可以返回给客户端

2316
01:22:13,633 --> 01:22:14,699
我们将要写

2317
01:22:14,700 --> 01:22:17,233
receive... 额 我们要写 greetingResponseFlux...

2318
01:22:22,733 --> 01:22:23,399
OK？这些是

2319
01:22:23,533 --> 01:22:24,633
String 类型的名字

2320
01:22:24,866 --> 01:22:26,132
我要将它变成

2321
01:22:26,466 --> 01:22:27,532
WebSocket 的消息

2322
01:22:27,533 --> 01:22:28,466
通过写 txt...

2323
01:22:31,900 --> 01:22:32,433
将它变成这样

2324
01:22:33,366 --> 01:22:35,166
这是我的 WebSocket 信息数据流

2325
01:22:35,500 --> 01:22:37,333
我只需要写 session.send(...

2326
01:22:37,666 --> 01:22:38,432
map1

2327
01:22:38,866 --> 01:22:39,799
这就是整个管道

2328
01:22:40,100 --> 01:22:40,633
很显然

2329
01:22:41,333 --> 01:22:42,866
我不想让它这样子

2330
01:22:43,533 --> 01:22:44,799
折叠起来成为一个

2331
01:22:45,066 --> 01:22:47,232
容易理解的数据流

2332
01:22:50,566 --> 01:22:50,832
OK

2333
01:22:52,666 --> 01:22:53,199
所以你可以看到

2334
01:22:53,566 --> 01:22:54,899
默认情况下我使用 map

2335
01:22:54,900 --> 01:22:57,066
除非我有其它东西会产生一个发布者

2336
01:22:57,066 --> 01:22:58,099
那样的话我会使用flatMap

2337
01:22:58,633 --> 01:22:59,433
额 还有

2338
01:23:00,033 --> 01:23:01,833
就是这样 这就是整个序列

2339
01:23:02,433 --> 01:23:03,133
所以 receive

2340
01:23:03,433 --> 01:23:04,866
当然这整个接口

2341
01:23:05,366 --> 01:23:06,666
时函数式接口 所以

2342
01:23:07,133 --> 01:23:08,166
这是它的 lambda 形式

2343
01:23:08,533 --> 01:23:08,733
OK?

2344
01:23:09,233 --> 01:23:09,733
现在

2345
01:23:10,200 --> 01:23:11,366
我有一个 WebSocketHandler

2346
01:23:11,366 --> 01:23:13,799
这是一个 Bean 我在配置类里边配置的

2347
01:23:14,100 --> 01:23:15,166
这是一个 WebSocket 端点

2348
01:23:15,400 --> 01:23:16,333
这东西能用

2349
01:23:16,566 --> 01:23:18,199
但我想 我要给你们演示这个

2350
01:23:18,766 --> 01:23:20,032
现在我的朋友们 我有点

2351
01:23:20,366 --> 01:23:21,032
有点尴尬

2352
01:23:21,600 --> 01:23:22,600
我们这边有点问题

2353
01:23:23,066 --> 01:23:23,799
不幸的是

2354
01:23:24,166 --> 01:23:25,599
我要给你们演示这个

2355
01:23:25,800 --> 01:23:28,166
然而我想不到做这事的更加优雅的方式了

2356
01:23:28,166 --> 01:23:30,932
我想不到一个好的方式去做我想做的事情

2357
01:23:31,166 --> 01:23:32,766
但我必须做这件事 为了做这件事

2358
01:23:32,766 --> 01:23:34,866
额…… 我会觉得不自在

2359
01:23:35,100 --> 01:23:36,800
对吧 我们是朋友啊 我觉得……

2360
01:23:37,866 --> 01:23:40,232
这会破坏我们之间的信任如果我这样做

2361
01:23:40,233 --> 01:23:41,533
但我想不到更好的方式了

2362
01:23:41,800 --> 01:23:44,300
而我通常不会在体面的公司里做这样的事情

2363
01:23:44,400 --> 01:23:47,400
OK 如果我能避免的话 如果我可以找到其它方式

2364
01:23:47,700 --> 01:23:48,800
去做我想做的事

2365
01:23:49,033 --> 01:23:50,799
那么当然我会

2366
01:23:52,066 --> 01:23:54,066
哎…… 我要写 JavaScript

2367
01:24:00,466 --> 01:24:00,666
OK？

2368
01:24:04,833 --> 01:24:05,433
好 那么

2369
01:24:05,866 --> 01:24:07,166
window.addEventListener...

2370
01:24:11,666 --> 01:24:12,432
OK 这些代码

2371
01:24:22,500 --> 01:24:22,733
OK

2372
01:24:23,066 --> 01:24:24,799
不好意思 是 ... ws/greetings ...

2373
01:24:29,633 --> 01:24:30,433
对吧 就是这样

2374
01:24:32,266 --> 01:24:35,199
然后 当 Socket 打开的时候

2375
01:24:36,133 --> 01:24:37,933
然后我可以开始跟它交互了

2376
01:24:38,633 --> 01:24:39,533
我要做的是

2377
01:24:39,533 --> 01:24:40,466
我要获取 Socket

2378
01:24:40,466 --> 01:24:41,332
我要发送请求

2379
01:24:41,333 --> 01:24:41,999
我只是写

2380
01:24:42,366 --> 01:24:42,966
Devoxx

2381
01:24:44,300 --> 01:24:44,866
Belgium OK?

2382
01:24:46,633 --> 01:24:46,833
好了吗？

2383
01:24:47,600 --> 01:24:48,033
然后

2384
01:24:48,333 --> 01:24:49,366
当数据进来的时候

2385
01:24:49,766 --> 01:24:51,799
我要加载这些资源

2386
01:24:51,800 --> 01:24:53,900
所以我要构造请求 这是我们要发送的名字

2387
01:24:54,200 --> 01:24:56,600
实际上我们不需要在 Belgium 后加叹号

2388
01:24:56,866 --> 01:24:58,499
当那个消息返回的时候

2389
01:24:58,933 --> 01:25:01,033
我们有 onMessage 回调 所以写 function ...

2390
01:25:02,133 --> 01:25:03,933
... msg ... 我将结果打印到这里

2391
01:25:04,033 --> 01:25:05,466
所以 console.log(...

2392
01:25:11,500 --> 01:25:12,266
然后我们重启应用

2393
01:25:22,166 --> 01:25:22,399
OK

2394
01:25:25,200 --> 01:25:26,000
噢 是这个

2395
01:25:28,300 --> 01:25:29,100
就是这样我的朋友们

2396
01:25:30,700 --> 01:25:31,300
每一秒钟

2397
01:25:32,733 --> 01:25:34,266
至往后无限

2398
01:25:35,466 --> 01:25:36,699
它会产生新的结果

2399
01:25:38,033 --> 01:25:42,233
它会一直有…… 继续有…… 有……

2400
01:25:42,933 --> 01:25:43,599
永远

2401
01:25:44,333 --> 01:25:47,566
直到永远…… 永远…… 永远……

2402
01:25:49,200 --> 01:25:50,266
它不会结束的

2403
01:25:51,033 --> 01:25:51,966
它是无终结的

2404
01:25:54,133 --> 01:25:54,999
就像海洋……

2405
01:25:56,766 --> 01:25:57,932
亦如星空……

2406
01:25:59,433 --> 01:26:00,933
还有你代码中的 bug

2407
01:26:01,266 --> 01:26:01,732
无穷的

2408
01:26:02,400 --> 01:26:03,233
无尽的 我们朋友们

2409
01:26:04,566 --> 01:26:05,366
那没关系

2410
01:26:06,200 --> 01:26:07,500
好吗 那没关系 因为

2411
01:26:07,766 --> 01:26:08,632
我们要做的是

2412
01:26:09,000 --> 01:26:10,500
是在雨滴之间

2413
01:26:10,700 --> 01:26:12,966
在这些消息发送给客户端的过程

2414
01:26:13,166 --> 01:26:14,632
那个线程释放了

2415
01:26:15,666 --> 01:26:18,466
某物 某人在系统中之后可以使用那个线程

2416
01:26:18,700 --> 01:26:19,466
去做更多的事情

2417
01:26:19,800 --> 01:26:21,200
这是真正的好处

2418
01:26:21,200 --> 01:26:23,166
响应式编程带来的进步

2419
01:26:23,300 --> 01:26:26,100
并不是我们让每个事务更加快

2420
01:26:26,366 --> 01:26:27,932
是我们这样做所以

2421
01:26:27,933 --> 01:26:30,233
处理更加多的事务

2422
01:26:31,033 --> 01:26:32,133
这就是真正的胜利

2423
01:26:32,633 --> 01:26:34,499
对吧 做个简单的计算

2424
01:26:34,500 --> 01:26:37,800
这个完全算不上是真实的性能测试

2425
01:26:37,800 --> 01:26:39,000
但在这里使用简单数字做例子

2426
01:26:39,233 --> 01:26:41,099
这里的目标是用一半的硬件成本去处理

2427
01:26:41,100 --> 01:26:43,833
同样多的事务

2428
01:26:44,500 --> 01:26:44,700
对吧

2429
01:26:45,033 --> 01:26:45,766
或者去处理

2430
01:26:46,133 --> 01:26:48,166
一半…… 额一样数量的事务

2431
01:26:48,566 --> 01:26:49,866
或者是两倍数量的事务

2432
01:26:50,033 --> 01:26:50,799
以同样的硬件

2433
01:26:51,500 --> 01:26:51,766
对吧

2434
01:26:51,933 --> 01:26:55,466
那并不是要使得每个特定的事务更加快

2435
01:26:55,700 --> 01:26:57,000
记得吗 因为线程切换

2436
01:26:57,200 --> 01:26:59,100
那可能会更慢一点

2437
01:27:00,300 --> 01:27:02,633
但目标是你可以用同样的硬件做得更多

2438
01:27:03,033 --> 01:27:05,199
你更高效地使用了这个系统

2439
01:27:06,000 --> 01:27:08,800
所以我的朋友们 我们已经看了如何构建一个服务

2440
01:27:08,800 --> 01:27:10,766
在这边谈论了一些不同的东西

2441
01:27:10,766 --> 01:27:11,699
我们构建了一个简单服务

2442
01:27:12,000 --> 01:27:13,400
在下一节

2443
01:27:13,833 --> 01:27:17,099
我们会讲构建一个客户端

2444
01:27:17,100 --> 01:27:19,566
那将会带我们进入到恐怖的微服务

2445
01:27:19,566 --> 01:27:22,899
当你有一个服务于另一个服务通信的时候会发生什么

2446
01:27:22,900 --> 01:27:27,433
在那一节我们会讨论像网关 HTTP 适配器 网关之类的

2447
01:27:27,466 --> 01:27:31,299
API 适配器 HTTP 客户端 你懂的

2448
01:27:31,300 --> 01:27:32,766
我们会用 kotlin 写

2449
01:27:32,766 --> 01:27:35,599
那会是在第二节

2450
01:27:36,066 --> 01:27:38,666
现在是生理休息期啦

2451
01:27:38,666 --> 01:27:41,032
你自身的一些 IO

2452
01:27:41,633 --> 01:27:44,833
额 去喝杯咖啡 喝杯茶

2453
01:27:44,833 --> 01:27:46,766
我很感谢你们 谁目前玩得开心？

2454
01:27:48,900 --> 01:27:50,966
只是确认一下 OK

2455
01:27:51,766 --> 01:27:52,366
好东西

2456
01:27:52,733 --> 01:27:53,966
我要在相机使用夜间模式

2457
01:27:55,000 --> 01:27:55,766
好东西

2458
01:27:56,666 --> 01:28:00,799
OK 我的朋友们 大概十分钟或十五分钟后再见

2459
01:28:01,633 --> 01:28:02,166
15 分钟后？

2460
01:28:02,500 --> 01:28:04,866
OK 好的 我们有 额 现在几点？

2461
01:28:05,500 --> 01:28:06,766
十点多…… 现在是十一点

2462
01:28:07,233 --> 01:28:10,266
所以 11点15分 回到你的座位上

2463
01:28:18,900 --> 01:28:19,833
好了

2464
01:28:20,100 --> 01:28:21,433
好东西 欢迎回来

2465
01:28:21,833 --> 01:28:24,466
那么 我刚才遇到一点问题

2466
01:28:24,833 --> 01:28:27,299
我去找杯咖啡

2467
01:28:27,300 --> 01:28:31,300
跟大家一样 额 那边有个人在门口

2468
01:28:31,833 --> 01:28:33,266
你的胸牌在哪里？

2469
01:28:34,166 --> 01:28:36,199
噢…… 我的胸牌在这边……

2470
01:28:36,900 --> 01:28:39,066
但我当时没有带 所以……

2471
01:28:39,600 --> 01:28:40,900
我差点回不来了

2472
01:28:41,133 --> 01:28:44,966
他非常坚持不让我回来

2473
01:28:45,200 --> 01:28:47,166
啊…… 所以……

2474
01:28:47,166 --> 01:28:48,032
还好现在没事了

2475
01:28:48,033 --> 01:28:53,833
幸好你们很多人在那里说， 他是演讲者……

2476
01:28:53,833 --> 01:28:56,533
没事的，这是他的日程表 哈哈

2477
01:28:56,533 --> 01:28:59,033
嗯 不管怎样 欢迎大家回来

2478
01:28:59,833 --> 01:29:01,033
那怎么样 有趣吗

2479
01:29:01,266 --> 01:29:02,266
啊 很有趣

2480
01:29:02,566 --> 01:29:04,866
我拿了咖啡 我觉得我准备好了

2481
01:29:05,133 --> 01:29:08,166
我们只有 55 分钟了 不是很多时间我的朋友们

2482
01:29:08,166 --> 01:29:09,399
所以我们要开始了

2483
01:29:09,400 --> 01:29:11,833
我知道你们有些人还正在回来

2484
01:29:12,066 --> 01:29:14,366
我们真的要继续了 所以

2485
01:29:14,366 --> 01:29:19,532
现在 我们已经构建了一个服务是一个 HTTP API

2486
01:29:19,900 --> 01:29:21,633
额…… 我们演示了 WebSocket

2487
01:29:21,633 --> 01:29:25,799
我们演示了 响应式 NoSQL 和 SQL 数据访问

2488
01:29:25,800 --> 01:29:28,566
在 Spring Data 的世界里

2489
01:29:29,400 --> 01:29:33,400
我们全部用 Java 写的加点 JavaScript

2490
01:29:33,966 --> 01:29:35,532
对吧 那有点

2491
01:29:36,733 --> 01:29:38,899
额…… 你懂得 总会遇到 JavaScript 的对吧

2492
01:29:38,900 --> 01:29:40,500
就如谚语所说那样

2493
01:29:40,500 --> 01:29:43,066
额 然后 现在

2494
01:29:43,900 --> 01:29:46,566
是时候将我们的注意力转到

2495
01:29:46,566 --> 01:29:49,132
构建客户端

2496
01:29:49,133 --> 01:29:51,399
构建一个东西 我们可以用来

2497
01:29:51,400 --> 01:29:54,733
额 与那个服务进行通信

2498
01:29:54,733 --> 01:29:56,299
去构建边缘服务

2499
01:29:56,300 --> 01:30:00,333
而边缘服务是在逻辑上在架构的边缘的东西

2500
01:30:00,766 --> 01:30:03,666
首个来自外界请求的端口

2501
01:30:03,833 --> 01:30:07,833
会被适配到对下游微服务的请求

2502
01:30:08,333 --> 01:30:10,899
而边缘服务是逻辑上我们处理

2503
01:30:11,133 --> 01:30:12,399
一些边界关键问题

2504
01:30:12,400 --> 01:30:14,200
例如 负载均衡

2505
01:30:14,200 --> 01:30:16,133
路由 还有安全之类的

2506
01:30:16,133 --> 01:30:18,999
所以我们要在这里做 在这个边缘服务里做

2507
01:30:19,900 --> 01:30:22,566
额 我们要构建一个 像往常一样

2508
01:30:23,766 --> 01:30:27,332
通过到 start.spring.io

2509
01:30:27,533 --> 01:30:28,366
OK? 所以我们开始

2510
01:30:30,033 --> 01:30:31,266
啊 现在

2511
01:30:31,733 --> 01:30:32,633
我们要构建一个应用

2512
01:30:33,033 --> 01:30:34,866
你知道吗 顺便说一下 有点失望

2513
01:30:35,266 --> 01:30:38,532
之前从 10 月 31 日开始

2514
01:30:38,533 --> 01:30:39,733
那时候是万圣节前夜

2515
01:30:39,733 --> 01:30:41,199
从 10 月 31 日开始

2516
01:30:41,833 --> 01:30:43,833
这是万圣节前夜风格的

2517
01:30:44,966 --> 01:30:45,799
那很酷啊

2518
01:30:46,833 --> 01:30:49,233
现在变回暗色模式也很好 你懂的

2519
01:30:49,866 --> 01:30:53,466
但 当时这里有个南瓜和鬼怪的

2520
01:30:53,866 --> 01:30:54,799
随意啦 没关系

2521
01:30:54,800 --> 01:30:57,533
OK 我们要构建一个应用基于 Kotlin 的

2522
01:30:57,833 --> 01:31:01,699
我们要构建一个 reservation-client

2523
01:31:01,700 --> 01:31:02,866
OK? 就是这样

2524
01:31:04,400 --> 01:31:07,566
很好 我们要在这边选择 正确的东西

2525
01:31:08,133 --> 01:31:09,733
当然选择 Java 13

2526
01:31:10,100 --> 01:31:12,766
然后我们有一些需要的依赖

2527
01:31:12,766 --> 01:31:14,099
我们需要响应式 Web 支持

2528
01:31:14,200 --> 01:31:15,333
我们需要 RSocket

2529
01:31:15,666 --> 01:31:18,766
额 我们需要 Spring Cloud Gateway

2530
01:31:19,033 --> 01:31:21,099
我们需要 响应式 Redis 支持

2531
01:31:21,100 --> 01:31:23,233
我们需要 Spring Security 支持

2532
01:31:23,566 --> 01:31:26,232
然后我觉得我对我目前的选择满意了

2533
01:31:26,233 --> 01:31:28,466
所以我要点击 Generate

2534
01:31:28,466 --> 01:31:30,066
当我确认我已经有了我所需要的

2535
01:31:31,133 --> 01:31:32,233
是的 齐了 好

2536
01:31:32,400 --> 01:31:33,833
所以我要构建一个应用

2537
01:31:33,833 --> 01:31:36,499
现在 这是一个 zip 文件可以打开的像往常一样

2538
01:31:37,266 --> 01:31:38,532
这是我们的 IDE

2539
01:31:40,800 --> 01:31:41,566
UAO

2540
01:31:42,666 --> 01:31:43,599
喔 这是什么东西

2541
01:31:45,166 --> 01:31:46,766
让我们看一下 我们不需要那个

2542
01:31:47,766 --> 01:31:48,166
这个也不要

2543
01:31:49,433 --> 01:31:49,999
这也不需要

2544
01:31:52,133 --> 01:31:53,466
OK？ reservation...

2545
01:31:54,500 --> 01:31:54,800
好

2546
01:31:56,033 --> 01:31:57,399
我给自己拿了两杯咖啡

2547
01:31:58,500 --> 01:31:59,300
只是以防万一

2548
01:32:05,500 --> 01:32:06,666
好东西

2549
01:32:06,933 --> 01:32:08,366
跑起来吧 好

2550
01:32:08,733 --> 01:32:10,299
这是基于 Kotlin 的应用程序

2551
01:32:10,533 --> 01:32:13,033
你们有多少人使用 Kotlin

2552
01:32:13,766 --> 01:32:16,732
OK 实际上很不错啊 手先别放下 让我看看

2553
01:32:17,700 --> 01:32:19,200
哇……

2554
01:32:19,766 --> 01:32:20,799
那很好啊

2555
01:32:21,400 --> 01:32:24,733
那大概有 三分之一 或者 四分之一 我觉得惊讶

2556
01:32:25,366 --> 01:32:27,099
这很让人惊奇 这很酷

2557
01:32:27,533 --> 01:32:28,399
好东西

2558
01:32:29,466 --> 01:32:31,699
所以 Kotlin 是一种好的编程语言

2559
01:32:31,700 --> 01:32:32,900
构建在 JVM 之上

2560
01:32:32,900 --> 01:32:34,866
你懂得 编译到字节码

2561
01:32:35,066 --> 01:32:36,832
有互操作性

2562
01:32:36,833 --> 01:32:38,599
跟其它的各种库之类的东西

2563
01:32:38,600 --> 01:32:40,566
使得它如此吸引人

2564
01:32:40,566 --> 01:32:44,699
目前 Kotlin 最大的用户是安卓用户

2565
01:32:44,700 --> 01:32:46,066
那是有很好的原因的

2566
01:32:46,300 --> 01:32:50,300
Android 很难有现代版本的 Java

2567
01:32:50,300 --> 01:32:52,400
Java 8 怎么讲都不

2568
01:32:52,633 --> 01:32:54,433
跟它们相关 对吧

2569
01:32:54,433 --> 01:32:56,533
你不能保证你在安卓写的代码

2570
01:32:56,533 --> 01:32:57,633
可以编程成 Java 8

2571
01:32:57,633 --> 01:33:01,233
因为很多人没有与 Java 8 兼容的运行时

2572
01:33:01,433 --> 01:33:04,199
所以你要编写代码编译到 Java 7 之类的

2573
01:33:04,200 --> 01:33:05,233
或者目标是 Java 7 

2574
01:33:05,400 --> 01:33:06,633
这可能有点让人失望

2575
01:33:06,800 --> 01:33:08,533
因为我们现在用的是 Java 13 对吧

2576
01:33:08,533 --> 01:33:11,066
版本号差不多是两倍了

2577
01:33:11,333 --> 01:33:14,599
然而我们还不能在安卓用户端使用它

2578
01:33:14,900 --> 01:33:16,233
所以 Kotlin 是非常不错的

2579
01:33:16,233 --> 01:33:17,899
它可以编译到更加老的版本

2580
01:33:18,166 --> 01:33:19,299
同时仍使用一种语言

2581
01:33:19,466 --> 01:33:21,566
用起来更像 Java 20 的感觉

2582
01:33:21,566 --> 01:33:23,266
相比较于 Java 7 对吧

2583
01:33:23,800 --> 01:33:24,166
额……

2584
01:33:25,033 --> 01:33:26,833
额 我意思我喜欢 Java 的 很显然啦 但是

2585
01:33:27,200 --> 01:33:29,100
那只是 按照定义来讲

2586
01:33:29,433 --> 01:33:31,999
它并没有那么有趣、前沿对吧

2587
01:33:32,633 --> 01:33:32,966
额……

2588
01:33:33,766 --> 01:33:34,566
所以 Kotlin

2589
01:33:34,900 --> 01:33:35,633
非常不错的语言

2590
01:33:35,733 --> 01:33:37,699
在 Kotlin 有些东西你要理解的 首先

2591
01:33:38,033 --> 01:33:39,799
函数是由 fun 开头的

2592
01:33:40,066 --> 01:33:41,732
函数名紧随其后

2593
01:33:42,000 --> 01:33:45,833
所有在 Kotlin 当中你可能称为方法的其实都只是函数

2594
01:33:45,833 --> 01:33:47,099
如果它们在一个类里边

2595
01:33:47,366 --> 01:33:48,666
我说它们是成员函数

2596
01:33:48,666 --> 01:33:49,666
如果在一个类之外

2597
01:33:50,100 --> 01:33:50,766
它们只是函数

2598
01:33:50,766 --> 01:33:52,032
它们只是顶层的东西

2599
01:33:52,033 --> 01:33:53,999
它们可以这样的 这是需要注意的

2600
01:33:54,266 --> 01:33:55,032
我们这里有的是

2601
01:33:55,400 --> 01:33:56,600
一个空的类

2602
01:33:57,166 --> 01:33:58,166
这是一个空的类

2603
01:33:58,400 --> 01:33:59,033
里边什么都没有

2604
01:33:59,400 --> 01:34:00,800
那里是同样的东西对吧

2605
01:34:00,800 --> 01:34:02,066
所以我有一个空的类

2606
01:34:02,333 --> 01:34:03,633
里边什么都没有

2607
01:34:04,033 --> 01:34:05,399
这个函数不属于这个类

2608
01:34:06,100 --> 01:34:06,566
它可以

2609
01:34:07,366 --> 01:34:08,666
那样的话 我就要这样做 对吧

2610
01:34:09,200 --> 01:34:10,200
但我不是要这样做

2611
01:34:10,200 --> 01:34:11,600
我只是有一个顶层的类

2612
01:34:11,933 --> 01:34:12,966
一个顶层的函数

2613
01:34:13,200 --> 01:34:15,166
它们看起来是相互相邻的

2614
01:34:15,666 --> 01:34:16,666
额 在 Kotlin 里边

2615
01:34:17,166 --> 01:34:17,932
参数名称

2616
01:34:18,166 --> 01:34:20,166
放前边然后才是类型 对吧

2617
01:34:20,566 --> 01:34:22,699
额 有一种同一的语法

2618
01:34:23,100 --> 01:34:24,266
给泛型参数的

2619
01:34:24,400 --> 01:34:25,933
那就是<xxx> 这是一个数组

2620
01:34:26,466 --> 01:34:29,699
String数组 相当于 String[] 对吧

2621
01:34:30,933 --> 01:34:33,633
OK 这基本上就是你需要理解的了

2622
01:34:33,633 --> 01:34:35,033
我们要做的是 我们要构建一个应用

2623
01:34:35,366 --> 01:34:37,732
那会访问一个 API

2624
01:34:38,100 --> 01:34:38,466
额……

2625
01:34:38,966 --> 01:34:40,199
边缘服务

2626
01:34:40,200 --> 01:34:41,666
首先要做一些事情

2627
01:34:41,666 --> 01:34:42,866
我要确保这个应用

2628
01:34:43,300 --> 01:34:45,800
在 9999 端口启动

2629
01:34:46,533 --> 01:34:48,399
我们要确保注释掉

2630
01:34:49,033 --> 01:34:51,933
那个…… 那个…… 安全相关的东西

2631
01:34:51,933 --> 01:34:54,233
因为那会锁住这个应用的 我们现在还不想这样

2632
01:34:55,166 --> 01:34:56,399
好吧 计算机

2633
01:34:57,533 --> 01:34:57,866
好？

2634
01:35:00,033 --> 01:35:01,033
好 这样可以了 好吗

2635
01:35:01,333 --> 01:35:03,133
我要选择 Enable-Auto import

2636
01:35:03,133 --> 01:35:05,233
因为有时候要更改 classpath

2637
01:35:05,233 --> 01:35:06,833
我希望工具会跟上节奏

2638
01:35:07,266 --> 01:35:09,332
OK 现在我要创建一个类

2639
01:35:09,333 --> 01:35:09,966
它将会是

2640
01:35:10,333 --> 01:35:13,399
额 Java config 风格的端点

2641
01:35:13,400 --> 01:35:15,200
我将会创建一个 API 网关

2642
01:35:15,500 --> 01:35:16,366
使用 Spring Cloud API Gateway

2643
01:35:16,366 --> 01:35:17,466
这是第一类

2644
01:35:17,766 --> 01:35:18,499
边缘服务

2645
01:35:18,800 --> 01:35:22,233
一个 API 网关是一种将外界请求

2646
01:35:22,533 --> 01:35:25,066
并处理它们

2647
01:35:25,433 --> 01:35:26,899
以一种通用的方式

2648
01:35:26,900 --> 01:35:30,366
有点与载荷本身无关的那样

2649
01:35:30,366 --> 01:35:33,199
它基本不知道那是 JSON 还是 XML 也不怎么关心

2650
01:35:33,433 --> 01:35:35,366
它只是做一些通用的转换

2651
01:35:35,633 --> 01:35:37,733
与载荷的语义无关

2652
01:35:37,866 --> 01:35:40,066
与特定的载荷本身无关

2653
01:35:40,566 --> 01:35:43,466
所以我们要创建一个基于 Spring Cloud Gateway的网关

2654
01:35:43,700 --> 01:35:44,766
现在 Spring Cloud Gateway

2655
01:35:44,800 --> 01:35:47,833
是构建在 Spring 响应式 Web 支持之上的

2656
01:35:47,833 --> 01:35:49,333
所以它本身就是响应式的了

2657
01:35:49,600 --> 01:35:52,166
我要在这里创建一个 Java 配置风格的端点

2658
01:35:52,666 --> 01:35:54,466
所以我在创建一个 额…… 

2659
01:35:54,466 --> 01:35:58,466
我们过去称之为 Bean 配置方法的 现在是函数

2660
01:35:58,900 --> 01:36:01,466
我正在注入一个类型为 RouteLocatorBuilder 的参数

2661
01:36:01,733 --> 01:36:03,266
我要使用 RouteLocatorBuilder

2662
01:36:03,566 --> 01:36:05,266
去构建我的网关路由

2663
01:36:05,633 --> 01:36:07,099
你做的方式是构建一个路由

2664
01:36:08,133 --> 01:36:09,866
然后你构建（builder 模式） OK？

2665
01:36:10,700 --> 01:36:11,933
现在 额……

2666
01:36:12,666 --> 01:36:14,066
在 Java 的话看起来就像这样

2667
01:36:14,200 --> 01:36:16,233
显然 在 Java 你会有分号

2668
01:36:16,233 --> 01:36:16,899
但在这里是可选的

2669
01:36:17,200 --> 01:36:19,766
可以有任意多个这样的route() 调用

2670
01:36:20,300 --> 01:36:21,200
每个路由

2671
01:36:21,933 --> 01:36:26,133
对应着某些会进入到服务的东西的定义

2672
01:36:26,500 --> 01:36:27,666
然后你想要拦截

2673
01:36:27,966 --> 01:36:30,866
处理 然后转发到其它东西

2674
01:36:30,866 --> 01:36:34,866
OK? 通常你有一个像这样的 Lambda

2675
01:36:35,233 --> 01:36:39,366
然后 Lambda 有一个 route 配置 或 规范

2676
01:36:39,766 --> 01:36:42,999
然后使用路由的规范去定义 例如

2677
01:36:43,233 --> 01:36:44,833
当每个请求进入到

2678
01:36:45,133 --> 01:36:47,233
这个路径 称为 /proxy

2679
01:36:47,766 --> 01:36:49,632
... and().host(...

2680
01:36:50,466 --> 01:36:53,899
这个主机 ……

2681
01:36:54,200 --> 01:36:56,200
然后我想将它发送到

2682
01:36:56,400 --> 01:36:57,900
这个 URL 所以 localhost ...

2683
01:37:00,700 --> 01:37:01,133
现在当然

2684
01:37:01,566 --> 01:37:03,199
我实际这样做不到 对吧？

2685
01:37:03,400 --> 01:37:04,266
这会发生什么？

2686
01:37:04,266 --> 01:37:05,599
首先  嗯……

2687
01:37:06,766 --> 01:37:08,399
我需要返回一个 RouteLocator

2688
01:37:08,500 --> 01:37:10,900
...RouterLocator...

2689
01:37:10,900 --> 01:37:11,766
那就是返回值

2690
01:37:12,133 --> 01:37:13,066
那就是它抱怨的

2691
01:37:13,466 --> 01:37:14,499
额 首先

2692
01:37:14,833 --> 01:37:16,233
将要发生的是 我想要

2693
01:37:16,400 --> 01:37:17,600
匹配 /proxy

2694
01:37:17,800 --> 01:37:19,300
然后我想匹配这个主机名

2695
01:37:19,633 --> 01:37:22,099
当然如果路径是 /proxy 那么

2696
01:37:22,533 --> 01:37:23,866
如果我转发到这个

2697
01:37:23,866 --> 01:37:25,432
不作任何地更改

2698
01:37:25,800 --> 01:37:27,933
那会变成 /reservations/proxy

2699
01:37:28,133 --> 01:37:29,333
那不是我想要的 所以我需要

2700
01:37:29,600 --> 01:37:31,566
去过滤、我要按某种方式处理一下

2701
01:37:31,800 --> 01:37:34,400
所以这里我们有 filter 回调 我们写……

2702
01:37:34,800 --> 01:37:35,866
然后赋予一个 lambda

2703
01:37:35,866 --> 01:37:37,366
我们可以使用 filterSpec...

2704
01:37:38,233 --> 01:37:39,899
然后写……

2705
01:37:44,133 --> 01:37:45,866
这将会作为一个代理 这些过滤器

2706
01:37:46,133 --> 01:37:48,599
是这里真正的力量

2707
01:37:48,600 --> 01:37:50,233
它赋予你能力做各种事情

2708
01:37:50,533 --> 01:37:50,999
想象一下

2709
01:37:51,333 --> 01:37:54,499
你有一个 HTTP (不好意思口误）HTML 5 客户端

2710
01:37:54,900 --> 01:37:56,200
然后那个 HTML5 客户端

2711
01:37:56,433 --> 01:37:58,466
想要调用下游的服务

2712
01:37:58,866 --> 01:38:00,132
额 为了让那成为可能

2713
01:38:01,066 --> 01:38:02,866
你要确保你支持

2714
01:38:03,200 --> 01:38:04,766
CORS 跨域请求脚本 对吧

2715
01:38:05,100 --> 01:38:06,266
而为了那样做 你要写

2716
01:38:06,900 --> 01:38:08,166
我想要添加一个首部

2717
01:38:08,166 --> 01:38:08,899
HttpHeaders.

2718
01:38:09,200 --> 01:38:09,933
噢 不是这个

2719
01:38:10,666 --> 01:38:12,366
你可以看到不少人也想到了这个

2720
01:38:12,633 --> 01:38:13,399
对吧 HttpHeaders

2721
01:38:13,900 --> 01:38:16,100
我们要允许 ACESS_CONTROL_ALLOW_ORIGIN

2722
01:38:17,066 --> 01:38:17,699
ALLOW_ORIGIN

2723
01:38:17,700 --> 01:38:19,166
我想要说 允许所有东西

2724
01:38:19,366 --> 01:38:19,799
OK？

2725
01:38:20,100 --> 01:38:21,366
嗯 所以那是

2726
01:38:21,366 --> 01:38:22,566
让我们去掉另一个

2727
01:38:22,566 --> 01:38:24,332
使得这不必要地长

2728
01:38:25,866 --> 01:38:27,032
OK 拜拜

2729
01:38:28,000 --> 01:38:29,166
然后这个

2730
01:38:32,533 --> 01:38:32,933
OK？

2731
01:38:35,300 --> 01:38:35,566
好

2732
01:38:36,200 --> 01:38:37,600
这就是这些代码

2733
01:38:37,600 --> 01:38:39,233
让我们看一下如果运行会怎样

2734
01:38:48,566 --> 01:38:49,132
正在编译

2735
01:38:51,500 --> 01:38:52,033
curl

2736
01:38:52,800 --> 01:38:58,500
减号 额不好意思 http://locahost:9999/proxy

2737
01:38:58,500 --> 01:38:59,666
这样当然是不行的

2738
01:39:00,400 --> 01:39:01,233
额 噢~

2739
01:39:01,600 --> 01:39:01,933
不是这个

2740
01:39:02,666 --> 01:39:04,099
security.rsocket #%……￥%@#

2741
01:39:07,400 --> 01:39:07,600
哼？

2742
01:39:12,166 --> 01:39:12,799
这是什么鬼

2743
01:39:23,466 --> 01:39:24,899
我这辈子都没见过这个

2744
01:39:26,566 --> 01:39:27,866
说真的 这真有趣

2745
01:39:28,933 --> 01:39:30,099
这就是追求新技术的馈赠

2746
01:39:32,033 --> 01:39:33,266
OK 我们有这个

2747
01:39:33,266 --> 01:39:34,599
让我们注释掉它

2748
01:39:34,600 --> 01:39:36,066
我以为我已经注释掉安全相关的依赖了 不是吗

2749
01:39:36,066 --> 01:39:36,732
我觉得我已经注释掉了

2750
01:39:38,400 --> 01:39:39,666
maven reimport...

2751
01:39:48,966 --> 01:39:50,966
别 那是什么？ ...rsocket.core?

2752
01:39:52,533 --> 01:39:54,733
哇 看起来我们的确遇到些问题了 但我们可以

2753
01:39:55,600 --> 01:39:56,633
有可能解决它

2754
01:39:56,900 --> 01:39:58,433
让我们看一下 噢这个

2755
01:39:58,833 --> 01:40:00,699
spring-security-rsocket 没人想要这东西

2756
01:40:02,000 --> 01:40:02,733
我没要这个

2757
01:40:03,266 --> 01:40:04,166
OK 这次好了

2758
01:40:06,466 --> 01:40:07,566
这是新的 OK 好 那么

2759
01:40:07,966 --> 01:40:11,099
它们想帮忙的 因为我最初勾选了RSocket

2760
01:40:11,100 --> 01:40:12,100
它引入了其它东西

2761
01:40:12,100 --> 01:40:13,166
然后我勾选了 Security

2762
01:40:13,166 --> 01:40:14,166
它将这两样都引入了

2763
01:40:14,533 --> 01:40:15,399
但这两样我不是全都要

2764
01:40:16,133 --> 01:40:17,199
OK 现在它显示

2765
01:40:17,600 --> 01:40:19,333
它找不到端点 对吧

2766
01:40:19,333 --> 01:40:20,999
404 所以现在

2767
01:40:21,266 --> 01:40:27,099
我指定一个主机断言 -H"host.devoxx.spring.io"

2768
01:40:27,633 --> 01:40:28,033
OK

2769
01:40:28,033 --> 01:40:31,166
然后 那…… 失败了 额 9999

2770
01:40:32,333 --> 01:40:33,866
-H ... devoxx.spring.io

2771
01:40:35,400 --> 01:40:36,733
连接被拒绝……

2772
01:40:38,033 --> 01:40:39,333
噢 因为我的服务（未运行） OK

2773
01:40:39,733 --> 01:40:40,666
它正在代理请求

2774
01:40:41,133 --> 01:40:42,033
到这边这个东西

2775
01:40:42,033 --> 01:40:42,999
我的 ReservationService

2776
01:40:43,400 --> 01:40:44,533
那东西还没有运行

2777
01:40:44,866 --> 01:40:45,966
OK 让我们重启它

2778
01:40:46,966 --> 01:40:48,032
然后这些就是请求

2779
01:40:48,033 --> 01:40:53,933
如果我美化输出到 JSON....  json_pp

2780
01:40:54,766 --> 01:40:55,399
OK 就是这样

2781
01:40:55,633 --> 01:40:56,066
这是我们的数据

2782
01:40:56,366 --> 01:40:58,266
OK 所以我们代理转发了数据

2783
01:40:58,933 --> 01:41:01,866
我们也可以看更加详尽的输出

2784
01:41:02,566 --> 01:41:02,999
去掉那个

2785
01:41:03,433 --> 01:41:04,833
我们可以看到我们这样做

2786
01:41:05,333 --> 01:41:08,166
它添加 Access-Control-Allow-Origin 首部到响应

2787
01:41:08,566 --> 01:41:09,832
所以现在任何 JavaScript 客户端

2788
01:41:09,833 --> 01:41:11,199
可以连接到我的边缘服务

2789
01:41:12,000 --> 01:41:13,433
而那会允许它们获取到数据

2790
01:41:14,200 --> 01:41:16,500
它会响应式不阻塞地转发请求

2791
01:41:16,700 --> 01:41:18,233
那不会等待完整的响应

2792
01:41:18,333 --> 01:41:19,899
它会流式传输数据当可用的时候

2793
01:41:20,233 --> 01:41:22,033
它会从下游的微服务获取到数据

2794
01:41:22,033 --> 01:41:25,166
在这个例子中就是 localhost:8080/reservasions

2795
01:41:25,366 --> 01:41:27,399
然后它会发送回到给我们的客户端

2796
01:41:27,966 --> 01:41:28,199
OK？

2797
01:41:28,400 --> 01:41:30,466
所以现在 让我们再回顾一下这代码 既然我们

2798
01:41:30,466 --> 01:41:33,599
已经让应用程序的基本骨架可以跑起来了

2799
01:41:34,066 --> 01:41:34,566
这个

2800
01:41:35,200 --> 01:41:38,933
是在 Kotlin 种非常像 Java 做法

2801
01:41:39,233 --> 01:41:39,699
OK ?

2802
01:41:39,933 --> 01:41:41,866
但有很多方面我们可以改善的 首先

2803
01:41:42,233 --> 01:41:43,333
我们有一个函数

2804
01:41:43,466 --> 01:41:44,732
创建了一个表达式

2805
01:41:44,733 --> 01:41:46,766
那个我们之后返回了

2806
01:41:47,200 --> 01:41:48,000
我们实际上没有

2807
01:41:48,533 --> 01:41:50,333
什么东西在中间 没有逻辑 没有状态

2808
01:41:50,333 --> 01:41:51,233
什么都没有 我们不

2809
01:41:51,566 --> 01:41:52,966
我们并没有从中获益

2810
01:41:53,166 --> 01:41:54,199
所以我们可以使用等号

2811
01:41:54,733 --> 01:41:55,666
在这个例子 我们实际上可以

2812
01:41:56,033 --> 01:41:57,366
做个赋值 基本上我们可以写

2813
01:41:57,633 --> 01:41:59,899
这个函数 = 这个表达式

2814
01:41:59,900 --> 01:42:02,000
所以如果你调用这个 它是等价于调用那个的

2815
01:42:02,466 --> 01:42:03,466
那样更好一点

2816
01:42:03,733 --> 01:42:05,733
另一个 Kotlin 做得很好的是

2817
01:42:06,133 --> 01:42:08,666
它有种很好的能力

2818
01:42:09,033 --> 01:42:11,833
如果一个函数最后的参数是个lambda

2819
01:42:12,066 --> 01:42:13,566
你可以将lambda写到函数的外边

2820
01:42:13,566 --> 01:42:14,799
所以在这个例子

2821
01:42:15,133 --> 01:42:16,599
我可以将它重写成这样

2822
01:42:17,233 --> 01:42:18,699
喔 这看起来有点傻 不是吗？

2823
01:42:18,700 --> 01:42:19,866
现在我在那里什么都没有了

2824
01:42:20,033 --> 01:42:20,266
对吧

2825
01:42:20,500 --> 01:42:21,966
但功能上是一样的

2826
01:42:22,300 --> 01:42:24,900
所以在 Kotlin 你也可以去掉括号

2827
01:42:25,400 --> 01:42:27,266
对吧 那也是同样的东西

2828
01:42:27,400 --> 01:42:29,500
额 这样好了一点 对吧？

2829
01:42:29,500 --> 01:42:31,666
这边也一样 我可以修改这个

2830
01:42:32,933 --> 01:42:34,366
即使这些全都很不错

2831
01:42:34,833 --> 01:42:37,499
但是我们有这些不必要 有些……

2832
01:42:38,233 --> 01:42:39,166
lambda 的参数

2833
01:42:39,300 --> 01:42:40,800
对吧 这是一个路由的规范

2834
01:42:41,233 --> 01:42:42,833
但 这只是中间变量

2835
01:42:42,833 --> 01:42:44,799
这些是我们创建了为了有个名字而已

2836
01:42:44,800 --> 01:42:46,366
但我们并不需要这些名字

2837
01:42:46,366 --> 01:42:48,532
因为我们直到 lambda 有它的参数

2838
01:42:48,733 --> 01:42:50,466
所以我们可以去掉这些变量名

2839
01:42:50,633 --> 01:42:51,866
然后我们可以用 it 引用

2840
01:42:52,400 --> 01:42:55,766
it 是一个隐式地被创建的参数 对吧

2841
01:42:56,300 --> 01:42:59,833
如果你用过 groovy 你就知道这些东西了 对吧

2842
01:43:00,333 --> 01:43:02,399
所以同样的东西 我可以在这做同样的东西

2843
01:43:02,533 --> 01:43:03,566
我可以写 it 对吧

2844
01:43:04,000 --> 01:43:05,900
当然 在这个例子 可能会有点疑惑

2845
01:43:06,133 --> 01:43:06,933
因为变量范围的问题

2846
01:43:07,200 --> 01:43:09,366
这可能是你想要保留变量名的原因

2847
01:43:09,666 --> 01:43:10,566
OK 随你

2848
01:43:11,100 --> 01:43:13,266
OK 我喜欢那样 看起来更好一点了

2849
01:43:13,500 --> 01:43:14,500
但甚至在这里

2850
01:43:15,200 --> 01:43:16,166
我们还可以做得更好

2851
01:43:16,466 --> 01:43:18,732
所以 其实 Kotlin 当中有个很好的特性

2852
01:43:18,733 --> 01:43:20,199
或可以获得扩展函数

2853
01:43:20,566 --> 01:43:23,566
这些是在 JVM、JDK

2854
01:43:23,566 --> 01:43:25,932
还有在 classpath 上的代码里面

2855
01:43:26,333 --> 01:43:28,866
但它们被添加到已存在的类型

2856
01:43:29,200 --> 01:43:31,300
所以你可以将类型粘起来 非常像 ruby

2857
01:43:31,300 --> 01:43:33,866
例如你可以给已存在的类添加东西

2858
01:43:34,166 --> 01:43:37,066
额 这意味着你可以像玩视频游戏

2859
01:43:37,066 --> 01:43:38,399
你可以解锁一个秘密等级

2860
01:43:38,666 --> 01:43:40,366
你的类路径上有这些库

2861
01:43:40,366 --> 01:43:44,699
那些通常是为 Java 用户准备的

2862
01:43:45,466 --> 01:43:47,899
但它们表达了某些 API 功能

2863
01:43:47,900 --> 01:43:49,633
某些能力到 Kotlin

2864
01:43:49,900 --> 01:43:51,233
而且只有通过使用 Kotlin

2865
01:43:51,333 --> 01:43:52,299
才可以使用它

2866
01:43:52,500 --> 01:43:55,000
所以实际上 我们还可以再次重写一遍

2867
01:43:55,700 --> 01:43:56,366
routes

2868
01:43:58,100 --> 01:43:59,066
然后这是 DSL

2869
01:43:59,966 --> 01:44:02,166
所以 RouteLocatorBuilder 是 Java API

2870
01:44:02,166 --> 01:44:04,099
是用 Java 写的 你可以看到代码

2871
01:44:05,000 --> 01:44:05,733
是 Java 对吧

2872
01:44:06,100 --> 01:44:06,400
不过

2873
01:44:07,033 --> 01:44:08,866
这里有个额外的函数 称为 routes

2874
01:44:09,566 --> 01:44:10,466
我们可以看到

2875
01:44:11,133 --> 01:44:12,333
是一个扩展函数

2876
01:44:13,166 --> 01:44:14,399
让我下载它

2877
01:44:16,366 --> 01:44:16,632
OK

2878
01:44:17,600 --> 01:44:18,600
下载源代码吧

2879
01:44:20,333 --> 01:44:21,499
谁在下种子 随意吧

2880
01:44:21,866 --> 01:44:23,032
OK 这个函数

2881
01:44:23,900 --> 01:44:27,166
是定义在 RouteLocator 之上的

2882
01:44:27,666 --> 01:44:28,732
并且它需要一个 RouteLocator 做参数

2883
01:44:29,033 --> 01:44:31,033
从这里之后它接收一个参数

2884
01:44:31,266 --> 01:44:31,999
那是一个 lambda

2885
01:44:32,566 --> 01:44:34,699
那 这很有趣 这个lambda语法

2886
01:44:34,966 --> 01:44:36,099
没有参数

2887
01:44:36,266 --> 01:44:37,299
然后返回 Void 

2888
01:44:37,300 --> 01:44:38,466
Unit 相当于 Void

2889
01:44:38,833 --> 01:44:40,499
这个 lambda 也写作

2890
01:44:41,200 --> 01:44:42,733
也被定义做

2891
01:44:43,166 --> 01:44:48,366
额… 基于对上下文绑定的RouteLocator DSL引用的

2892
01:44:48,633 --> 01:44:49,133
所以基本上

2893
01:44:49,433 --> 01:44:50,233
在那个lambda

2894
01:44:50,300 --> 01:44:51,966
如果我调用 this.

2895
01:44:52,500 --> 01:44:53,600
我实际上调用的是

2896
01:44:53,766 --> 01:44:57,199
我是对着一个 RouteLocator 实例调用的 this.

2897
01:44:57,933 --> 01:45:02,833
我原来的 'this' 已经被替换成这个 DSL 的 'this'

2898
01:45:03,133 --> 01:45:06,099
这意味着我可以对着这个（方法）调用，我意思是类型

2899
01:45:06,500 --> 01:45:08,766
而实际不需要声明那个类型

2900
01:45:08,766 --> 01:45:11,832
我的 lambda 被插入到那个对象里

2901
01:45:11,866 --> 01:45:12,866
它的上下文 基本上是这样

2902
01:45:13,233 --> 01:45:14,866
所以现在我可以重写这些

2903
01:45:15,100 --> 01:45:16,533
更加明确地 我可以说

2904
01:45:16,866 --> 01:45:17,499
route...

2905
01:45:18,566 --> 01:45:20,299
然后我要匹配一个路径

2906
01:45:20,766 --> 01:45:21,599
为 /proxy

2907
01:45:22,233 --> 01:45:23,466
而且，顺便说一下，我可以这样做

2908
01:45:23,466 --> 01:45:24,966
我们可以那样做 但我们也有

2909
01:45:25,533 --> 01:45:27,266
额 中缀表示法

2910
01:45:27,433 --> 01:45:27,666
对吧

2911
01:45:28,133 --> 01:45:28,699
所以 ...host...

2912
01:45:29,166 --> 01:45:30,132
我可以这样做 我写

2913
01:45:30,400 --> 01:45:32,266
"*.spring.io"

2914
01:45:32,666 --> 01:45:32,966
随意啦

2915
01:45:33,366 --> 01:45:34,799
但因为这是中缀标记法

2916
01:45:34,800 --> 01:45:36,100
我可以去掉所有这些

2917
01:45:36,933 --> 01:45:38,266
对吧 同样的东西

2918
01:45:39,066 --> 01:45:39,332
额……

2919
01:45:39,933 --> 01:45:40,299
然后

2920
01:45:40,933 --> 01:45:41,999
我想要创建 filter

2921
01:45:42,833 --> 01:45:43,733
然后这个 filter

2922
01:45:43,833 --> 01:45:45,033
包括设置路径

2923
01:45:45,200 --> 01:45:46,300
对吧 "/reservations"

2924
01:45:47,333 --> 01:45:48,899
然后我想要添加响应首部

2925
01:45:49,566 --> 01:45:50,099
让我……

2926
01:45:51,200 --> 01:45:51,800
复制这个

2927
01:45:53,300 --> 01:45:54,400
OK 跟之前的一样

2928
01:45:55,333 --> 01:45:56,499
然后是 uri

2929
01:45:58,833 --> 01:45:59,366
在这里

2930
01:46:00,700 --> 01:46:01,233
"http...

2931
01:46:01,800 --> 01:46:04,966
"http://localhost:8080/"

2932
01:46:05,500 --> 01:46:05,800
好了

2933
01:46:06,100 --> 01:46:06,333
就这样

2934
01:46:06,933 --> 01:46:07,566
这就是整个东西

2935
01:46:07,566 --> 01:46:08,532
所以现在我可以重写

2936
01:46:08,833 --> 01:46:10,199
全部 我不需要 build

2937
01:46:10,566 --> 01:46:12,732
上下文会帮我完成的

2938
01:46:12,733 --> 01:46:14,133
就是作用范围它本身

2939
01:46:14,433 --> 01:46:15,099
给予了我那个 对吧

2940
01:46:15,700 --> 01:46:17,766
然后就是这样 这就是全部的重写的 DSL

2941
01:46:18,266 --> 01:46:18,866
所以你得到像这样的

2942
01:46:19,266 --> 01:46:19,932
类型安全的

2943
01:46:20,433 --> 01:46:22,133
看起来有点像 有点让我想起

2944
01:46:22,733 --> 01:46:24,233
以前的 Apache 配置文件 对吧

2945
01:46:24,633 --> 01:46:26,866
不同的是这是编译器的 而且是类型安全的

2946
01:46:27,000 --> 01:46:27,633
对吧 这很不错

2947
01:46:29,066 --> 01:46:31,032
所以这跟刚才给你展示的东西基本上是一样的

2948
01:46:31,033 --> 01:46:32,599
为了证明 让我们重启一下应用

2949
01:46:33,300 --> 01:46:34,866
我喝点咖啡 我觉得我值得这样做

2950
01:46:42,933 --> 01:46:43,199
OK？

2951
01:46:43,600 --> 01:46:43,900
那么

2952
01:46:44,133 --> 01:46:45,099
看吧 这就是我们的数据

2953
01:46:45,566 --> 01:46:46,699
所以这就是跑起来了的应用

2954
01:46:47,000 --> 01:46:47,166
现在

2955
01:46:48,266 --> 01:46:48,932
那个过滤器

2956
01:46:49,266 --> 01:46:50,699
就是魔法的所作

2957
01:46:50,700 --> 01:46:51,666
是力量所在

2958
01:46:51,666 --> 01:46:53,132
我可以做各种有趣的事情

2959
01:46:53,133 --> 01:46:55,299
我可以修改首部 我可以修改请求 URI

2960
01:46:55,533 --> 01:46:57,866
我可以修改请求体、响应体

2961
01:46:58,100 --> 01:46:58,933
我可以保存

2962
01:46:59,166 --> 01:47:01,666
或者是移除首部 例如 host 首部

2963
01:47:01,933 --> 01:47:03,933
我可以做重定向、可以做重试

2964
01:47:03,933 --> 01:47:05,233
我可以做重写

2965
01:47:05,400 --> 01:47:06,100
URL 重写

2966
01:47:06,200 --> 01:47:09,766
一些你可能会用 NGINX 或 mod_rewrite 做的事

2967
01:47:09,766 --> 01:47:10,966
你可以很容在这里做到

2968
01:47:10,966 --> 01:47:12,299
路径重写之类的东西

2969
01:47:12,733 --> 01:47:13,666
你可以在这里做

2970
01:47:13,966 --> 01:47:17,099
我可以设置响应的状态

2971
01:47:17,100 --> 01:47:18,366
我可以做各种事情

2972
01:47:18,666 --> 01:47:19,832
使用这些 filter

2973
01:47:20,166 --> 01:47:21,899
我最喜欢做的事情之一是

2974
01:47:21,900 --> 01:47:23,900
当然是创建我自己的 filter 对吧

2975
01:47:24,200 --> 01:47:25,400
因为你可以完全掌控

2976
01:47:25,400 --> 01:47:26,466
所以如果你想要创建你自己的 filter

2977
01:47:26,666 --> 01:47:28,199
做起来很简单 对吧 你可以

2978
01:47:28,600 --> 01:47:29,366
你可以看那是怎么做的

2979
01:47:29,766 --> 01:47:29,999
嗯……

2980
01:47:31,466 --> 01:47:33,066
另一样我最喜欢做的事是

2981
01:47:33,066 --> 01:47:34,666
考虑下限制访问速率

2982
01:47:35,633 --> 01:47:35,999
那么

2983
01:47:36,600 --> 01:47:37,200
速率限制器

2984
01:47:37,466 --> 01:47:38,366
是一个非常简单的东西

2985
01:47:38,366 --> 01:47:39,632
速率限制器是一种东西

2986
01:47:40,000 --> 01:47:42,033
当有一个请求进来的时候

2987
01:47:42,533 --> 01:47:43,766
查看进来的请求

2988
01:47:44,266 --> 01:47:46,999
基于你的规范的条件来验证

2989
01:47:47,433 --> 01:47:47,733
然后

2990
01:47:48,033 --> 01:47:49,899
选择保留还是拒绝那个请求

2991
01:47:50,300 --> 01:47:50,600
还有

2992
01:47:50,666 --> 01:47:51,932
通常那个标准是

2993
01:47:52,033 --> 01:47:53,966
你所规定的一个计数 一个预算

2994
01:47:54,200 --> 01:47:55,500
你说，我允许

2995
01:47:55,800 --> 01:47:59,000
额…… 让我们假设 10 个记录 5 个请求

2996
01:47:59,266 --> 01:48:00,366
每秒十个请求

2997
01:48:00,800 --> 01:48:02,900
或5请求每秒 或者是 每秒百万个请求

2998
01:48:02,900 --> 01:48:03,700
不管是什么吧

2999
01:48:03,933 --> 01:48:05,233
对你来说可以接受就好

3000
01:48:06,400 --> 01:48:06,933
一个速率限制器

3001
01:48:08,233 --> 01:48:10,266
关注两个很常见的应用场景

3002
01:48:11,400 --> 01:48:12,333
第一种用例

3003
01:48:12,733 --> 01:48:13,599
是 嘿~

3004
01:48:14,300 --> 01:48:17,466
我想要限制在全球范围的绝对请求次数

3005
01:48:18,466 --> 01:48:21,032
到 随意吧 n 个请求每秒

3006
01:48:21,133 --> 01:48:22,599
5 让我们只用 5

3007
01:48:22,866 --> 01:48:24,966
简单容易好算数 OK？

3008
01:48:25,500 --> 01:48:28,866
所以假设我们想要限制每秒访问的绝对次数为5个请求

3009
01:48:29,700 --> 01:48:32,833
这意味着不管人们在哪里发起请求

3010
01:48:32,833 --> 01:48:35,166
也不管是一个客户端、机器人或者是人

3011
01:48:35,433 --> 01:48:36,033
什么都没关系

3012
01:48:36,300 --> 01:48:38,366
你只需限制每秒5个请求就好了

3013
01:48:38,833 --> 01:48:39,599
对于全球范围

3014
01:48:39,766 --> 01:48:40,099
OK？

3015
01:48:40,600 --> 01:48:40,900
嗯……

3016
01:48:41,633 --> 01:48:43,966
这是很常见的用例

3017
01:48:44,200 --> 01:48:47,533
如果，由于某种原因你有一个很昂贵的下游服务

3018
01:48:47,766 --> 01:48:49,466
那 很难扩展起来的

3019
01:48:49,900 --> 01:48:51,333
例如 我想到的是大型机

3020
01:48:51,666 --> 01:48:55,999
对吧 某种大型机 你可以处理 x 个请求

3021
01:48:56,000 --> 01:48:57,400
x 个事务处理

3022
01:48:57,633 --> 01:48:58,499
x 个用户

3023
01:48:58,933 --> 01:48:59,933
但如果你再添加一个

3024
01:49:00,400 --> 01:49:01,700
你要买个新的大型机

3025
01:49:02,366 --> 01:49:02,566
对吧

3026
01:49:03,000 --> 01:49:05,766
这些东西还未开始用就已经要花几百万了

3027
01:49:05,966 --> 01:49:08,032
对吧 如果可以的话没人想要扩展这些东西

3028
01:49:08,433 --> 01:49:09,633
所以这非常有用 像说 嘿~

3029
01:49:10,033 --> 01:49:11,933
我要将所有东西汇聚起来降低到这个小的

3030
01:49:12,166 --> 01:49:13,466
受限的速率

3031
01:49:13,766 --> 01:49:15,432
我要说 OK 这里只有 5 个请求

3032
01:49:15,833 --> 01:49:16,666
只是简单的数学

3033
01:49:17,133 --> 01:49:18,299
我确信你可以处理比那更多的 对吧

3034
01:49:18,300 --> 01:49:20,700
但是我只将它限制到每秒5个请求

3035
01:49:21,000 --> 01:49:21,833
对全球范围

3036
01:49:21,833 --> 01:49:23,833
不管是谁在发起请求

3037
01:49:24,800 --> 01:49:25,033
嗯……

3038
01:49:25,266 --> 01:49:27,032
这是一种应用场景 另一个应用场景是

3039
01:49:27,566 --> 01:49:29,799
我想要处理 我想每个用户

3040
01:49:30,633 --> 01:49:32,366
都是每秒只能发起5个请求

3041
01:49:33,533 --> 01:49:35,833
好吧 所以在这个案例你没有扩展起来的问题

3042
01:49:36,233 --> 01:49:39,366
很可能地 现在是 2019 年 快到 2020年了

3043
01:49:39,700 --> 01:49:41,833
你可以使用一个云平台 例如 CloudFoundry

3044
01:49:41,833 --> 01:49:43,299
或者你可以用 Kubernetes 构建一些东西

3045
01:49:43,633 --> 01:49:45,233
额 随意什么东西吧 对吧？

3046
01:49:45,833 --> 01:49:46,633
如果是这样的案例

3047
01:49:46,633 --> 01:49:49,599
你想要限制对下游服务的调用

3048
01:49:50,266 --> 01:49:52,432
但你不想限制用户的绝对数量

3049
01:49:52,433 --> 01:49:54,999
通常你只是限制每个用户的请求数量

3050
01:49:55,000 --> 01:49:58,200
以确保每个人都参与公平的游戏

3051
01:49:58,200 --> 01:50:01,566
额 没有人 你懂得 滥用系统

3052
01:50:01,866 --> 01:50:04,232
并从中获益

3053
01:50:04,233 --> 01:50:06,299
你不希望有机器人对你的页面发送垃圾请求

3054
01:50:06,300 --> 01:50:07,533
或者是爬虫之类的 不管什么

3055
01:50:07,800 --> 01:50:10,833
发现一种方式毁了系统对其它人的服务质量

3056
01:50:11,400 --> 01:50:13,833
所以速率限制器在这两方面都有用

3057
01:50:14,700 --> 01:50:15,066
嗯……

3058
01:50:15,400 --> 01:50:18,900
速率限制器维持进入系统的请求的计数

3059
01:50:19,233 --> 01:50:19,533
同时

3060
01:50:20,233 --> 01:50:22,333
它们与你所给的预算作比较

3061
01:50:22,333 --> 01:50:23,733
如果预算超了

3062
01:50:23,733 --> 01:50:25,199
它们拒绝请求

3063
01:50:25,200 --> 01:50:27,000
它们将请求发到别的地方去

3064
01:50:27,600 --> 01:50:28,433
所以我们有了速率限制器

3065
01:50:29,166 --> 01:50:29,666
嗯……

3066
01:50:30,033 --> 01:50:33,266
一个追踪进入系统请求数的速率限制器

3067
01:50:33,566 --> 01:50:34,799
我们有一个边缘服务

3068
01:50:34,800 --> 01:50:37,433
我有一个边缘服务 一个速率限制器

3069
01:50:37,433 --> 01:50:39,333
这个速率限制器 现在 让我们假设

3070
01:50:39,600 --> 01:50:42,533
我们想控制并限制每秒请求次数到5

3071
01:50:44,000 --> 01:50:46,566
如果我创建另一个这样的边缘服务实例会怎样？

3072
01:50:46,566 --> 01:50:50,566
如果我将这个边缘服务的 JVM 线程

3073
01:50:50,966 --> 01:50:54,099
并将其部署 然后我现在有两个实例在负载均衡器后面