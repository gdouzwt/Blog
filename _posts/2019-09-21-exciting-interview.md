---
layout:     post
title:      一次刺激的面试和笔试
subtitle:   继续总结经验教训
date:       2019-09-21
author:     招文桃
header-img: img/post-bg-desk.jpg
catalog: true
tags:
    - 笔试面试
---





先记录一些错题回顾。不过这些不是在线笔试的错题，是日常练习的。

- 一个以".java"为后缀的源文件：

> 只能有一个与文件名相同的public类，可以包含其他非public类（不考虑内部类）

基础概念要清晰。

- 关于`equals()` 和 `hashcode()` 的，对象属性之类的东西。

下面论述正确的是（）？

> A. 如果两个对象的hashcode相同，那么它们作为同一个HashMap的key时，必然返回同样的值
> B. 如果a,b的hashcode相同，那么a.equals(b)必须返回true
> C. 对于一个类，其所有对象的hashcode必须不同
> D. 如果a.equals(b)返回true，那么a,b两个对象的hashcode必须相同

答案是 D

解释如下：

如果两个对象的hashcode相同，那么它们作为同一个HashMap的key时，必然返回同样的值。如果a,b的hashcode相同，那么a.equals(b)必须返回true，对于一个类，其所有对象的hashcode必须不同，
如果a.equals(b)返回true，那么a,b两个对象的hashcode必须相同。



- 关于计算机网络

如果在一个建立了TCP连接的socket上调用recv函数，返回值为0，则表示（）

> A. 对端发送了一段长度为0的数据
> B. 对端关闭了连接
> C. 还没有收到对端数据
> D. 连接发生错误

基础，对于TCP协议的认识，解阻塞与非阻塞recv返回值没有区分，都是

>  < 0 出错， 
>
> =0 连接关闭 
>
> 0 接收到数据太小



- 关于JavaBean的，还有一些JSP，旧的技术还没有完全淘汰，有时候有必要了解一下。





回顾某个笔试题目：

题目原表述和空间要求等已经记不清，凭回忆和草稿恢复题目如下：

输入 T 组数，格式为第 1 行是组数 T ，余下每行 1 个数 x ，对每个 x 求输出对应的 n ，满足 x <= $S(n)$  的最小值。其中 $S(n)$表示 n 的十进制各位之和， 1 <= T <= 10, 1 <= x <= 100000。

示例输入

> 2
>
> 13
>
> 18

示例输出

> 49
>
> 99

## Java实现

```java
import java.util.Scanner;

public class Exam1 {

    public static void main(String[] args) {

        Scanner stdIn = new Scanner(System.in);
        int T; // 组数

        do {
            System.out.print("请输入数据组数T(1 <= T <= 10)：");
            T = stdIn.nextInt();
        } while (T < 1 || T > 10);

        int[] x = new int[T]; // 输入的x

        for (int i = 0; i < T; i++) {
            do {
                System.out.printf("请输入第%2d 组的 x(1 <= x <= 100000)：", (i + 1));
                x[i] = stdIn.nextInt();
            } while (x[i] < 1 || x[i] > 100000);
        }

        for (int number : x) {
            System.out.print((number % 9 == 0) ? "" : (number % 9));
            for (int i = 0; i < number / 9; i++) {
                System.out.print(9);
            }
            System.out.println();
        }
    }
}
```

## 思考过程

考试的时候初步想法，输入数据组数 T ，接下来每组的数保存在长度为 T 的整型数组里面。 这只是输入数据的保存，接着就是核心算法部分，思考这个算法要做什么，要寻找什么规律，最终达到题目要求。

我是这样想的，首先实现对于每个 x 可以找到满足条件的 n ，接着再考虑怎么知道这个 n 是最小的，判断的依据是什么？功能实现完善了，再考虑优化时间复杂度或空间复杂度。

初步来看，随着 x 增大，符合条件的 n 将会是一个很大的数，位数肯定超过 Java 支持的数据类型上限，这就是要考虑到的问题。 但可以先从小数入手，先实现在 x 较小的情况下可以运行的程序，接着优化，添加可以处理大数的操作，使得在题目要求的数值范围内可以有效运行。最后才是细化优化。

后来观察了一下这些数字，发现规律很明显，不用很复杂的算法就可以实现了。首先题目要求对于给定的 x 要找到满足 x <= $S(n)$ 的 n 的最小值，所以最小就是 x = $S(n)$ 的情形。列出一些 x 和 对应的 n 如下：

> 1	...	8	9	10	11	12	...	28	
>
> 1	...	8	9	19	29	39	...	1999

发现满足要求的都是最高位是 1~8 其余位数全部是 9 的数字（不然不可能最小）。所以问题就转化成求 n 的最高位是什么，余下位数共有多少个 9 ，即最高位是 n % 9, 余下有 n / 9 个 9。 因为 x = 100000 的时候，满足条件的 n 长度是 “最高位的 1 ” + “ 后面11111 个 9 ”， 长度达到 11112 位。 因此用打印字符串作为结果输出。时间复杂度$O(n)$。

## 总结

不是什么难题，平时解题思维锻炼得少，有时候会将简单问题复杂化，所以多练，希望有提高。