<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>记录</title>
    <description></description>
    <link>https://zwt.io/</link>
    <atom:link href="https://zwt.io/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Wed, 18 Mar 2020 13:18:33 +0000</pubDate>
    <lastBuildDate>Wed, 18 Mar 2020 13:18:33 +0000</lastBuildDate>
    <generator>Jekyll v4.0.0</generator>
    
      <item>
        <title>RSocket与Spring Security简单整合</title>
        <description>&lt;h3 id=&quot;创建工程&quot;&gt;创建工程&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;greetings-service&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;在 start.spring.io 选择 2.3.0 M2 版本 Spring Boot，依赖项如下&lt;/p&gt;

      &lt;p&gt;Lombok&lt;/p&gt;

      &lt;p&gt;RSocket&lt;/p&gt;

      &lt;p&gt;Spring Security&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;greetings-client&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;客户端的依赖项也是&lt;/p&gt;

      &lt;p&gt;Lombok&lt;/p&gt;

      &lt;p&gt;RSocket&lt;/p&gt;

      &lt;p&gt;Spring Security&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;服务端应用&quot;&gt;服务端应用&lt;/h4&gt;

&lt;p&gt;GreetingsServiceApplication.java&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;// 省略导入
// 一个简单的，基于用户名和密码的“问候”应用
// 简单起见，所有类都写在一个文件里
@SpringBootApplication
public class GreetingsServiceApplication {

    public static void main(String[] args) {
        SpringApplication.run(GreetingsServiceApplication.class, args);
    }
}

@Configuration
@EnableRSocketSecurity
class RSocketSecurityConfiguration {

    @Bean
    RSocketMessageHandler messageHandler(RSocketStrategies strategies) {
        RSocketMessageHandler mh = new RSocketMessageHandler();
        mh.getArgumentResolverConfigurer()
            .addCustomResolver(new AuthenticationPrincipalArgumentResolver());
        mh.setRSocketStrategies(strategies);
        return mh;
    }

    // 授权
    @Bean
    PayloadSocketAcceptorInterceptor authorization(RSocketSecurity security) {
        return security
                .authorizePayload(spec -&amp;gt; spec
                        .route(&quot;greetings&quot;)
                        .authenticated()
                        .anyExchange()
                        .permitAll())
                .simpleAuthentication(Customizer.withDefaults())
                .build();
    }

    // 用户认证 Authentication
    @Bean
    MapReactiveUserDetailsService authentication() {
        UserDetails jlong = User.withDefaultPasswordEncoder().username(&quot;jlong&quot;)
            .password(&quot;pw&quot;).roles(&quot;USER&quot;).build();
        UserDetails rwinch = User.withDefaultPasswordEncoder().username(&quot;rwinch&quot;)
            .password(&quot;pw&quot;).roles(&quot;ADMIN&quot;, &quot;USER&quot;).build();
        return new MapReactiveUserDetailsService(jlong, rwinch);
    }
}

// DTO
@Data
@AllArgsConstructor
@NoArgsConstructor
class GreetingResponse {
    private String message;
}

@Controller
class GreetingController {

    @MessageMapping(&quot;greetings&quot;)
    Flux&amp;lt;GreetingResponse&amp;gt; greet(@AuthenticationPrincipal Mono&amp;lt;UserDetails&amp;gt; user) {
        return user
                .map(UserDetails::getUsername)
                .flatMapMany(GreetingController::greet);
    }

    private static Flux&amp;lt;GreetingResponse&amp;gt; greet(String name) {
        return Flux.fromStream(
                Stream.generate(() -&amp;gt; 
                new GreetingResponse(&quot;Hello &quot; + name + &quot; @ &quot; + 
                Instant.now().toString())))
                .delayElements(Duration.ofSeconds(1));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;服务端的配置文件&lt;/strong&gt;：application.properties&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-properties&quot;&gt;spring.rsocket.server.port=8888
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;客户端应用&quot;&gt;客户端应用&lt;/h4&gt;

&lt;p&gt;GreetingsClientApplication.java&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;@SpringBootApplication
@Log4j2
public class GreetingsClientApplication {

    @SneakyThrows
    public static void main(String[] args) {
        SpringApplication.run(GreetingsClientApplication.class, args);
        System.in.read(); // 让程序不要结束
    }

    private final MimeType mimeType =
            MimeTypeUtils.parseMimeType(WellKnownMimeType.MESSAGE_RSOCKET_AUTHENTICATION.getString());
    private final UsernamePasswordMetadata credentials = new UsernamePasswordMetadata(&quot;jlong&quot;, &quot;pw&quot;);

    // 配置所用编码器
    @Bean
    RSocketStrategiesCustomizer rSocketStrategiesCustomizer() {
        return strategies -&amp;gt; strategies.encoder(new SimpleAuthenticationEncoder());
    }

    // 相当于客户端
    @Bean
    RSocketRequester rSocketRequester(RSocketRequester.Builder builder) {
        return builder
                //.setupMetadata(this.credentials, this.mimeType)
                .connectTcp(&quot;localhost&quot;, 8888)
                .block();
    }

    // 应用就绪时通过RSocket向localhost:8888/greetings发起请求
    // 并将响应消息通过日志输出到控制台
    @Bean
    ApplicationListener&amp;lt;ApplicationReadyEvent&amp;gt; ready(RSocketRequester greetings) {
        return event -&amp;gt; greetings
                .route(&quot;greetings&quot;)
                .metadata(this.credentials, this.mimeType)
                .data(Mono.empty())
                .retrieveFlux(GreetingResponse.class)
                .subscribe(gr -&amp;gt; log.info(&quot;secured response: &quot; + gr.toString()));
    }
}

// DTO
@Data
@AllArgsConstructor
@NoArgsConstructor
class GreetingResponse {
    private String message;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;结束&quot;&gt;结束&lt;/h3&gt;

&lt;p&gt;感觉直接看代码也挺好理解的，就不勉强添加太多文字说明了。有什么不明白的，可以看&lt;a href=&quot;https://www.bilibili.com/video/av95256090&quot;&gt;视频讲解&lt;/a&gt;。&lt;/p&gt;

</description>
        <pubDate>Tue, 10 Mar 2020 21:00:00 +0000</pubDate>
        <link>https://zwt.io/2020/03/10/spring-tips-rsocket-spring-security/</link>
        <guid isPermaLink="true">https://zwt.io/2020/03/10/spring-tips-rsocket-spring-security/</guid>
        
        <category>RSocket</category>
        
        <category>Spring Security</category>
        
        <category>Authentication</category>
        
        
      </item>
    
      <item>
        <title>网络爬虫学习笔记</title>
        <description>&lt;h3 id=&quot;课程计划&quot;&gt;课程计划&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;入门&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;HttpClient&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Jsoup&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;案例&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;dependencies {
    implementation('org.jsoup:jsoup:1.12.2')
    implementation('org.apache.httpcomponents:httpclient:4.5.2')
  
    testImplementation('org.slf4j:slf4j-log4j12:1.7.25')
    testImplementation('org.junit.jupiter:junit-jupiter:5.6.0')
}
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;爬虫功能&quot;&gt;爬虫功能&lt;/h3&gt;

&lt;p&gt;从功能上来讲，爬虫一般分为数据采集，处理，存储三个部分。爬虫从一个或若干个初始页面的URL开始，获得初始页面上的URL，在抓取页面的过程中，不断从当前页面抽取新的URL放入队列，直到满足系统的一定停止条件。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;数据采集&lt;/li&gt;
  &lt;li&gt;处理&lt;/li&gt;
  &lt;li&gt;存储&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;从初始页面开始，爬取这个页面里面的详细页面连接，接着是下一页，等等。&lt;!--more--&gt;&lt;/p&gt;

&lt;h4 id=&quot;为什么学习网络爬虫&quot;&gt;为什么学习网络爬虫&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;可以实现搜索引擎&lt;/p&gt;

    &lt;p&gt;搜集，自己感兴趣的数据。做好玩的事情。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;大数据时代，获取更多数据源，人工智能&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;数据分析&lt;/li&gt;
      &lt;li&gt;数据挖掘&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;搜索引擎优化，网站推广，研究规则&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;就业，数据工程师，爬虫工程师， Microsoft Health,  Data mining&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;带参数的-get-请求&quot;&gt;带参数的 GET 请求&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;HttpGet&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;post-请求&quot;&gt;POST 请求&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;HttpPost 不带参数&lt;/li&gt;
  &lt;li&gt;带参数&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;[To be continued!]&lt;/p&gt;

</description>
        <pubDate>Mon, 02 Mar 2020 19:30:00 +0000</pubDate>
        <link>https://zwt.io/2020/03/02/web-scraping-notes/</link>
        <guid isPermaLink="true">https://zwt.io/2020/03/02/web-scraping-notes/</guid>
        
        <category>Java</category>
        
        <category>爬虫</category>
        
        <category>scraping</category>
        
        
      </item>
    
      <item>
        <title>OCP-1Z0-816 模拟测试1回顾</title>
        <description>&lt;h3 id=&quot;nio-2-files-class&quot;&gt;NIO 2 Files class&lt;/h3&gt;

&lt;p&gt;文件操作， &lt;code&gt;Files.copy&lt;/code&gt;方法&lt;/p&gt;

&lt;p&gt;However, &lt;code&gt;Files.isSameFile&lt;/code&gt; method doesn’t check the contents of the file. It is meant to check if the two path objects resolve to the same file or not. In this case, they are not, and so, it will return false.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public static Path copy(Path source, Path target, CopyOption... options) throws IOException
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;选项参数（options parameter)可以包括以下：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;REPLACE_EXISTING&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;​      If the target file exists, then the target file is replaced if it is not a non-empty directory. If the target file exists and is a symbolic link, then the symbolic link itself, not the target of the link, is replaced.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;COPY_ATTRIBUTES&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;​      Attempts to copy the file attributes associated with this file to the target file. The exact file attributes that are copied is platform and file system dependent and therefore unspecified. Minimally, the last-modified-time is copied to the target file if supported by both the source and target file store. Copying of file timestamps may result in precision loss.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;NOFOLLOW_LINKS&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;​      Symbolic links are not followed. If the file is a symbolic link, then the symbolic link itself, not the target of the link, is copied. It is implementation specific if file attributes can be copied to the new link.  In other words, the COPY_ATTRIBUTES option may be ignored when copying a symbolic link.&lt;br /&gt;
An implementation of this interface may support additional implementation specific options.
Coping a file is not an atomic operation. If an &lt;code&gt;IOException&lt;/code&gt; is thrown then it’s possible that the target file is incomplete or some of its file attributes have not been copied from the source file. When the REPLACE_EXISTING option is specified and the target file exists, then the target file is replaced. The check for the existence of the creation of the new file may not be atomic with respect to other file system activities. &lt;!--more--&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public static Path move(Path source, Path target, CopyOption... options) throws IOException
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Move or rename a file to a target file.
By default, this method attempts to move the file to the target file, failing if the target file exists except if the source and target are the same file, in which case this method has no effect. If the file is a symbolic link then the symbolic link itself, not the target of the link, is moved. This method may be invoked to move an empty directory. In some implementations a directory has entries for special files or links that are created when the directory is created. In such implementations a directory is considered empty when only the special entries exist. When invoked to move a directory that is not empty then the directory is moved if it does not require moving the entries in the directory. For example, renaming a directory on the same FileStore will usually not required moving the entries in the directory. When moving a directory requires that its entries be moved then this method fails (by throwing an &lt;code&gt;IOException&lt;/code&gt;). To move a file tree may involve copying rather than moving directories and this can be done using the copy method in conjunction with the &lt;code&gt;Files.walkFileTree&lt;/code&gt; utility method.&lt;/p&gt;

&lt;p&gt;The options parameter may include any of the following:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;REPLACE_EXISTING&lt;/strong&gt; If the target file exists, then the target file is replaced if it is not a non-empty directory. If the target file exists and is a symbolic link, then the symbolic link itself, not the target of the link, is replaced.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ATOMIC_MOVE&lt;/strong&gt; The move is performed as an atomic file system operation and all other options are ignored. If the target file exists then it is implementation specific if the existing file is replaced or this method fails by throwing an &lt;code&gt;IOException&lt;/code&gt;. If the move cannot be performed as an atomic file system operation then &lt;code&gt;AtomicMoveNotSupportedException&lt;/code&gt; is thrown. This can arise, for example, when the target location is on a different FileStore and would require that the file be copied, or target location is associated with a different provider to this object. An implementation of this interface may support additional implementation specific options.&lt;/p&gt;

&lt;p&gt;Where the move requires that the file be copied then the last-modified-time is copied to the new file. An implementation may also attempt to copy other file attributes but is not required to fail if the file attributes cannot be copied. When the move is performed as a non-atomic operation, and an &lt;code&gt;IOException&lt;/code&gt; is thrown, then the state of the files is not defined. The original file and the target file may both exist, the target file may be incomplete or some of its file attributes may not been copied from the original file.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Consider the following code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;class LowBalanceException extends ____ {  // 1
    public LowBalanceException(String msg) { super(msg); }
}

class WithdrawalException extends ____ { // 2 
    public WithdrawalException(String msg) { super(msg); }
}

class Account {
    double balance;
    public void withdraw(double amount) throws WithdrawalException {
        try {
            throw new RuntimeException(&quot;Not Implemented&quot;);
        } catch (Exception e) {
            throw new LowBalanceException( e.getMessage());
        }
    }
    public static void main(String[] args) {
        try {
            Account a = new Account();
            a.withdraw(100.0);
        } catch(Exception e) {
            System.out.println(e.getMessage());
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What can be inserted at // 1 and // 2 so that the above code will prints Not Implemented?&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Exception
Exception&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Exception
LowBalanceException&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;WithdrawalException
Exception&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;WithdrawalException
RuntimeException&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Explanation&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;The withdraw method declares that it throws WithdrawalException. This means that the only exceptions that can come out of this method are WithdrawalExceptions  (which means WithdrawalException or its subclasses) or RuntimeExceptions.&lt;/li&gt;
  &lt;li&gt;The try block in withdraw method throws a RuntimeException. It will be caught by the catch(Exception) block because RuntimeException is-a Exception. The code in the catch block throws a LowBalanceException, which is not caught. Thus, it will be thrown out of this method, which means LowBalanceException must either be a RuntimeException or be a WithdrawalException (i.e. must extend WithdrawalException) to satisfy the throws clause of the withdraw method.&lt;/li&gt;
  &lt;li&gt;The main() method does not have a throws clause but the call to withdraw() is enclosed within a try block with catch(Exception). Thus, WithdrawalException can extend either Exception or RuntimeException.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;[To be continued!]&lt;/p&gt;
</description>
        <pubDate>Wed, 26 Feb 2020 15:15:00 +0000</pubDate>
        <link>https://zwt.io/2020/02/26/ocp-mock-test1-review/</link>
        <guid isPermaLink="true">https://zwt.io/2020/02/26/ocp-mock-test1-review/</guid>
        
        <category>Java</category>
        
        <category>1Z0-816</category>
        
        <category>认证考试</category>
        
        
      </item>
    
      <item>
        <title>OCP 816 考点速记</title>
        <description>&lt;p&gt;&lt;strong&gt;Unmodifiable collections using of/copyOf and Collections.unmodifiableXXX methods&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;java.util.List&lt;/code&gt; and &lt;code&gt;java.util.Set&lt;/code&gt; have &lt;code&gt;of&lt;/code&gt; and &lt;code&gt;copyOf&lt;/code&gt; static factory methods that provide a convenient way to create unmodifiable lists/sets.&lt;/p&gt;

&lt;p&gt;The of methods accept either an array or multiple individual parameters. If you pass it a collection, it will be treated as a regular object i.e. it will return a list/set containing the same collection object instead of returning a list/set containing the objects that the passed collection contains.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;copyOf&lt;/code&gt;, on the other hand, accepts only a &lt;code&gt;Collection&lt;/code&gt;. It iterates through the passed &lt;code&gt;Collection&lt;/code&gt; and adds all the elements of that &lt;code&gt;Collection&lt;/code&gt; in the returned list/set. &lt;!--more--&gt;&lt;/p&gt;

&lt;p&gt;Here are a few important points about these methods:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;They return unmodifiable copies of the original List/Set. Thus, any operation that tries to modify the returned list throws an &lt;code&gt;java.lang.UnsupportedOperationException&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;The list/set returned by the &lt;code&gt;of/copyOf&lt;/code&gt; methods is completely independent of the original collection. Thus, if you modify the original collection after passing it to &lt;code&gt;of/copyOf&lt;/code&gt; methods, those changes will not be reflected in the list returned by the &lt;code&gt;of/copyOf&lt;/code&gt; methods.&lt;/li&gt;
  &lt;li&gt;They do not support &lt;code&gt;null&lt;/code&gt; elements. Thus, if your array contains a &lt;code&gt;null&lt;/code&gt; and if you try to create a &lt;code&gt;List&lt;/code&gt; using &lt;code&gt;List.of&lt;/code&gt;, it will throw a &lt;code&gt;NullPointerException&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;&lt;code&gt;Collections.unmodifiableXXX&lt;/code&gt; methods&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;java.utils.Collections&lt;/code&gt; class also has several variations of &lt;code&gt;unmodifiableXXX&lt;/code&gt; static methods (such as &lt;code&gt;unmodifiableList(List )&lt;/code&gt;, &lt;code&gt;unmodifiableSet(Set )&lt;/code&gt;, and &lt;code&gt;unmodifiableMap(Map )&lt;/code&gt; ). These method return an unmodifiable view of the underlying collection. The fundamental difference between &lt;code&gt;Collections.unmodifiableXXX&lt;/code&gt; and &lt;code&gt;List.of/copyOf&lt;/code&gt; methods is that &lt;code&gt;Collections.unmodifiableList&lt;/code&gt; returns a view (instead of a copy) into the underlying list. Which means, if you make any changes to the underlying list after creating the view, those changes will be visible in the view. Further, &lt;code&gt;Collections.unmodifiableList&lt;/code&gt; has no problem with nulls.&lt;/p&gt;

&lt;p&gt;The word unmodifiable in &lt;code&gt;unmodifiableXXX&lt;/code&gt; method name refers to the fact that you cannot modify the view using a reference to view.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;Top Down Approach for modularzing an application&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;While modularizing an app in a top-down approach, you need to remember the following points -&lt;/p&gt;

&lt;p&gt;\1. Any jar file can be converted into an automatic module by simply putting that jar on the module-path instead of the classpath. Java automatically derives the name of this module from the name of the jar file.&lt;/p&gt;

&lt;p&gt;\2. Any jar that is put on classpath (instead of module-path) is loaded as a part of the “unnamed” module.&lt;/p&gt;

&lt;p&gt;\3. An explicitly named module (which means, a module that has an explicitly defined name in its module-info.java file) can specify dependency on an automatic module just like it does for any other module i.e. by adding a requires &lt;code&gt;&amp;lt;module-name&amp;gt;;&lt;/code&gt; clause in its module info but it cannot do so for the unnamed module because there is no way to write a requires clause without a name. In other words, a named module can access classes present in an automatic module but not in the unnamed module.&lt;/p&gt;

&lt;p&gt;\4. Automatic modules are given access to classes in the unnamed module (even though there is no explicitly defined module-info and requires clause in an automatic module). In other words, a class from an automatic module will be able to read a class in the unnamed module without doing anything special.&lt;/p&gt;

&lt;p&gt;\5. An automatic module exports all its packages and is allowed to read all packages exported by other modules. Thus, an automatic module can access: all packages of all other automatic modules + all packages exported by all explicitly named modules + all packages of the unnamed module (i.e. classes loaded from the classpath).&lt;/p&gt;

&lt;p&gt;Thus, if your application jar &lt;strong&gt;A&lt;/strong&gt; directly uses a class from another jar &lt;strong&gt;B&lt;/strong&gt;, then you would have to convert &lt;strong&gt;B&lt;/strong&gt; into a module (either named or automatic). If &lt;strong&gt;B&lt;/strong&gt; uses another jar &lt;strong&gt;C&lt;/strong&gt;, then you can leave &lt;strong&gt;C&lt;/strong&gt; on the class path if &lt;strong&gt;B&lt;/strong&gt; hasn’t yet been migrated into a named module. Otherwise, you would have to convert &lt;strong&gt;C&lt;/strong&gt; into an automatic module as well.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;
There are two possible ways for an automatic module to get its name:
\1. When an Automatic-Module-Name entry is available in the manifest, its value is the name of the automatic module.
\2. Otherwise, a name is derived from the JAR filename (see the ModuleFinder JavaDoc for the derivation algorithm) - Basically, hyphens are converted into dots and the version number part is ignored. So, for example, if you put mysql-connector-java-8.0.11.jar on module path, its module name would be mysql.connector.java&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;Bottom Up Approach for modularzing an application&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;While modularizing an app using the bottom-up approach, you basically need to convert lower level libraries into modular jars before you can convert the higher level libraries. For example, if a class in &lt;strong&gt;A.jar&lt;/strong&gt; directly uses a class from &lt;strong&gt;B.jar&lt;/strong&gt;, and a class in &lt;strong&gt;B.jar&lt;/strong&gt; directly uses a class from &lt;strong&gt;C.jar&lt;/strong&gt;, you need to first modularize &lt;strong&gt;C.jar&lt;/strong&gt; and then &lt;strong&gt;B.jar&lt;/strong&gt; before you can modularize &lt;strong&gt;A.jar&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Thus, bottom up approach is possible only when the dependent libraries are modularized already.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;Java_Module_Execution_Options&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;You need to know about three command line options for running a class that is contained in a module:&lt;/p&gt;

&lt;p&gt;\1. &lt;strong&gt;–module-path&lt;/strong&gt; or -p: This option specifies the location(s) of the module(s) that are required for execution. This option is very versatile. You can specify exploded module directories, directories containing modular jars, or even specific modular or non-modular jars here. The path can be absolute or relative to the current directory. For example, –module-path c:/javatest/output/mathutils.jar or –module-path mathutils.jar&lt;/p&gt;

&lt;p&gt;You can also specify the location where the module’s files are located. For example, if your module is named abc.math.utils and this module is stored in c:\javatest\output, then you can use: –module-path c:/javatest/output. Remember that c:\javatest\output directory must contain abc.math.utils directory and the module files (including module-info.class) must be present in their appropriate directory structure under abc.math.utils directory.&lt;/p&gt;

&lt;p&gt;You can specify as many jar files or module locations separated by path separator (; on windows and : on *nix) as required.&lt;/p&gt;

&lt;p&gt;NOTE: -p is the short form for –module-path.(Observe the single and double dashes).&lt;/p&gt;

&lt;p&gt;\2. &lt;strong&gt;–module&lt;/strong&gt; or &lt;strong&gt;-m&lt;/strong&gt;: This option specifies the module that you want to run. For example, if you want to run abc.utils.Main class of abc.math.utils module, you should write –module abc.math.utils/abc.utils.Main
If a module jar specifies the Main-Class property its MANIFEST.MF file, you can omit the main class name from –module option. For example, you can write, –module abc.math.utils instead of –module abc.math.utils/abc.utils.Main.&lt;/p&gt;

&lt;p&gt;NOTE: -m is the short form for –module.(Observe the single and double dashes).&lt;/p&gt;

&lt;p&gt;Thus,
java –module-path mathutils.jar –module abc.math.utils/abc.utils.Main is same as
java -p mathutils.jar -m abc.math.utils/abc.utils.Main&lt;/p&gt;

&lt;p&gt;NOTE: It is possible to treat modular code as non-modular by ignoring module options altogether. For example, if you want to run the same class using the older classpath option, you can do it like this:
java -classpath mathutils.jar abc.utils.Main&lt;/p&gt;

&lt;p&gt;\3. &lt;strong&gt;-classpath&lt;/strong&gt;: Remember that modular code cannot access code present on the -classpath but “automatic modules” are an exception to this rule. When a non-modular jar is put on –module-path, it becomes an “automatic module” but it can still access all the modular as well as non-modular code. In other words, a class from an automatic module can access classes present on –module-path as well as on -classpath without having any “requires” clause (remember that there is no module-info in automatic modules).
Thus, if your modular jar A depends on a non-modular jar B, you have to put that non-modular jar B on –module-path. You must also add appropriate requires clause in your module A’s module-info otherwise compilation of your module will not succeed. Further, if the non-modular jar B depends on another non-modular jar C, then the non-modular jar C may be put on the classpath or module-path.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;Java_Module_Compilation_Options&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;For compiling a Java class that is part of a module, you need to remember the following five command line options:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;–module-source-path: This option is used to specify the location of the module source files. It should point to the parent directory of the directory where module-info.java of the module is stored. For example, if your module name is moduleA, then the module-info.java for this module would be in moduleA directory and if moduleA directory exists in src directory, then –module-source-path should contain the src directory i.e. –module-source-path src&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;If moduleA depends on another module named moduleB, and if moduleB directory exists in src2 directory, you can add this directory in –module-source-path as well i.e. –module-source-path src;src2. javac will compile the required files of src2 as well if the source code of moduleB is organized under src2 correctly.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;-d: This option is required when you use the –module-source-path option. It is used to specify the output directory. This is the directory where javac will generate the module’s package driven directory structure and the class files for the sources. For example, if you specify out as the output directory, javac will create a directory under out with the same name as the name of the module and will create class files with appropriate package driven directory structure under that directory.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;–module or -m: This option is used when you want to compile all the source files of a particular module. This option is helpful when you want to compile all the files at once without listing any of the source files of a module individually in the command.
For example, if you have two java files in moduleA, stored under moduleA\a\A1.java and moduleA\a\A2.java, you can compile both of them at the same time using the command: java –module-source-path src -d out –module moduleA
Javac will find out all the java source files under moduleA and compile all of them. It will create the class files under the output directory specified in -d option i.e. out. Thus, the out directory will now have two class files - moduleA/a/A1.class and moduleA/a/A2.class.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;–module-path or -p: This option specifies the location(s) of any other module upon which the module to be compiled depends and is very versatile. You can specify the exploded module directories, directories containing modular jars, or specific modular jars here. For example, if you want to compile moduleA and it depends on another module named abc.util packaged as utils.jar located in thirdpartymodules directory then your module-path can be thirdpartymodules or thirdpartymodules/utils.jar. That both the following two commands will work:&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;javac –module-source-path src –module-path thirdpartymodules -d out –module moduleA
and
javac –module-source-path src –module-path thirdpartymodules\utils.jar -d out –module moduleA&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;If your module depends on a non-modular third party jar, you need to do two things -Put that third party jar in –module-path.
Putting a non-modular jar in –module-path causes that jar to be loaded as an “automatic module”. The name of this module is assumed to be same as the name of the jar minus any version numbers. For example, if you put mysql-driver-6.0.jar in –module-path, it will be loaded as an automatic module with name mysql.driver. Name derivation is explained in detail in java.lang.module.ModuleFinder JavaDoc but for the exam, just remember that hyphens are converted into dots and the version number and extension part is removed.
It is also possible for a non-modular jar to specify its module name using Automatic-Module-Name: &lt;code&gt;&amp;lt;module name&amp;gt;&lt;/code&gt; entry to the jar’s MANIFEST.MF.Add a requires &lt;code&gt;&amp;lt;module-name&amp;gt;;&lt;/code&gt; clause in module-info of your module.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;-classpath&lt;/strong&gt;: This option is used for compilation of non-modular code. If you are compiling regular non-modular code but that code depends on some classes, then you can put those classes or jars on the classpath using -classpath option.
&lt;strong&gt;Note:&lt;/strong&gt; This option is not helpful for compilation of modular code because classes of a modular cannot see classes on classpath. Modular code can only see other modular code. That is why, non-modular classes have to be converted into “automatic modules” and put on –module-path as explained above.&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;enum points&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;You need to know the following facts about enums:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Enum constructor is always private. You cannot make it public or protected. If an enum type has no constructor declarations, then a private constructor that takes no parameters is automatically provided.&lt;/li&gt;
  &lt;li&gt;An enum is implicitly final, which means you cannot extend it.&lt;/li&gt;
  &lt;li&gt;You cannot extend an enum from another enum or class because an enum implicitly extends java.lang.Enum. But an enum can implement interfaces.&lt;/li&gt;
  &lt;li&gt;Since enum maintains exactly one instance of its constants, you cannot clone it. You cannot even override the clone method in an enum because java.lang.Enum makes it final.&lt;/li&gt;
  &lt;li&gt;Compiler provides an enum with two public static methods automatically - values() and valueOf(String). The values() method returns an array of its constants and valueOf() method tries to match the String argument exactly (i.e. case sensitive) with an enum constant and returns that constant if successful otherwise it throws java.lang.IllegalArgumentException.&lt;/li&gt;
  &lt;li&gt;By default, an enum’s toString() prints the enum name but you can override it to print anything you want.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The following are a few more important facts about java.lang.Enum which you should know:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;It implements java.lang.Comparable (thus, an enum can be added to sorted collections such as SortedSet, TreeSet, and TreeMap).&lt;/li&gt;
  &lt;li&gt;It has a method ordinal(), which returns the index (starting with 0) of that constant i.e. the position of that constant in its enum declaration.&lt;/li&gt;
  &lt;li&gt;It has a method name(), which returns the name of this enum constant, exactly as declared in its enum declaration.&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;AutoCloseable_points&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;You need to know the following points regarding try-with-resources statement for the exam:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;The resource class must implement java.lang.AutoCloseable interface. Many standard JDK classes such as implement java.io.Closeable interface, which extends java.lang.AutoCloseable.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;AutoCloseable has only one method - public void close() throws Exception.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Resources are closed at the end of the try block and before any catch or finally block.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Resources are not even accessible in the catch or finally block. For example:&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;try(Device d = new Device())
{
   d.read();
}finally{
   d.close(); //This will not compile because d is not accessible here.
}
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;Note that the try-with-resource was enhanced in Java 9 and it now allows you to use a variable declared before the try statement in the try-with-resource block. In this case, of course, the variable is accessible after the try block but the object referred to by it has been closed. For example, the following is valid since Java 9:&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;Device d = new Device();
try(d){ //valid since Java 9
  ...
}finally{
   d.close(); //this will compile but may not work correctly because the object referred to by d has already been closed.
}
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Resources are closed in the reverse order of their creation.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Resources are closed even if the code in the try block throws an exception.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;java.lang.AutoCloseable’s close() throws Exception but java.io.Closeable’s close() throws IOException.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;If code in try block throws exception and an exception also thrown while closing is resource, the exception thrown while closing the resource is suppressed. The caller gets the exception thrown in the try block.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;JDBC URL&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The format of a JDBC URL is : &lt;code&gt;jdbc:&amp;lt;subprotocol&amp;gt;:&amp;lt;subname&amp;gt;&lt;/code&gt;
where subprotocol defines the kind of database connectivity mechanism that may be supported by one or more drivers. The contents and syntax of the subname will depend on the subprotocol.&lt;/p&gt;

&lt;p&gt;Here are a few examples of commonly used urls for connecting to derby db (the Java database that comes bundled with various IDEs such as Netbeans) and Mysql:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;jdbc:derby:sample
jdbc:derby://localhost:1527/sample
jdbc:mysql://localhost:1527/sample
jdbc:mysql://192.168.0.100:3306/testdb&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Observe that a JDBC url always starts with jdbc: and has at least three components separated by a two colons.&lt;/p&gt;

&lt;p&gt;It also usually includes the hostname or address and the port number on which the database is listening for the requests but that is not necessary.&lt;/p&gt;

&lt;p&gt;Most drivers allow adding more options to the URL in the subname part, for example the following JDBC url for Oracle DB specifies the type of the jdbc driver : &lt;br /&gt;
jdbc:oracle:thin:@localhost:1521:testdb&lt;/p&gt;

&lt;p&gt;Userid and password are usually supplied separately from the URL but some drivers allow them to be specified in the URL itself. For example: &lt;br /&gt;
jdbc:oracle:thin:scott/mypassword@//myhost:1521/orcl&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;Command Line Switches for Assertions&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Although not explicitly mentioned in the exam objectives, OCP Java 11 Part 2 Exam requires you to know about the switches used to enable and disable assertions. Here are a few important points that you should know:&lt;/p&gt;

&lt;p&gt;Assertions can be enabled or disabled for specific classes and/or packages. To specify a class, use the class name. To specify a package, use the package name followed by “…” (three dots also known as ellipses):&lt;/p&gt;

&lt;p&gt;&lt;code&gt;java -ea:&amp;lt;class&amp;gt; myPackage.myProgram&lt;/code&gt;
&lt;code&gt;java -da:&amp;lt;package&amp;gt;... myPackage.myProgram&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;You can have multiple -ea/-da flags on the command line. For example, multiple flags allow you to enable assertions in general, but disable them in a particular package.
&lt;code&gt;java -ea -da:com.xyz... myPackage.myProgram&lt;/code&gt;
The above command enables assertions for all classes in all packages, but then the subsequent -da switch disables them for the com.xyz package and its subpackages.&lt;/p&gt;

&lt;p&gt;To enable assertion for one package and disable for other you can use:
&lt;code&gt;java -ea:&amp;lt;package1&amp;gt;... -da:&amp;lt;package2&amp;gt;... myPackage.myProgram&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;You can enable or disable assertions in the unnamed root package (i.e. the default package) using the following commands:
&lt;code&gt;java -ea:... myPackage.myProgram&lt;/code&gt;
&lt;code&gt;java -da:... myPackage.myProgram&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Note that when you use a package name in the ea or da flag, the flag applies to that package as well as its subpackages. For example,
&lt;code&gt;java -ea:com... -da:com.enthuware... com.enthuware.Main&lt;/code&gt;
The above command first enables assertions for all the classes in com as well as for the classes in the subpackages of com. It then disables assertions for classes in package com.enthuware and its subpackages.&lt;/p&gt;

&lt;p&gt;Another thing is that &lt;code&gt;-ea/-da&lt;/code&gt; do not apply to system classes. For system classes (i.e. the classes that come bundled with the JDK/JRE), you need to use &lt;code&gt;-enablesystemassertions/-esa&lt;/code&gt; or &lt;code&gt;-disablesystemassertions/-dsa&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Note that &lt;strong&gt;*** and ****&lt;/strong&gt; are not valid wildcards for including subpackages.&lt;/p&gt;

</description>
        <pubDate>Wed, 26 Feb 2020 01:15:00 +0000</pubDate>
        <link>https://zwt.io/2020/02/26/ocp-816-learning-points/</link>
        <guid isPermaLink="true">https://zwt.io/2020/02/26/ocp-816-learning-points/</guid>
        
        <category>Java</category>
        
        <category>1Z0-816</category>
        
        <category>认证考试</category>
        
        
      </item>
    
      <item>
        <title>816 基准测试回顾</title>
        <description>&lt;p&gt;The following are the details of the interface &lt;code&gt;ScheduledExecutorService&lt;/code&gt;:
All Superinterfaces:
 &lt;code&gt;Executor&lt;/code&gt;, &lt;code&gt;ExecutorService&lt;/code&gt;
All Known Implementing Classes:
 &lt;code&gt;ScheduledThreadPoolExecutor&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;An &lt;code&gt;ExecutorService&lt;/code&gt; that can schedule commands to run after a given delay, or to execute periodically.
The schedule     methods create tasks with various delays and return a task object that can     be used to cancel or check execution. The &lt;code&gt;scheduleAtFixedRate&lt;/code&gt; and  &lt;code&gt;scheduleWithFixedDelay&lt;/code&gt; methods create and execute tasks that run periodically until cancelled.&lt;!--more--&gt;&lt;/p&gt;

&lt;p&gt;Commands submitted using the &lt;code&gt;Executor.execute(java.lang.Runnable)&lt;/code&gt; and &lt;code&gt;ExecutorService.submit&lt;/code&gt; methods are scheduled with a requested delay of zero. Zero and negative delays (but not periods) are also allowed in schedule methods, and are treated as     requests for immediate execution.&lt;/p&gt;

&lt;p&gt;All schedule methods accept relative delays and periods as arguments, not absolute times or dates. It is a simple matter to transform an absolute time represented as a Date to the required form. For example, to schedule at a certain future date, you can use: &lt;code&gt;schedule(task, date.getTime() - System.currentTimeMillis(), TimeUnit.MILLISECONDS)&lt;/code&gt;. Beware however that expiration of a relative delay need not coincide with the current Date at which the task is enabled due to network time synchronization protocols, clock drift, or other factors. The Executors class provides convenient factory methods for the &lt;code&gt;ScheduledExecutorService&lt;/code&gt; implementations provided in this package.&lt;/p&gt;

&lt;p&gt;Following is a usage example that sets up a &lt;code&gt;ScheduledExecutorService&lt;/code&gt; to beep every ten seconds for an hour:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;import java.util.concurrent.*;
import static java.util.concurrent.TimeUnit.SECONDS;

public class BeeperControl {
    private final ScheduledExecutorService scheduler =
            Executors.newScheduledThreadPool(1);

    public void beepForAnHour() {
        final ScheduledFuture&amp;lt;?&amp;gt; beeperHandle =
                scheduler.scheduleAtFixedRate(() -&amp;gt;
                        System.out.println(&quot;beep&quot;), 0, 3, SECONDS);
    }

    public static void main(String[] args) {
        new BeeperControl().beepForAnHour();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;Which of the following statements are correct?&lt;/strong&gt;&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;A List stores elements in a Sorted Order.&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;List just keeps elements in the order in which they are added. For sorting, you’ll need some other interface such as a SortedSet.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;A Set keeps the elements sorted and a List keeps the elements in the order they were added.&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;A Set keeps unique objects without any order or sorting.&lt;/p&gt;

      &lt;p&gt;A List keeps the elements in the order they were added. A List may have non-unique elements.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;A SortedSet keeps the elements in the order they were added.&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;A SortedSet keeps unique elements in their natural order.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;An OrderedSet keeps the elements sorted.&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;There is no interface like OrderedSet&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;An OrderedList keeps the elements ordered.&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;There is no such interface. The List interface itself is meant for keeping the elements in the order they were added.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;A NavigableSet keeps the elements sorted.&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;A NavigableSet is a Sorted extended with navigation methods reporting closest matches for given search targets. Methods lower, floor, ceiling, and higher return elements respectively less than, or equal, greater than or equal, and greater than a given element, returning null if there is no such element.&lt;/p&gt;

      &lt;p&gt;Since NavigableSet is a SortedSet, it keeps the elements sorted.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;How many methods have to be provided by a class that is not abstract and that implements Serializable interface?&lt;/strong&gt;&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;0&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;Serializable interface does not declare any methods. That is why is also called as a “marker” interface.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;1&lt;/p&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;2&lt;/p&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;3&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;Simple rule to determine sorting order: spaces &amp;lt; numbers &amp;lt; uppercase &amp;lt; lowercase&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;Given that a code fragment has just created a JDBC Connection and has executed an update statement, which of the following statements is correct?&lt;/strong&gt;&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Changes to the database are pending a commit call on the connection.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Changes to the database will be rolled back if another update is executed without committing the previous update.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;Changes to the database will be committed right after the update statement has completed execution.&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;A Connection is always in auto-commit mode when it is created. As per the problem statement, an update was fired without explicitly disabling the auto-commit mode, the changes will be committed right after the update statement has finished execution.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Changes to the database will be committed when another query (update or select) is fired using the connection.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Explanation&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;When a connection is created, it is in auto-commit mode. i.e. auto-commit is enabled. This means that each individual SQL statement is treated as a transaction and is automatically committed right after it is completed. (A statement is completed when all of its result sets and update counts have been retrieved. In almost all cases, however, a statement is completed, and therefore committed, right after it is executed.)&lt;/p&gt;

&lt;p&gt;The way to allow two or more statements to be grouped into a transaction is to disable the auto-commit mode. Since it is enabled by default, you have to explicitly disable it after creating a connection by calling &lt;code&gt;con.setAutoCommit(false);&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;JDBC 默认开启了自动提交。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;Which statements concerning the relation between a non-static inner class and its outer class instances are true?&lt;/strong&gt;&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Member variables of the outer instance are always accessible to inner instances, regardless of their accessibility modifiers.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;Member variables of the outer instance can always be referred to using only the variable name within the inner instance.&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;This is possible only if that variable is not shadowed by another variable in inner class.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;More than one inner instance can be associated with the same outer instance.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;An inner class can extend its outer classes.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;A final outer class cannot have any inner classes.&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;There is no such rule.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;Which interfaces does java.util.NavigableMap extend directly or indirectly?&lt;/strong&gt;&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;&lt;code&gt;java.util.SortedSet&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;&lt;code&gt;java.util.Map&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;&lt;code&gt;java.util.SortedMap&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;&lt;code&gt;java.util.TreeMap&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;&lt;code&gt;TreeMap&lt;/code&gt; is a class that implements &lt;code&gt;NavigableMap&lt;/code&gt; interface. &lt;code&gt;ConcurrentSkipListMap&lt;/code&gt; is the other such class.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;&lt;code&gt;java.util.List&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Explanation&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;A &lt;code&gt;NavigableMap&lt;/code&gt; is a &lt;code&gt;SortedMap&lt;/code&gt; (which in turn extends Map) extended with navigation methods returning the closest matches for given search targets. Methods &lt;code&gt;lowerEntry&lt;/code&gt;, &lt;code&gt;floorEntry&lt;/code&gt;, &lt;code&gt;ceilingEntry&lt;/code&gt;, and &lt;code&gt;higherEntry&lt;/code&gt; return Map. Entry objects associated with keys respectively less than, less than or equal, greater than or equal, and greater than a give key, returning null if there is no such key. Similarly, methods &lt;code&gt;lowerKey&lt;/code&gt;, &lt;code&gt;ceilingKey&lt;/code&gt;, and &lt;code&gt;higherKey&lt;/code&gt; return only the associated keys.&lt;/p&gt;

&lt;p&gt;All of these methods are designed for locating, not traversing entries.&lt;/p&gt;

&lt;p&gt;A &lt;code&gt;NavigableMap&lt;/code&gt; may be accessed and traversed in either ascending or descending key order. The &lt;code&gt;descendingMap&lt;/code&gt; method returns a view of the map with the senses of all relational and directional methods inverted. The performance of ascending operations and views is likely to be faster than that of descending ones. Methods &lt;code&gt;subMap&lt;/code&gt;, &lt;code&gt;headMap&lt;/code&gt;, and &lt;code&gt;tailMap&lt;/code&gt; differ from the like-named &lt;code&gt;SortedMap&lt;/code&gt; methods in accepting additional arguments describing whether lower and upper bounds are inclusive versus exclusive. Submaps of any NavigableMap must implement the NavigableMap interface.&lt;/p&gt;

&lt;p&gt;This interface additionally defines methods &lt;code&gt;firstEntry&lt;/code&gt;, &lt;code&gt;pollFirstEntry&lt;/code&gt;, &lt;code&gt;lastEntry&lt;/code&gt;, and &lt;code&gt;pollLastEntry&lt;/code&gt; that return and/or remove the least and greatest mapping, if any exist, else returning null.&lt;/p&gt;

&lt;p&gt;Implementations of entry-returning methods are expected to return &lt;code&gt;Map.Entry&lt;/code&gt; pairs representing snapshots of mappings at the time they were produced, and thus generally do not support the optional &lt;code&gt;Entry.setValue&lt;/code&gt; method. Note however that it is possible to change mappings in the associated map using method put.&lt;/p&gt;

&lt;p&gt;Methods &lt;code&gt;subMap(K, K)&lt;/code&gt;, &lt;code&gt;headMap(K)&lt;/code&gt;, and &lt;code&gt;tailMap(K)&lt;/code&gt; are specified to return &lt;code&gt;SortedMap&lt;/code&gt; to allow existing implementations of &lt;code&gt;SortedMap&lt;/code&gt; to be compatibly retrofitted to implement &lt;code&gt;NavigableMap&lt;/code&gt;, but extensions and implementations of this interface are encouraged to override these methods to return &lt;code&gt;NavigableMap&lt;/code&gt;. Similarly, &lt;code&gt;SortedMap.keySet()&lt;/code&gt; can be overridden to return &lt;code&gt;NavigableSet&lt;/code&gt;.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;Which of the following standard functional interfaces is most suitable to process a large collection of int primitives and return processed data for each of them?&lt;/strong&gt;&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;&lt;code&gt;Function&amp;lt;Integer&amp;gt;&lt;/code&gt;&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;&lt;code&gt;IntFunction&lt;/code&gt;&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;&lt;code&gt;Consumer&amp;lt;Integer&amp;gt;&lt;/code&gt;&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;&lt;code&gt;IntConsumer&lt;/code&gt;&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;&lt;code&gt;Predicate&amp;lt;Integer&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Explanation&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Using the regular functional interfaces by parameterizing them to Integer is inefficient as compared to using specially designed interfaces for primitives because they avoid the cost of boxing and unboxing the primitives.&lt;/p&gt;

&lt;p&gt;Now, since the problem statement requires something to be returned after processing each int, you need to use a Function instead of a Consumer or a Predicate.&lt;/p&gt;

&lt;p&gt;Therefor, &lt;strong&gt;&lt;code&gt;IntFunction&lt;/code&gt;&lt;/strong&gt; is most appropriate in this case.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;In which of the following cases can the Console object be acquired?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;You had to select 1 option&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;When the JVM is started from an interactive command line with explicitly redirecting the standard input and output streams to Console.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;When the JVM is started from an interactive command line without redirecting the standard input and output streams.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;When the JVM is started in the background with the standard input and output streams directed to Console.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;When the JVM is started in the background without redirecting the standard input and output streams.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Explanation&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Whether a virtual machine has a console is dependent upon the underlying platform and also upon the manner in which the virtual machine is invoked. If the virtual machine is started from an interactive command line without redirecting the standard input and output streams then its console will exist and will typically be connected to the keyboard and display from which the virtual machine was launched. If the virtual machine is started automatically, for example by a background job scheduler, then it will typically not have a console.&lt;/p&gt;

&lt;p&gt;If this virtual machine has a console then it is represented by a unique instance of this class which can be obtained by invoking the &lt;code&gt;System.console()&lt;/code&gt; method. If no console device is available then an invocation of that method will return null.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Which of the following are wrapper classes for primitive types?&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;&lt;code&gt;java.lang.String&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;&lt;code&gt;java.lang.Void&lt;/code&gt;&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;There is Void class but it does not wrap any primitive type.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;&lt;code&gt;java.lang.Null&lt;/code&gt;&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;There is no Null class in java.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;&lt;code&gt;java.lang.Object&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;None of the above&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Explanation&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Frequently it is necessary to represent a value of primitive type as if it were an object. There are following wrapper classes for this purpose:&lt;/p&gt;

&lt;p&gt;Byte, Char, Character, Short, Integer, Long, Float, and Double.&lt;/p&gt;

&lt;p&gt;Note that Byte, Short, Integer, Long, Float and Double extend from Number which is an abstract class. An object of type Double, for example, contains a field whose type is double, representing that value in such a way that a reference to it can be stored in a variable of reference type. These classes also provide a number of methods for converting among primitive values, as well as supporting such standard methods as &lt;code&gt;equals&lt;/code&gt; and &lt;code&gt;hasCode&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;It is important to understand that objects of wrapper classes are immutable.&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Complete the following code so that it will print dick, harry, and tom in that order.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public class TestClass {
    public static void main(String[] args) {
        
        Set&amp;lt;String&amp;gt; holder = new TreeSet&amp;lt;&amp;gt;();
        holder.add(&quot;tom&quot;);
        holder.add(&quot;dick&quot;);
        holder.add(&quot;harry&quot;);
        holder.add(&quot;tom&quot;);
        printIt(holder);
    }
    public static void printIt(Collection&amp;lt;String&amp;gt; list) {
        for(String s : list) System.out.println(s);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Explanation&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The output is expected to contain unique items. This implies that you need to use a &lt;code&gt;Set&lt;/code&gt;. The output is also expected to be sorted. Thus, &lt;code&gt;TreeSet&lt;/code&gt; is the only option.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;printIt()&lt;/code&gt; method expects a Collection of Strings. Therefore, the reference type of holder can be &lt;code&gt;Collection&amp;lt;String&amp;gt;&lt;/code&gt; or any subclass of &lt;code&gt;Collection&amp;lt;String&amp;gt;&lt;/code&gt; such as &lt;code&gt;Set&amp;lt;String&amp;gt;&lt;/code&gt;. It cannot be &lt;code&gt;List&lt;/code&gt; or &lt;code&gt;ArrayList&lt;/code&gt; because the object on the right hand side is &lt;code&gt;TreeSet&lt;/code&gt;.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;Which of the following standard functional interface returns void?&lt;/strong&gt;&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;&lt;code&gt;Supplier&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;It takes no argument and returns an object.&lt;/p&gt;

    &lt;p&gt;&lt;code&gt;T get()&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;&lt;code&gt;Function&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;Represents a function that accepts one argument and produces a result.&lt;/p&gt;

    &lt;p&gt;&lt;code&gt;R apply(T t)&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;Applies this function to the given argument.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;&lt;code&gt;Predicate&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;It takes and argument and returns a boolean:&lt;/p&gt;

    &lt;p&gt;&lt;code&gt;boolean test(T t)&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;Evaluates this predicate on the given argument.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;&lt;code&gt;Consumer&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;Its functional method is:&lt;/p&gt;

    &lt;p&gt;&lt;code&gt;void accept(T t)&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;Performs this operation on the given argument.&lt;/p&gt;

    &lt;p&gt;It also has the following default method:&lt;/p&gt;

    &lt;p&gt;&lt;code&gt;default Consumer&amp;lt;T&amp;gt; andThen(Consumer&amp;lt;? super T&amp;gt; after)&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;Returns a composed &lt;code&gt;Consumer&lt;/code&gt; that performs, in sequence, this operation followed by the after operation.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;&lt;code&gt;UnaryOperator&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;Represents an operation on a single operand that produces a result of the same type as its operand. This is a specialization of &lt;code&gt;Function&lt;/code&gt; for the case where the operand and result are of the same type.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Explanation&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;You should go through the description of all the functional interfaces given here:&lt;/p&gt;

&lt;p&gt;https://docs.oracle.com/javase/8/docs/api/java/util/function/package-summary.html&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Which of the following switches is/are used for controlling the execution of assertions at run time?&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;&lt;code&gt;-ua&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;&lt;code&gt;-da&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;It is a short form for ‘disable assertions’.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;&lt;code&gt;-enableassertions&lt;/code&gt;&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;&lt;code&gt;-assert&lt;/code&gt;&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;&lt;code&gt;-keepassertions&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Explanation&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Although not explicitly mentioned in the exam objectives, OCP Java 11 Part 2 Exam requires you to know about the switches used to enable and disable assertions. Here are a few important points that you should know:&lt;/p&gt;

&lt;p&gt;Assertions can be enabled or disabled for specific classes and/or packages. To specify a class, use the class name. To specify a package, use the package name followed by “…“(three dots also known as ellipses):&lt;/p&gt;

&lt;p&gt;&lt;code&gt;java -ea:&amp;lt;class&amp;gt; myPackage.myProgram&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;java -da:&amp;lt;package&amp;gt;... myPackage.myProgram&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;You can have multiple &lt;code&gt;-ea/-da&lt;/code&gt; flags on the command line. For example, multiple flags allow you to enable assertions in general, but disable them in a particular package.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;java -ea -da:com.xyz... myPackage.myProgram&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;The above command enables assertions for all classes  in all packages, but then the subsequent &lt;code&gt;-da&lt;/code&gt; switch disables them for the &lt;code&gt;com.xyz&lt;/code&gt; package and its subpackages.&lt;/p&gt;

&lt;p&gt;To enable assertion for one package and disable for other you can use:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;java -ea:&amp;lt;package1&amp;gt;... -da:&amp;lt;package2&amp;gt;... myPackage.myProgram&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;You can enable or disable assertions in the unnamed root package (i.e. the default package) using the following commands:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;java -ea:... myPackage.myProgram&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;java -da:... myPackage.myProgram&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Note that when you use a package name in the &lt;code&gt;ea&lt;/code&gt; or &lt;code&gt;da&lt;/code&gt; flag, the flag applies to that package as well as its subpackages. For example,&lt;/p&gt;

&lt;p&gt;&lt;code&gt;java -ea:com... -da:com.enthuware... com.enthuware.Main&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;The above command first enables assertions for all the classes in &lt;code&gt;com&lt;/code&gt; as well as for the classes in the subpackages of &lt;code&gt;com&lt;/code&gt;. It then disables assertions for classes in package &lt;code&gt;com.enthuware&lt;/code&gt; and its subpackages.&lt;/p&gt;

&lt;p&gt;Another thing is that -ea/-da do not apply to system classes. For system classes (i.e. the classes that com bundled with the JDK/JRE), you need to use &lt;code&gt;-enablesystemassertions/-esa&lt;/code&gt; or &lt;code&gt;-disablesystemassertions/-dsa&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Note that * and ** are not valid wildcards for including subpackages.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Which of these statements concerning the use of standard collection interfaces are true?&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;None of the standard collection classes are thread safe.&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;Vector and Hashtable are.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;class HashSet implements SortedSet.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Collection classes implementing List cannot have duplicate elements.&lt;/p&gt;

    &lt;p&gt;List is meant for ordering of elements. Duplicates are allowed.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;ArrayList can only accommodate a fixed number of elements.&lt;/p&gt;

    &lt;p&gt;It grows as more elements are added.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;Some operations may throw an UnsupportedOperationException.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Explanation&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Some operations may throw an UnsupportedOperationException. This exception type is unchecked, and code calling these operations is not required to explicitly handle exceptions of this type.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Identify correct statements about the Java module system.&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;If a request is made to load a type whose package is not defined in any known module system will attempt to load it from the class path.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;The unnamed module can only access types present in the unnamed module.&lt;/p&gt;

    &lt;p&gt;The unnamed module reads every other module. In other words, a class in an unnamed module can access all exported types of all modules.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Code from a named module can access classes that are on the classpath.&lt;/p&gt;

    &lt;p&gt;A named module cannot access any random class from the classpath. If your named module requires access to a non-modular class, you must put the non-modular class/jar on module-path and load it as an automatic module. Further, you must also put an appropriate “requires” clause in your module-info.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;If a package is defined in both a named module and the unnamed module then the package in the unnamed module is ignored.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;An automatic module cannot access classes from the unnamed module.&lt;/p&gt;

    &lt;p&gt;Remember that named modules cannot access classes from the unnamed module because it is not possible for named module to declare dependency on the unnamed module.&lt;/p&gt;

    &lt;p&gt;But what if a named module needs to access a class from a non-modular jar? Well, you can put the non-modular jar on the module-path, thereby making it an automatic module. A named module can declare dependency on an automatic module using the requires clause.&lt;/p&gt;

    &lt;p&gt;Now, what if that jar in turn requires access to some other class from another third party non-modular jar? Here, the original modular jar doesn’t directly access the non-modular jar, so it may not be wise to create an automatic module out of all such third party jars. This is where the -classpath options is helpful.&lt;/p&gt;

    &lt;p&gt;In addition to reading every other named module, an automatic module is also made to read the unnamed module. Thus, while running a modular application, the classpath option can be used to enable automatic modules to access third party non-modular jars.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Explanation&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bottom Up Approach for modularizing an application&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;While modularizing an app using the bottom-up approach, you basically need to convert lower level libraries into modular jars before you can convert the higher level libraries. For example, if a class in &lt;strong&gt;A.jar&lt;/strong&gt; directly uses a class from &lt;strong&gt;B.jar&lt;/strong&gt;, and a class in &lt;strong&gt;B.jar&lt;/strong&gt; directly uses a class from &lt;strong&gt;C.jar&lt;/strong&gt;, you need to first modularize &lt;strong&gt;C.jar&lt;/strong&gt; and then &lt;strong&gt;B.jar&lt;/strong&gt; before you can modularize &lt;strong&gt;A.jar&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Thus, bottom up approach is possible only when the dependent libraries are modularized already.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Top Down Approach for modularzing an application&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;While modularizing an app in a top-down approach, you need to remember the following points -&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Any jar file can be converted into an automatic module by simply putting that jar on the &lt;em&gt;module-path&lt;/em&gt; instead of the &lt;em&gt;classpath&lt;/em&gt;. Java automatically derives the name of this module from the jar file.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Any jar that is put on classpath(instead of &lt;em&gt;module-path&lt;/em&gt;) is loaded as part of the “unnamed” module.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;An explicitly named module (which means, a module that has an explicitly defined name in its &lt;em&gt;module-info.java&lt;/em&gt; file) can specify dependency on an automatic module just like it does for any other module i.e. by adding a &lt;code&gt;requires &amp;lt;module-name&amp;gt;;&lt;/code&gt; clause in its module info but it cannot do so for the unnamed module because there is no way to write a &lt;code&gt;requires&lt;/code&gt; clause without a name. In other words, named module can access classes present in an automatic module but not in the unnamed module.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Automatic modules are given access to classes in the unnamed module (even though there is no explicitly defined module-info and requires clause in an automatic module). In other words, a class from an automatic module will be able to read a class in the unnamed module without doing anything special.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;An automatic module exports all its packages and is allowed to read all packages exported by other modules. Thus, an automatic module can access: all packages of all other automatic modules + all packages exported by all explicitly named modules + all packages of the unnamed module (i.e. classes loaded from the classpath).&lt;/p&gt;

    &lt;p&gt;Thus, if your application jar &lt;strong&gt;A&lt;/strong&gt; directly uses a class from another jar &lt;strong&gt;B&lt;/strong&gt;, then you would have to convert &lt;strong&gt;B&lt;/strong&gt; into a module (either named or automatic). If &lt;strong&gt;B&lt;/strong&gt; uses another jar &lt;strong&gt;C&lt;/strong&gt;, then you can leave &lt;strong&gt;C&lt;/strong&gt; on the class path if &lt;strong&gt;B&lt;/strong&gt; hasn’t yet been migrated into a named module. Otherwise, you would have to convert &lt;strong&gt;C&lt;/strong&gt; into an automatic module as well.&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;There are two possible ways for an automatic module to get its name:&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;When an Automatic-Module-Name entry is available in the manifest, its value is the name of the automatic module.&lt;/li&gt;
      &lt;li&gt;Otherwise, a name is derived from the JAR filename (see the ModuleFinder JavaDoc for the derivation algorithm) - Basically, hyphens are converted into dots and the version number part is ignored. So, for example, if you put &lt;code&gt;mysql-connector-java-8.0.11.jar&lt;/code&gt; on module path, its module name would be &lt;code&gt;mysql.connector.java&lt;/code&gt;&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;p&gt;Using a &lt;code&gt;Callable&lt;/code&gt; would be more appropriate than using a &lt;code&gt;Runnable&lt;/code&gt; in which of the following situations?&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;When you want to execute a task directly in a separate thread.&lt;/p&gt;

    &lt;p&gt;A Callable cannot be passed to Thread for Thread creation but a Runnable can be. i.e. &lt;code&gt;new Thread(aRunnable);&lt;/code&gt; is valid. But &lt;code&gt;new Thread(aCallable);&lt;/code&gt; is not. Therefore, if you want to execute a task directly in a Thread, a &lt;code&gt;Callable&lt;/code&gt; is not suitable. You will need to use a &lt;code&gt;Runnable&lt;/code&gt;. You can achieve the same by using an &lt;code&gt;ExecutorService.submit(aCallable)&lt;/code&gt; , but in this case, you are not controlling the Thread directly.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;When your task might throw a checked exception and you want to execute it in a separate Thread.&lt;/p&gt;

    &lt;p&gt;&lt;code&gt;Callable.call()&lt;/code&gt; allows you to declare checked exceptions while &lt;code&gt;Runnable.run()&lt;/code&gt; does not. So if your task throws a checked exception, it would be more appropriate to use a &lt;code&gt;Callable&lt;/code&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;When your task does not return any result but you want to execute the task asynchronously.&lt;/p&gt;

    &lt;p&gt;Both &lt;code&gt;Callable&lt;/code&gt; and &lt;code&gt;Runnable&lt;/code&gt; can be used to execute a task asynchronously. If the task does not return any result, neither is more appropriate than the other. However, if the task returns a result, which you want to collect asynchronously later, &lt;code&gt;Callable&lt;/code&gt; is more appropriate.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;When you want to use &lt;code&gt;ExecutorService&lt;/code&gt; to submit multiple instance of a task.&lt;/p&gt;

    &lt;p&gt;Both can be used with an &lt;code&gt;ExecutorService&lt;/code&gt; because has overloaded submit methods:&lt;/p&gt;

    &lt;p&gt;&lt;code&gt;&amp;lt;T&amp;gt; Future&amp;lt;T&amp;gt; submit(Callable&amp;lt;T&amp;gt; task)&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;and&lt;/p&gt;

    &lt;p&gt;&lt;code&gt;Future&amp;lt;?&amp;gt; submit(Runnable task)&lt;/code&gt; Observe that even though a Runnable’s &lt;code&gt;run()&lt;/code&gt; method cannot return a value, the &lt;code&gt;ExecutorService.submit(Runnable)&lt;/code&gt; returns a &lt;code&gt;Future&lt;/code&gt;. The Future’s get method will return &lt;code&gt;null&lt;/code&gt; upon successful completion.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Explanation&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;public interface Callable&amp;lt;V&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;A task that returns a result and may throw an exception. Implementers define a single method with no arguments called call -&lt;/p&gt;

&lt;p&gt;V call() throws Exception&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;Callable&lt;/code&gt; interface is similar to &lt;code&gt;Runnable&lt;/code&gt;, in that both are designed for classes whose instances are potentially executed by another thread. A &lt;code&gt;Runnable&lt;/code&gt;, however, does not return a result and cannot throw a checked exception.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;65 Which of the following collection implementations are thread-safe?&lt;/strong&gt;&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;ArrayList&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;HashSet&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;HashMap&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;TreeSet&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;None of the above&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Explanation&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Of all the collection classes of the &lt;code&gt;java.util&lt;/code&gt; package, only &lt;code&gt;Vector&lt;/code&gt; and &lt;code&gt;Hashtable&lt;/code&gt; are Thread-safe. &lt;code&gt;java.util.Collection&lt;/code&gt; class contains a &lt;code&gt;synchronizedCollection&lt;/code&gt; method that creates thread-safe instances based on collections which are not.&lt;/p&gt;

&lt;p&gt;For example:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Set s = Collections.synchronizedSet(new HashSet());&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;From Java 1.5 onwards, you can also use a new Concurrent library available in &lt;code&gt;java.util.concurrent&lt;/code&gt; package, which contains interfaces/classes such as ConcurrentMap/ConcurrentHashMap. Classes in this package offer better performance than objects returned from &lt;code&gt;Collections.synchronizedXXX&lt;/code&gt; methods.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;Complete the code so that a Portfolio object can be serialized and deserialized properly.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这题主要考察序列化与反序列化，正确答案如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;

public class Bond {
    String ticker = &quot;bac&quot;;
    double coupon = 8.3;
}
class Portfolio implements Serializable {
    String accountName;
    transient Bond bond = new Bond();

    private void writeObject(ObjectOutputStream os) throws Exception {
        os.defaultWriteObject();
        os.writeObject(bond.ticker);
        os.writeDouble(bond.coupon);
    }
    private void readObject(ObjectInputStream os) throws Exception {
        os.defaultReadObject();
        this.bond = new Bond();
        bond.ticker = (String) os.readObject();
        bond.coupon = os.readDouble();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Explanation&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Bond class does not implement Serializable. Therefore, for Portfolio to be serialized, ‘bond’ must be transient.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;writeObject&lt;/code&gt; method takes &lt;code&gt;ObjectOutputStream&lt;/code&gt; as the only parameter, while &lt;code&gt;readObject&lt;/code&gt; method takes &lt;code&gt;ObjectInputStream&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;To serialize the object using the default behavior, you must call &lt;code&gt;objectOutputStream.defaultWriteObject();&lt;/code&gt; or &lt;code&gt;objectOutputStream.writeFields();&lt;/code&gt;. This will ensure that instance field of Portfolio object are serialized.&lt;/li&gt;
  &lt;li&gt;To deserialize the object using the default behavior, you must call &lt;code&gt;objectInputStream.defaultReadObject();&lt;/code&gt; or &lt;code&gt;objectInputStream.readFields();&lt;/code&gt;. This will ensure that instance fields of Portfolio object are deserialized.&lt;/li&gt;
  &lt;li&gt;The order of values to be read explicitly in &lt;code&gt;readObject&lt;/code&gt; must be exactly the same as the order they were written in &lt;code&gt;writeObject&lt;/code&gt;. Here, ticker was written before coupon and so ticker must be read before coupon.&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;Which of the following are standard annotations used to suppress various warnings generated by the compiler?&lt;/strong&gt;&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;&lt;code&gt;@SuppressWarning(&quot;rawtypes&quot;)&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;&lt;code&gt;@SupressWarning( {&quot;deprecation&quot;, &quot;unchecked&quot;} )&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;&lt;code&gt;@SupressWarning(&quot;deprecation&quot;, &quot;unchecked&quot;)&lt;/code&gt;&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;Syntax is incorrect because this annotation takes only one value type String array. So, if you want to pass multiple string values, you must pass an array containing those values.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;&lt;code&gt;@SafeVarargs&lt;/code&gt;&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;This can be used on a constructor or a method. If a constructor or a method tries to perform unsafe operations involving a var args parameter and a parameterized collection, a warning is generated. This annotation suppresses that warning. Example:&lt;/p&gt;

      &lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;@SafeVarargs // Not actually safe but still suppresses the warning
static void m(List&amp;lt;String&amp;gt;... stringList) {
    Object[] array = stringLists;
    List&amp;lt;Integer&amp;gt; temList = Arrays.asList(42);
    array[0] = temList; // Semantically invalid, but compiles without warnings because of the annotation
    String s = stringLists[0].get(0);  // Oh no, ClassCastException at runtime!
}
&lt;/code&gt;&lt;/pre&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;&lt;code&gt;@Override&lt;/code&gt;&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;This annotation is used only on methods. It causes a warning to be generated if a method does not actually override any method from the base class. It does not suppress any warning.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;&lt;code&gt;@Deprecated&lt;/code&gt;&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;This annotation causes a warning to be generated. It does not suppress any warning.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Explanation&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;As per JLS 11 section 9.6.4.5, &lt;code&gt;@SuppressWarning&lt;/code&gt; must support three values: &lt;code&gt;unchecked&lt;/code&gt;, &lt;code&gt;deprecation&lt;/code&gt;, and &lt;code&gt;removal&lt;/code&gt;. However, it is not an error if you use a value that is not supported by the compiler. A compiler simply ignores it.&lt;/p&gt;

&lt;p&gt;Different compilers may support more values. For example, Oracle’s javac compiler supports a large number of values (https://docs.oracle.com/en/java/javase/11/tools/javac.html). The ones that you should be aware of for the exam are: &lt;code&gt;none&lt;/code&gt;, &lt;code&gt;rawtypes&lt;/code&gt;, &lt;code&gt;serial&lt;/code&gt;, and &lt;code&gt;varargs&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;This annotation is not repeatable. Therefore, you cannot use it twice on the same type. However, you can specify multiple values like this: &lt;code&gt;@SupressWarning({ &quot;deprecation&quot;, &quot;unchecked&quot;} )&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;You are implementing a special sorting algorithm that can sort objects of different classes. Which of the following class declarations will you use?&lt;/strong&gt;&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;&lt;code&gt;java
public class SpecialSorter&amp;lt;&amp;gt; {
    ...
}
&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;&lt;code&gt;java
public class SpecialSorter&amp;lt;K&amp;gt; {
    ...
}
&lt;/code&gt;&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;This is the correct way to define a generic class. Within the class, you can use K as a type, for example:&lt;/p&gt;

      &lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public class SpecialSorter&amp;lt;K&amp;gt; {
    public void sort(ArrayList&amp;lt;K&amp;gt; items) {
        K item = items.get(0);
        // ...
    }
}
&lt;/code&gt;&lt;/pre&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;&lt;code&gt;java
public class &amp;lt;SpecialSorter&amp;gt; {
    ...
}
&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;&lt;code&gt;java
public class SpecialSorter(K) {
    ...
}
&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;Which of the following statements are true?&lt;/strong&gt;&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;A nested class may be declared static.&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;FYI, JLS defines the following terminology in Chapter 8:&lt;/p&gt;

      &lt;p&gt;A top level class is a class that is not a nested class.&lt;/p&gt;

      &lt;p&gt;A nested class is any class whose declaration occurs within the body of another class or interface.&lt;/p&gt;

      &lt;p&gt;An inner class is a class that is not explicitly or implicitly declared static.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Anonymous inner class may be declared public.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Anonymous inner class may be declared private.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Anonymous inner class may be declared protected.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;Anonymous inner class may extend an abstract class.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Explanation&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;abstract class SomeClass { public abstract void ml(); }
public class TestClass
{
    public static class StaticInnetClass { } //option1
    public SomeClass getSomeClass()
    {
        return new SomeClass()
        {
            public void ml() {}
        };
	}
}
//Here, the anonymous class created inside the method extends the abstract class SomeClass.
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;Which of the following options can be a part of a correct inner class declaration or a combined declaration and instance initialization? (Assume that &lt;code&gt;SimpleInterface&lt;/code&gt; and &lt;code&gt;ComplexInterface&lt;/code&gt; are interfaces.)&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;&lt;code&gt;java
private class C { }
&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;&lt;code&gt;java
new SimpleInterface() {
    // valid code
}
&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;&lt;code&gt;java
new ComplexInterface(x) {
    // valid code
}
&lt;/code&gt;&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;You cannot pass parameters when you implement an interface by anonymous class.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;&lt;code&gt;java
private final abstract class C { }
&lt;/code&gt;&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;A final class can never be abstract.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;&lt;code&gt;java
new ComplexClass() implements SimpleInterface { }
&lt;/code&gt;&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;‘implements’ part comes only in class definition not in instantiation.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;Which of the following statements are true?&lt;/strong&gt;&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Package member classes can be declared static.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;Classes declared as members of top-level classes can be declared static.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Local classes can be declared static.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;Anonymous classes cannot be declared static.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;No type of class can be declared static.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Explanation&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The modifier static pertains only to member classes, not to top level or local or anonymous classes. That is, only classes declared as member of top-level classes can be declared static. Package member classes, local classes (i.e. classes declared in methods) and anonymous classes cannot be declared static.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;How will you initialize a &lt;code&gt;SimpleDateFormat&lt;/code&gt; object to that the following code will print the full name of the month of the given date?&lt;/strong&gt;&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;&lt;code&gt;SimpleDateFormat sdf = new SimpleDateFormat(&quot;MMMM&quot;, Locale.FRANCE);&lt;/code&gt;&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;Upper case M is for Month. For example, for February and December, the following will be printed:
M =&amp;gt; 2, 12&lt;br /&gt;
MM =&amp;gt; 02, 12&lt;br /&gt;
MMM =&amp;gt; févr., déc.&lt;br /&gt;
MMMM =&amp;gt; février, décembre&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;&lt;code&gt;SimpleDateFormat sdf = new SimpleDateFormat(&quot;M*&quot;, Locale.FRANCE);&lt;/code&gt;&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;M* will print the month number (i.e. 2 for Feb and 12 for Dec), followed by *. For example, 2* or 12*&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;&lt;code&gt;SimpleDateFormat sdf = new SimpleDateFormat(&quot;mmmm&quot;, Locale.FRANCE);&lt;/code&gt;&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;Lower case m is for minutes. So mmmm will print the current minute, where the first two digits will always be zero. For example, 0032 or 0002.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;&lt;code&gt;SimpleDateFormat sdf = new SimpleDateFormat(&quot;mmm&quot;, Locale.FRANCE);&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;&lt;code&gt;SimpleDateFormat sdf = new SimpleDateFormat(&quot;MM&quot;, Locale.FRANCE);&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Explanation&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;For the purpose of the exam, you need to know the basic codes for printing out a date. The important ones are m, M, d, D, e, y, s, S, h, H, and z.&lt;br /&gt;
You should check the complete details of these patterns here:&lt;br /&gt;
https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/time/format/DateTimeFormatter.html&lt;/p&gt;

&lt;p&gt;The important point to understand is how the length of the pattern determines the output of text and numbers.&lt;/p&gt;

&lt;p&gt;Text: The text style is determined based on the number of pattern letters used. Less than 4 pattern letters will use the short form. Exactly 4 pattern letters will use the full form. Exactly 5 pattern letters will use the narrow form. Pattern letters ‘L’, ‘c’, and ‘q’ specify the stand-alone from of the text styles.&lt;/p&gt;

&lt;p&gt;Number: If the count of letters is one, then the value is output using the minimum number of digits and without padding. Otherwise, the count of digits is used as the width of the output field, with the value zero-padded as necessary. The following pattern letters have constrains on the count of letters. Only one letter of ‘c’ and ‘F’ can be specified. Up to two letters of ‘d’, ‘H’, ‘h’, ‘K’, ‘k’, ‘m’, and ‘s’ can be specified. Up to three letters of ‘D’ can be specified.&lt;/p&gt;

&lt;p&gt;Number/Text: If the count of pattern letters is 3 or greater, use the Text rules above. Otherwise use the Number rules above.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;Code that uses generic collection classes can interoperate with code that uses raw collections classes because of?&lt;/strong&gt;&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;type erasure&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;Type erasure means that a compiled java class does not contain any of the generic information that is present in the java file. In other words, the compiler removes the generic information from a java class when it compile it into byte code. For example, &lt;code&gt;List&amp;lt;String&amp;gt; list;&lt;/code&gt; and &lt;code&gt;List list;&lt;/code&gt; are compiled to the same byte code. Therefore, at run time, it does not matter whether you’ve used generic classes or not and this kinds of classes to interoperate because they are essentially the same class to the JVM.&lt;/p&gt;

      &lt;p&gt;Type erasure ensure that no new classes are created for parameterized types; consequently, generics incur no runtime overhead.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;reification&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;This is just the opposite of type erasure. Here, all the type information is preserved in the byte code. In Java, arrays are reified. For example,&lt;/p&gt;

      &lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;ArrayList[] alArray = new ArrayList[1];
Collection[] cArray = alArray;
cArray[0] = new HashSet();
&lt;/code&gt;&lt;/pre&gt;

      &lt;p&gt;The above code will compile fine. But it will throw an &lt;code&gt;java.lang.ArrayStoreException&lt;/code&gt; at run time because the byte code contains the information that &lt;code&gt;cArray&lt;/code&gt; actually points to an array of &lt;code&gt;ArrayList&lt;/code&gt;s and not of &lt;code&gt;HasSet&lt;/code&gt;s.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;just in time compilation&lt;/p&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;byte code instrumentation&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;字节码操作好像有点意思。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Which variables declared in the encapsulating class or in the method, can an inner class access if the inner class is defined in a static method of encapsulating class?&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;All static variables&lt;/p&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;All final instance variables&lt;/p&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;All instance variables&lt;/p&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;All automatic variables&lt;/p&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;All final or effectively final static or automatic variables&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;An effectively final variable means even though it is not declared final, it is never assigned a value again throughout the code after being assigned a value at the time of declaration.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Explanation&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Consider the following code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public class TestClass
{
    static int si = 10; int ii = 20;
    public static void inner()
    {
        int ai = 30; // automatic variable
        ai = 31; // ai is not effectively final anymore.
        final int fai = 40; // automatic final variable
        class Inner
        {
            public Inner() { System.out.println(si+&quot;    &quot;+fai);  }
        }
        new Inner();
    }
    public static void main(String[] args) { TestClass.inner(); }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since method &lt;code&gt;inner()&lt;/code&gt; is a static method, only &lt;code&gt;si&lt;/code&gt; and &lt;code&gt;fai&lt;/code&gt; are accessible in class Inner. Note that &lt;code&gt;ai&lt;/code&gt; and &lt;code&gt;ii&lt;/code&gt; are not accessible. If method &lt;code&gt;inner()&lt;/code&gt; were a non-static, &lt;code&gt;ii&lt;/code&gt; would have been accessible. If the line &lt;code&gt;ai = 31;&lt;/code&gt; did not exist, &lt;code&gt;ai&lt;/code&gt; would have been accessible.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Which of the following command line switches is required for the assert statements to be executed while running a Java class?&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;&lt;code&gt;ea&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;&lt;code&gt;ua&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;&lt;code&gt;a&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;No switch is needed, they are on by default.&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;No, assertions are turned off by default.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;&lt;code&gt;source&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Explanation&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Although not explicitly mentioned in the exam objectives, OCP Java 11 Part 2 Exam requires you to know about the switches used to enable and disable assertions. Here are a few important points that you should know:&lt;/p&gt;

&lt;p&gt;Assertions can be enabled or disabled for specific classes and/or packages. To specify a class, use the class name. To specify a package, use the package name followed by “…“(three dots also known as ellipses):&lt;/p&gt;

&lt;p&gt;&lt;code&gt;java -ea:&amp;lt;class&amp;gt; myPackage.myProgram&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;java -da:&amp;lt;package&amp;gt;... myPackage.myProgram&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;You can have multiple &lt;code&gt;-ea/-da&lt;/code&gt; flags on the command line. For example, multiple flags allow you to enable assertions in general, but disable them in a particular package.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;java -ea -da:com.xyz... myPackage.myProgram&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;The above command enables assertions for all classes  in all packages, but then the subsequent &lt;code&gt;-da&lt;/code&gt; switch disables them for the &lt;code&gt;com.xyz&lt;/code&gt; package and its subpackages.&lt;/p&gt;

&lt;p&gt;To enable assertion for one package and disable for other you can use:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;java -ea:&amp;lt;package1&amp;gt;... -da:&amp;lt;package2&amp;gt;... myPackage.myProgram&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;You can enable or disable assertions in the unnamed root package (i.e. the default package) using the following commands:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;java -ea:... myPackage.myProgram&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;java -da:... myPackage.myProgram&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Note that when you use a package name in the &lt;code&gt;ea&lt;/code&gt; or &lt;code&gt;da&lt;/code&gt; flag, the flag applies to that package as well as its subpackages. For example,&lt;/p&gt;

&lt;p&gt;&lt;code&gt;java -ea:com... -da:com.enthuware... com.enthuware.Main&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;The above command first enables assertions for all the classes in &lt;code&gt;com&lt;/code&gt; as well as for the classes in the subpackages of &lt;code&gt;com&lt;/code&gt;. It then disables assertions for classes in package &lt;code&gt;com.enthuware&lt;/code&gt; and its subpackages.&lt;/p&gt;

&lt;p&gt;Another thing is that -ea/-da do not apply to system classes. For system classes (i.e. the classes that com bundled with the JDK/JRE), you need to use &lt;code&gt;-enablesystemassertions/-esa&lt;/code&gt; or &lt;code&gt;-disablesystemassertions/-dsa&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Note that * and ** are not valid wildcards for including subpackages.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;Which of the following is/are valid functional interface?&lt;/strong&gt;&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;&lt;code&gt;java
interface F {
    default void m() {}
}
&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;It is not a valid functional interface because it does not have an abstract method.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;&lt;code&gt;java
interface F {
    default void m() {}
    static void n() {}
}
&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;It is not a valid functional interface because it does not have an abstract method.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;&lt;code&gt;java
interface F {
    void m();
    void n();
}
&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;It is not a valid functional interface because it has more than one abstract methods.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;&lt;code&gt;java
interface F {
    default void m() { }
    abstract void n();
}
&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;The use of abstract keyword is redundant here, but it legal.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;&lt;code&gt;java
interface F {
    void m() {}
}
&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;This will not compile because the method has a body but it lacks the keyword default.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Explanation&lt;/strong&gt;
A functional interface is an interface that contains exactly one abstract method. It may contain zero or more default methods and/or static methods in addition to the abstract method. Because a functional interface contains exactly one abstract method, you can omit the name of that method when you implement it using a lambda expression. For example, consider the following interface -&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;interface Predicate&amp;lt;T&amp;gt; {
    boolean test(T t);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The purpose of this interface is to provide a method that operates on an object of class T and return a boolean.&lt;/p&gt;

&lt;p&gt;You could have a method that takes an instance of class that  implements this interface defined like this -&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public void printImportantData(ArrayList&amp;lt;Data&amp;gt; dataList, Predicate&amp;lt;Data&amp;gt; p) {
    for (Data d: dataList) {
        if (p.test(d)) System.out.println(d);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;where Data class could be as simple as &lt;code&gt;public class Data { public int value; }&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Now, you can call the above method as follows:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;printImportantData(al, (Data d) -&amp;gt; { return d.value &amp;gt; 1; } );&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Notice the lack of method name here. This is possible because the interface has only one abstract method so the compiler can figure out the name. This can be shortened to:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;printImportantData(al, d -&amp;gt; d.value &amp;gt; 1);&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Notice that there is no declaration of d! The compiler can figure out all information it needs because the interface has only one abstract method and that method has only one parameter. So you don’t need to write all those things in your code.&lt;/p&gt;

&lt;p&gt;Compare the above approach to the old style using an inner class that does the same thing -&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;printImportantData(al, new Predicate&amp;lt;Data&amp;gt;() {
    public boolean test(Data d) {
        return d.value &amp;gt; 1;
    }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;Predicate&lt;/code&gt; interface described above can be used anywhere there is a need to “do something with an object and return a boolean” and is actually provided by the standard java library in &lt;code&gt;java.util.function&lt;/code&gt; package. This package provides a few other useful functional interfaces.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Predicate&amp;lt;T&amp;gt;&lt;/code&gt; Represents a predicate (boolean-valued function) of one argument of type T.&lt;br /&gt;
&lt;code&gt;Consumer&amp;lt;T&amp;gt;&lt;/code&gt; Represents an operation that accepts a single input argument of type T and returns no result.  &lt;br /&gt;
&lt;code&gt;Function&amp;lt;T, R&amp;gt;&lt;/code&gt; Represents a function that accepts one argument of type T and produces a result of type R&lt;br /&gt;
&lt;code&gt;Supplier&amp;lt;T&amp;gt;&lt;/code&gt; Represents a supplier of results of type T.&lt;/p&gt;

&lt;p&gt;Please see http://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html for learning Lambda expressions in Java.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;看段代码，判断输出：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;import java.util.HashSet;

enum SIZE {
    TALL, GRANDE, JUMBO;
}

public class CoffeeMug {
    public static void main(String[] args) {
        HashSet&amp;lt;SIZE&amp;gt; hs = new HashSet&amp;lt;&amp;gt;();
        hs.add(SIZE.TALL); hs.add(SIZE.JUMBO); hs.add(SIZE.GRANDE); 
        hs.add(SIZE.TALL); hs.add(SIZE.TALL); hs.add(SIZE.JUMBO); 

        for(SIZE s: hs) System.out.println(s);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There are two concepts involved in this question:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;A &lt;code&gt;Set&lt;/code&gt; (such as a &lt;code&gt;HashSet&lt;/code&gt;) does not allow duplicate elements. If you add a duplicate element, it is ignored. Thus, only three unique &lt;code&gt;SIZE&lt;/code&gt; elements are stored.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;It is important to understand how the &lt;code&gt;add()&lt;/code&gt; method of a Set works :
&lt;code&gt;boolean add(E o)&lt;/code&gt;
	Adds the specified element to this set if it is not already present (optional operation). More formally, adds the specified element, o, to this set if this set contains no element e such that &lt;code&gt;(o==null ? e==null : o.equals(e))&lt;/code&gt;. If this set already contains the specified element, the call leaves this set unchanged and returns false. In combination with the restriction on constructors, this ensures that sets never contain duplicate elements.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;The order of elements is not defined in &lt;code&gt;HashSet&lt;/code&gt;. So while retrieving elements, it can return them in any order.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Remember that, &lt;code&gt;TreeSet&lt;/code&gt; does store elements in their &lt;strong&gt;natural sorted order&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Also remember that the order of Enums is the order in which they are defined. It is not necessarily same as alphabetical order of their names.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Which of these statements concerning nested classes and interfaces are true?&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;An instance of a static nested class has an inherent outer instance.&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;Because static nested class is a static class.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;A static nested class can contain non-static member variables.&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;It is like any other normal class.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;A static nested interface can contain static member variables.&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;Static nested interface is similar to top level interface.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;A static nested interface has an inherent outer instance associated with it.&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;A static nested interface is a static interface and so does not have an associated outer instance.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;For each instance of the outer class, there can exist many instances of a non-static inner class.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Explanation&lt;/strong&gt;
Note the difference between an Inner class and a static nested class. Inner class means a NON STATIC class defined inside a class. Remember: A nested class is any class whose declaration occurs within the body of another class or interface. A top level class is a class that is not a nested class. An inner class is a nested class that is not explicitly or implicitly declared static. A class defined inside an interface is implicitly static. For example,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public class A  // outer class
{
   static public class B //Static Nested class . It can be used in other places: A.B b = new A.B(); There is no outer instance.
   {
   }
   class C //Inner class. It can only be used like this: A.C c = new A().new C(); Outer instance is needed.
   {
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;One can define a class as a static member of any top-level class. Now consider the following contents of a file named I1.java …&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public interface I1
{
    public void mA();
    public interface InnerI1
    {
        int k = 10;
        public void innerA();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here, interface &lt;code&gt;InnerI1&lt;/code&gt; is implicitly &lt;strong&gt;STATIC&lt;/strong&gt; and so is called as static nested interface. ‘k’ is a &lt;code&gt;static&lt;/code&gt; (&amp;amp; &lt;code&gt;final&lt;/code&gt;) member of this interface. If you do &lt;code&gt;'javap'&lt;/code&gt; on I1 it prints: Compiled from I1.java&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public interface I1
    /* ACC_SUPER bit NOT set */
{
    public abstract void mA();
    public static interface I1. InnerI1
    /* ACC_SUPER bit NOT set */
    {
        public static final int k;
        public abstract void innerA();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This interface can be referred to in other places like:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;class MyClass implements I1.InnerI1
{
...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is similar to referring a Top Level class.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;Which of the following annotations are retained for run time?&lt;/strong&gt;&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;&lt;code&gt;@SuppressWarnings&lt;/code&gt;&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;It is defined with @Retention(SOURCE)&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;&lt;code&gt;@Override&lt;/code&gt;&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;It is defined with @Retention(SOURCE)&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;&lt;code&gt;@SafeVarargs&lt;/code&gt;&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;It is defined with @Retention(RUNTIME)&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;&lt;code&gt;@FunctionalInterface&lt;/code&gt;&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;It is defined with @Retention(RUNTIME)&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;&lt;code&gt;@Deprecated&lt;/code&gt;&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;It is defined with @Retention(RUNTIME)&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;Your application needs to load a set of key value pairs from a database table which never changes. Multiple threads need to access this information but none of them changes it.  Which class would be the most appropriate to store such data if the values need not be keep in a sorted fashion?&lt;/strong&gt;&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;&lt;code&gt;Hashtable&lt;/code&gt;&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;&lt;code&gt;Set&lt;/code&gt;&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;&lt;code&gt;TreeMap&lt;/code&gt;&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;&lt;code&gt;List&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Explanation&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;You should know that all &lt;code&gt;Hashtable&lt;/code&gt; methods are synchronized and this compromises its performance for simultaneous reads.&lt;br /&gt;
Since no thread modifies the data, it is not efficient to use a &lt;code&gt;Hashtable&lt;/code&gt;.
A &lt;code&gt;HashMap&lt;/code&gt; is perfect choice because its methods are not synchronized and so it allows efficient multiple reads. &lt;code&gt;TreeMap&lt;/code&gt; is used to keep the keys sorted which makes it a little bit slower than &lt;code&gt;HashMap&lt;/code&gt;.
&lt;code&gt;Set&lt;/code&gt; and &lt;code&gt;List&lt;/code&gt; can’t be used since we need to store Key-value pairs.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;A programmer has written the following code to ensure that the phone number is not null and is of 10 characters:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public void processPhoneNumber(String number) {
    assert number != null &amp;amp;&amp;amp; number.length() == 10 : &quot;Invalid phone number&quot;;
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Which of the given statements regarding the above code are correct?&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;This is an appropriate use of assertions.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;This code will not work  in all situations.&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;It will not work if assertions are disabled.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;The given code is syntactically correct.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Constrains on input parameters should be enforced using assertions.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Explanation&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;As a rule, assertions should not be used to assert the validity of input parameters of a public method. Since assertions may be disabled at the wish of the user of the program, input validation will not occur when assertions are disabled. A public method should ensure in all situations(whether assertions are enabled or disabled) that the input parameters are valid before proceeding with the rest of the code. For this reason, input validation should always be done using the standard exception mechanism:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;if(number == null || number.length() != 10) throw new RuntimeException(&quot;Invalid phone number&quot;);&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;However, assertions may be used to validate the input parameters of a private method. This is because private methods are called only by the developer of the class. Therefore, if a private method is called with an invalid parameter, this problem should be rectified at the development stage itself. It cannot occur in the production stage, so there is not need to throw an explicit exception.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;Which clause(s) are used by a module definition that implements a service?&lt;/strong&gt;&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;exports&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;A service provider module is not read directly by a service user module. So, &lt;em&gt;exports&lt;/em&gt; clause is not required.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;provides&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;The provider module must specify the service interface and the implementing class that implements the service interface. For example,&lt;/p&gt;

      &lt;p&gt;provides org.printservice.api.Print with com.myprinter.PrintImpl&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;uses&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;A uses clause is used by the module that uses a service. For example,&lt;/p&gt;

      &lt;p&gt;uses org.printservice.api.Print;&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;implements&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;This is not a valid clause in module-info.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;requires&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;The implementing module must require the module that defines the service interface.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Explanation&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;For example, if an &lt;code&gt;abc.print&lt;/code&gt; module implements an &lt;code&gt;org.printing.Print&lt;/code&gt; service interface defined in &lt;code&gt;PrintServiceAPI&lt;/code&gt; module using &lt;code&gt;com.abc.PrintImpl&lt;/code&gt; class, then this is how its module-info should look:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;module abc.print {
    requires PrintServiceAPI; //required because this module defines the service interface org.printing.Print
    uses org.printing.Print; //specifies that this module uses this service
    
    //observe that abc.print module is not required.
}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;Which of the following statements regarding the assertion mechanism of Java is NOT correct?&lt;/strong&gt;&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;Assertions require changes at the JVM level.&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;No change is required in the JVM for supporting assertions.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Assertions require changes at the API level.&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;Besides the ‘assert’ keyword, new methods are added in &lt;code&gt;java.lang.Class&lt;/code&gt; and &lt;code&gt;java.lang.ClassLoader&lt;/code&gt; classes.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Assertions can be enabled or disabled through the command line at the time of execution of (i.e. starting) the program.&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;By using the switches, -ea and -da or -enableassertions or -disableassertions&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Code that uses Assertions cannot be run on version below 1.4&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;Because of the ‘assert’ keyword.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;Code written for JDK version 1.3 cannot be compiled under JDK version 1.4&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;It can be compiled by using -source flag: javac -source 1.3 classname.java&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;Identify correct statements about annotations.&lt;/strong&gt;&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;@SuppressWarnings can be used only on a class, constructor, or a method.&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;Actually, it can be used on several things. Its target can be a &lt;strong&gt;TYPE&lt;/strong&gt;, &lt;strong&gt;FIELD&lt;/strong&gt;, &lt;strong&gt;METHOD&lt;/strong&gt;, &lt;strong&gt;PARAMETER&lt;/strong&gt;, &lt;strong&gt;CONSTRUCTOR&lt;/strong&gt;, &lt;strong&gt;LOCAL_VARABLE&lt;/strong&gt;, and &lt;strong&gt;MODULE&lt;/strong&gt;.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;@Override can only be used on instance methods.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;@SafeVarargs can only be used on methods.&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;It can be used on constructors and methods.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;@Deprecated can be used only on a class, constructor, or a method.&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;Actually, it can be used on serval things, Its target can be a &lt;strong&gt;CONSTRUCTOR&lt;/strong&gt;, &lt;strong&gt;FIELD&lt;/strong&gt;, &lt;strong&gt;LOCAL_VARIABLE&lt;/strong&gt;, &lt;strong&gt;METHOD&lt;/strong&gt;, &lt;strong&gt;PACKAGE&lt;/strong&gt;, &lt;strong&gt;MODULE&lt;/strong&gt;,&lt;strong&gt;PARAMETER&lt;/strong&gt;,&lt;strong&gt;TYPE&lt;/strong&gt;.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;@SuppressWarnings(“all”) can be used suppress all warnings from a method or a class.&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;Although you can pass any string value to the SuppressWarnings annotation (unrecognized values are ignored), the Java specification mandates only three values - unchecked, deprecation, and removal. Different compilers and IDEs may support other values in addition to these three. There is no rule that says the value “all” has to suppress all warnings (although a compiler or an IDE may do that upon seeing this value.)&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

</description>
        <pubDate>Sat, 15 Feb 2020 22:10:00 +0000</pubDate>
        <link>https://zwt.io/2020/02/15/foundation-test-review/</link>
        <guid isPermaLink="true">https://zwt.io/2020/02/15/foundation-test-review/</guid>
        
        <category>Java 11</category>
        
        <category>OCP 11</category>
        
        
      </item>
    
      <item>
        <title>Exercises for Inner class</title>
        <description>&lt;h3 id=&quot;questions-and-exercises&quot;&gt;QUESTIONS AND EXERCISES&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;What is an inner class? Differentiate between member, local, and anonymous inner classes.&lt;/p&gt;

    &lt;p&gt;An inner class declares inside a top-level class without a static modifier. Inner classes that declared at member level are called member inner classes, local to the method, or instance initialization block are local inner class. And local inner classes that have no name are anonymous inner classes.&lt;!--more--&gt;&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;An inner class is a class declared inside the  body of another class. A member inner class is declared inside a class. It can be declared as public, private, protected, or package-level. A local inner class is declared inside a block. Its scope is limited to the block in which it is declared. An anonymous inner class is the same as  local inner class, but has no name. It is declared and an object of the class is created at the same time.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;What is the fully qualified name of the inner class B, which is declared as follows?&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;// A.java
package io.zwt.innerclasses.exercises;
   
public class A {
	public class B {
	}
}
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;That will be :  &lt;code&gt;io.zwt.innerclasses.exercises.A.B&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Consider the following declaration for top-level class named Cup and a member inner class named Handle:&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;// Cup.java
package io.zwt.innerclasses.exercises;
   
public class Cup {
	public class Handle {
		public Handle() {
			System.out.println(&quot;Created a handle for the cup&quot;);
		}
	}
   	
	public Cup() {
		System.out.println(&quot;Created a cup&quot;);
	}
}
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;Compile the in the main() method for the following CupTest class that will create an instance of the Cup.Handle inner class:&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;// CupTest.java
package io.zwt.innerclasses.exercises;
public class CupTest {
    public static void main(String[] args) {
        // Create a Cup
        Cup c = new Cup();
           
        // Create a Handle
        // Cup.Handle h = / * You code goes here */;
        Cup.Handle h = c.new Handle();
    }
}
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;What will be the output when the following Outer class is run?&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;// Outer.java
package io.zwt.innerclasses.exercises;
   
public class Outer {
    private final int value = 19680112;
       
    public class Inner {
        private final int value = 19690919;
        public void print() {
            System.out.println(&quot;Inner: value = &quot; + value);
            System.out.println(&quot;Inner: this.value = &quot; + this.value);
            System.out.println(&quot;Inner: Inner.this.value = &quot; + 
                              Inner.this.value);
            System.out.println(&quot;Inner: Outer.this.value = &quot; + 
                              Outer.this.vlaue);
        }
    }
       
    public void print() {
        System.out.println(&quot;Outer: value = &quot; + value);
        System.out.println(&quot;Outer: this.value = &quot; + this.value);
        System.out.println(&quot;Outer: Outer.this.value = &quot; + 
                          Outer.this.value);
    }
       
    public static void main(String[] args) {
        Outer out = new Outer();
        Inner in = out.new Inner();
        out.print();
        in.print();
    }
}
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The following declaration of an AnonymousTest class does not compile. Describe the reasons and steps you might take to fix the error.&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;// AnonymousTest
package io.zwt.innerclasses.exercises;
   
public class AnonymousTest {
    public static void main(String[] args) {
        int x = 100;
           
        Object obj = new Object() {
            {
                System.out.println(&quot;Inside.x = &quot; + x);
            }
        };
        x = 300;
        System.out.println(&quot;Outside.x = &quot; + x);
    }
}
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Consider the following declaration for a top-level class A and a member inner class B:&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;package io.zwt.innerclasses.exercises;
   
public class A {
    public class B {
        public B() {
            System.out.println(&quot;B is created.&quot;);
        }
    }
    public A() {
        System.out.println(&quot;A is created.&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;Consider the following incomplete declaration of class C, which inherits from the inner class A.B:&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;// C.java
package io.zwt.innerclasses.exercises;
   
public class C extends A.B {
    /* Define a constructor for class C here */
       
    public static void main(String[] args) {
        C c = /* Your code goes here */;
    }
}
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;Add an appropriate constructor for class C and complete the statement in the main() method. When class C is run, it should print the following to the standard output:&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;A is created.
B is created.
C is created.
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Which of the following is true about an anonymous inner class?&lt;/p&gt;

    &lt;p&gt;a. It can inherit from one class and implement one interface.&lt;/p&gt;

    &lt;p&gt;b. It can inherit from one class and implement multiple interfaces.&lt;/p&gt;

    &lt;p&gt;c. It can inherit from one class or implement one interface.&lt;/p&gt;

    &lt;p&gt;d. It can implement multiple interfaces, but inherits from only one class.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;How many class files will be generated when the following declaration of the Computer class is compiled? List the names of all generated class files.&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;// Computer.java
package io.zwt.innerclasses.exercises;
   
public class Computer {
    public class Mouse {
        public class Button {
        }
    }
       
    public static void main(String[] args) {
        Object obj = new Object() {
        };
           
        System.out.println(obj.hasCode());
    }
}
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The following declaration of class H does not compile. Point out the problem and suggest a solution.&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;// H.java
package io.zwt.innerclasses.exercises;
   
public class H {
    private int x = 100;
       
    public static class J {
        private int y = x * 2;
    }
}
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Consider the following declaration of a top-level class P and a nested static class Q:&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;// P.java
package io.zwt.innerclasses.exercises;
    
public class P {
    public static class Q {
        System.out.println(&quot;Hello from Q.&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;Complete the main() method of the following PTest class that will create an object of the nested static class Q. When class PTest is run, it should print a message “Hello from Q.” to the standard output.&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;// PTest.java
package io.zwt.innerclasses.exercises;
    
public class PTest {
    public static void main(String[] args) {
        P.Q q = /* Your code goes here */ ;
    }
}
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;

</description>
        <pubDate>Sat, 15 Feb 2020 16:55:00 +0000</pubDate>
        <link>https://zwt.io/2020/02/15/inner-class-exercises/</link>
        <guid isPermaLink="true">https://zwt.io/2020/02/15/inner-class-exercises/</guid>
        
        <category>Java</category>
        
        
      </item>
    
      <item>
        <title>Travis CI上手</title>
        <description>&lt;h3 id=&quot;配置文件&quot;&gt;配置文件&lt;/h3&gt;

&lt;p&gt;我用于博客自动构建的&lt;code&gt;.travis.yml&lt;/code&gt;脚本：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-yaml&quot;&gt;language: ruby
rvm:
  - 2.6.3
env:
  global:
  - NOKOGIRI_USE_SYSTEM_LIBRARIES=true
  - secure: D0RrVHHBEEJMyJK9OUUPM6Wms+D+zifJhHFl4BcmC0leSR0vANoQ6357Bl4miZL2flmnBU/1Z9WNzcDVM0JwQpF8ZVeEdMvgBY5+73Xjp8cIwYfWx8MAUB8J1Hug2aEiXw6KoSxjFOnUpSRnhCcWpviFNCZOa5XavMfe7+OHbNQT1U1xu+ZOmDG6Hrm3CMhfzu2cRPIfziAAgnWVfgtqA0STXnY9D0HvfsKPl6khy6VWkeF09Chqo/XVO/SV5LSgplkgXh1OzS6ITwT99UWDRqIeXYAvMJFyrHkzdxNgtAddYVxmx8WQqfqUFQ6A3HSnJy2Fq04H3gLszQxrVPzw8fNeOzBe7hIviaZdgRsglc26NO13EX//e4DA1ImiYKciFGvDNDBrqtv8u3XAG+8jVe/dLwKbBXnvi64udh2/H/lTBfWQ3eV08/R6m0m4aF8jbv0oBuXReyXuEy9D6xNm+yceekWzKAmTYPFb9W5XLveIgt8SIQO9P6tGuMWV6w7KRhgbpgI886ZeSVS3WcAGIr11SvSNa+x5WapOd/mizHrA8VvW4v8GjmYYwTOsmiLuYl2t1fWY76yYOOdSDLC9XhJN/mS3qxxX7WR4KCJgpstyzTVXj+uyuzi23sV1SdUvO35r3VkZk11ad9Qmp9WLXpdSQfMAKbu/lC7C9HfrGuM=
cache:
  bundler: true
  directories:
    - /home/travis/.rvm/
install:
- gem install bundler
- bundle install
script:
- bundle exec rake deploy
after_success:
- bash &amp;lt;(curl -s https://codecov.io/bash)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;发现启用了 cache 之后，快很多了。搞到动图凑内容：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/cache_1581461859_5053.gif&quot; alt=&quot;cache_1581461859_5053&quot; /&gt;&lt;/p&gt;

&lt;p&gt;用来测试构建时长，哈哈哈哈！&lt;/p&gt;
</description>
        <pubDate>Wed, 12 Feb 2020 06:49:00 +0000</pubDate>
        <link>https://zwt.io/2020/02/12/intro-to-travis/</link>
        <guid isPermaLink="true">https://zwt.io/2020/02/12/intro-to-travis/</guid>
        
        <category>持续集成</category>
        
        
      </item>
    
      <item>
        <title>AsciiDoc语法参考</title>
        <description>&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;段落&quot;&gt;&lt;em&gt;段落&lt;/em&gt;&lt;/h3&gt;
&lt;div class=&quot;paragraph lead&quot;&gt;
&lt;p&gt;段落不需要特别的格式，&lt;strong&gt;直接&lt;/strong&gt;写就是了。
然后呢&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;自然段&quot;&gt;&lt;em&gt;自然段&lt;/em&gt;&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;这是普通段落&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;开始至少空一格就成为自然段，同一个自然段里面的内容必须相邻，
即不能隔空行。&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;隔空行就是另一个自然段了。自然段文字是等宽字体，然后会保留空格和新行。
例如    保留了前边的空格，
然后这样，保留了换新行。&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;现在这里又是一个普通段落了。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;然后呢&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;杂记&quot;&gt;杂记&lt;/h4&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;使用 Travis CI 也挺好玩的，搭建起持续集成的工作流。在这里也添加个动图吧：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;一个普通图：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;imageblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;img src=&quot;/img/city.jpg&quot; alt=&quot;City&quot;&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;一个专用动图：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;imageblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;img src=&quot;/img/cache_1581461859_5053.gif&quot; alt=&quot;travis 真香！&quot;&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;bold &lt;strong&gt;constrained&lt;/strong&gt; &amp;amp; &lt;strong&gt;un&lt;/strong&gt;constrained&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;italic &lt;em&gt;constrained&lt;/em&gt; &amp;amp; &lt;em&gt;un&lt;/em&gt;constrained&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;bold italic &lt;strong&gt;&lt;em&gt;constrained&lt;/em&gt;&lt;/strong&gt; &amp;amp; &lt;strong&gt;&lt;em&gt;un&lt;/em&gt;&lt;/strong&gt;constrained&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;monospace &lt;code&gt;constrained&lt;/code&gt; &amp;amp; &lt;code&gt;un&lt;/code&gt;constrained&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;monospace bold &lt;code&gt;&lt;strong&gt;constrained&lt;/strong&gt;&lt;/code&gt; &amp;amp; &lt;code&gt;&lt;strong&gt;un&lt;/strong&gt;&lt;/code&gt;constrained&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;monospace italic &lt;code&gt;&lt;em&gt;constrained&lt;/em&gt;&lt;/code&gt; &amp;amp; &lt;code&gt;&lt;em&gt;un&lt;/em&gt;&lt;/code&gt;constrained&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;monospace bold italic &lt;code&gt;&lt;strong&gt;&lt;em&gt;constrained&lt;/em&gt;&lt;/strong&gt;&lt;/code&gt; &amp;amp; &lt;code&gt;&lt;strong&gt;&lt;em&gt;un&lt;/em&gt;&lt;/strong&gt;&lt;/code&gt;constrained&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;code&gt;C&amp;#43;&amp;#43;&lt;/code&gt; is valid syntax in the programming language by the same name.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;code&gt;WHERE id &amp;lt;= 20 AND value = &quot;{name}&quot;&lt;/code&gt; is a SQL WHERE clause.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;public class Hello {
  public static void main(String[] args) {
    System.out.println(&quot;Hello&quot;);
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Werewolves are allergic to &lt;mark&gt;cassia cinnamon&lt;/mark&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Did the werewolves read the &lt;span class=&quot;small&quot;&gt;small print&lt;/span&gt;?&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Where did all the &lt;span class=&quot;underline&quot;&gt;cores&lt;/span&gt; run off to?&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;We need &lt;span class=&quot;line-through&quot;&gt;ten&lt;/span&gt; make that twenty VMs.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;span class=&quot;big&quot;&gt;O&lt;/span&gt;nce upon an infinite loop.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;sup&gt;super&lt;/sup&gt;script phrase&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;sub&gt;sub&lt;/sub&gt;script phrase&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&amp;#8220;double curved quotes&amp;#8221;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&amp;#8216;single curved quotes&amp;#8217;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Olaf&amp;#8217;s desk was a mess.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;All of the werewolves&amp;#8217; desks were a mess.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Olaf had been with the company since the &amp;#8217;60s.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Rubies are red,&lt;br&gt;
Topazes are blue.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Ruby is red.&lt;br&gt;
Java is black.&lt;/p&gt;
&lt;/div&gt;
&lt;div style=&quot;page-break-after: always;&quot;&gt;&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Lists&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Edgar Allen Poe&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Sheri S. Tepper&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Bill Bryson&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;max nesting&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;level 1&lt;/p&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;level 2&lt;/p&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;level 3&lt;/p&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;level 4&lt;/p&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;level 5&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;level 1&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Ordered, basic&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;Step 1&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Step 2&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Step 3&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Ordered, max nesting&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;level 1&lt;/p&gt;
&lt;div class=&quot;olist loweralpha&quot;&gt;
&lt;ol class=&quot;loweralpha&quot; type=&quot;a&quot;&gt;
&lt;li&gt;
&lt;p&gt;level 2&lt;/p&gt;
&lt;div class=&quot;olist lowerroman&quot;&gt;
&lt;ol class=&quot;lowerroman&quot; type=&quot;i&quot;&gt;
&lt;li&gt;
&lt;p&gt;level 3&lt;/p&gt;
&lt;div class=&quot;olist upperalpha&quot;&gt;
&lt;ol class=&quot;upperalpha&quot; type=&quot;A&quot;&gt;
&lt;li&gt;
&lt;p&gt;level 4&lt;/p&gt;
&lt;div class=&quot;olist upperroman&quot;&gt;
&lt;ol class=&quot;upperroman&quot; type=&quot;I&quot;&gt;
&lt;li&gt;
&lt;p&gt;level 5&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;level 1&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Checklist&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist checklist&quot;&gt;
&lt;ul class=&quot;checklist&quot;&gt;
&lt;li&gt;
&lt;p&gt;&lt;i class=&quot;fa fa-check-square-o&quot;&gt;&lt;/i&gt; checked&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;i class=&quot;fa fa-check-square-o&quot;&gt;&lt;/i&gt; also checked&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;i class=&quot;fa fa-square-o&quot;&gt;&lt;/i&gt; not checked&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;normal list item&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Description, single-line&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;dlist&quot;&gt;
&lt;dl&gt;
&lt;dt class=&quot;hdlist1&quot;&gt;first term&lt;/dt&gt;
&lt;dd&gt;
&lt;p&gt;definition of first term&lt;/p&gt;
&lt;/dd&gt;
&lt;dt class=&quot;hdlist1&quot;&gt;second term&lt;/dt&gt;
&lt;dd&gt;
&lt;p&gt;definition of second term&lt;/p&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Description, multi-line&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;dlist&quot;&gt;
&lt;dl&gt;
&lt;dt class=&quot;hdlist1&quot;&gt;first term&lt;/dt&gt;
&lt;dd&gt;
&lt;p&gt;definition of first term&lt;/p&gt;
&lt;/dd&gt;
&lt;dt class=&quot;hdlist1&quot;&gt;second term&lt;/dt&gt;
&lt;dd&gt;
&lt;p&gt;definition of second term&lt;/p&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Q &amp;amp; A&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;qlist qanda&quot;&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;What is Asciidoctor?&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;An implementation of the AsciiDoc processor in Ruby.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;What is the answer to the Ultimate Question?&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;42&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Complex content in outline lists&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Every list item has at least one paragraph of content,
which may be wrapped, even using a hanging indent.&lt;/p&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Additional paragraphs or blocks are adjoined by putting
a list continuation on a line adjacent to both blocks.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;dlist&quot;&gt;
&lt;dl&gt;
&lt;dt class=&quot;hdlist1&quot;&gt;list continuation&lt;/dt&gt;
&lt;dd&gt;
&lt;p&gt;a plus sign (&lt;code&gt;&amp;#43;&lt;/code&gt;) on a line by itself&lt;/p&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A literal paragraph does not require a list continuation.&lt;/p&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;$ gem install asciidoctor&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;AsciiDoc lists may contain any complex content.&lt;/p&gt;
&lt;table class=&quot;tableblock frame-all grid-all stretch&quot;&gt;
&lt;colgroup&gt;
&lt;col style=&quot;width: 50%;&quot;&gt;
&lt;col style=&quot;width: 50%;&quot;&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th class=&quot;tableblock halign-left valign-top&quot;&gt;Application&lt;/th&gt;
&lt;th class=&quot;tableblock halign-left valign-top&quot;&gt;Language&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;AsciiDoc&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;Python&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;Asciidoctor&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;Ruby&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;超链接&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://asciidoctor.org&quot; class=&quot;bare&quot;&gt;https://asciidoctor.org&lt;/a&gt; - automatic!&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://asciidoctor.org&quot;&gt;Asciidoctor&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/asciidoctor&quot;&gt;Asciidoctor @ &lt;strong&gt;GitHub&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://discuss.asciidoctor.org&quot; class=&quot;external&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Discuss Asciidoctor&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://discuss.asciidoctor.org&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Discuss Asciidoctor&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://example.org&quot; class=&quot;teal&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Google, Yahoo, Bing&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;See &lt;a href=&quot;#自然段&quot;&gt;&lt;em&gt;自然段&lt;/em&gt;&lt;/a&gt; to learn how to write paragraphs.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Learn how to organize the document into &lt;a href=&quot;#section-titles&quot;&gt;sections&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;图片&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;imageblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;img src=&quot;https://asciidoctor.org/images/octocat.jpg&quot; alt=&quot;GitHub mascot&quot;&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;UI Macro&lt;/p&gt;
&lt;/div&gt;
&lt;table class=&quot;tableblock frame-all grid-all stretch&quot;&gt;
&lt;colgroup&gt;
&lt;col style=&quot;width: 50%;&quot;&gt;
&lt;col style=&quot;width: 50%;&quot;&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th class=&quot;tableblock halign-left valign-top&quot;&gt;Shortcut&lt;/th&gt;
&lt;th class=&quot;tableblock halign-left valign-top&quot;&gt;Purpose&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;&lt;kbd&gt;F11&lt;/kbd&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;Toggle fullscreen&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;&lt;span class=&quot;keyseq&quot;&gt;&lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;T&lt;/kbd&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;Open a new tab&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;&lt;span class=&quot;keyseq&quot;&gt;&lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;Shift&lt;/kbd&gt;+&lt;kbd&gt;N&lt;/kbd&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;New incognito window&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;&lt;kbd&gt;\&lt;/kbd&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;Used to escape characters&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;&lt;span class=&quot;keyseq&quot;&gt;&lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;]&lt;/kbd&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;Jump to keyword&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;&lt;span class=&quot;keyseq&quot;&gt;&lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;+&lt;/kbd&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;Increase zoom&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;
Content in a passthrough block is passed to the output unprocessed.
That means you can include raw HTML, like this embedded Gist:
&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/mojavelinux/5333524.js&quot;&gt;
&lt;/script&gt;
&lt;div class=&quot;quoteblock&quot;&gt;
&lt;blockquote&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Four score and seven years ago our fathers brought forth
on this continent a new nation&amp;#8230;&amp;#8203;&lt;/p&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;attribution&quot;&gt;
&amp;#8212; Abraham Lincoln&lt;br&gt;
&lt;cite&gt;Address delivered at the dedication of the Cemetery at Gettysburg&lt;/cite&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;quoteblock&quot;&gt;
&lt;blockquote&gt;
A person who never made a mistake never tried anything new.
&lt;/blockquote&gt;
&lt;div class=&quot;attribution&quot;&gt;
&amp;#8212; Albert Einstein
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;quoteblock&quot;&gt;
&lt;blockquote&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;A person who never made a mistake never tried anything new.&lt;/p&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class=&quot;quoteblock&quot;&gt;
&lt;blockquote&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;If you don&amp;#8217;t know where you are going, any road will get you there.&lt;/p&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;attribution&quot;&gt;
&amp;#8212; Charles Lutwidge Dodgson&lt;br&gt;
&lt;cite&gt;Mathematician and author, also known as &lt;a href=&quot;https://en.wikipedia.org/wiki/Lewis_Carroll&quot;&gt;Lewis Carroll&lt;/a&gt;&lt;/cite&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sidebarblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;div class=&quot;title&quot;&gt;AsciiDoc history&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;AsciiDoc was first released in Nov 2002 by Stuart Rackham.
It was designed from the start to be a shorthand syntax
for producing professional documents like DocBook and LaTeX.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;exampleblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;Example 1. Sample document&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Here&amp;#8217;s a sample AsciiDoc document:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;= Title of Document
Doc Writer
:toc:

This guide provides...&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The document header is useful, but not required.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;admonitionblock note&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td class=&quot;icon&quot;&gt;
&lt;i class=&quot;fa icon-note&quot; title=&quot;Note&quot;&gt;&lt;/i&gt;
&lt;/td&gt;
&lt;td class=&quot;content&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;An admonition block may contain complex content.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;div class=&quot;title&quot;&gt;A list&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;one&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;two&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;three&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Another paragraph.&lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;line of code  &lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;(1)&lt;/b&gt;
line of code  &lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;(2)&lt;/b&gt;
line of code  &lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;(3)&lt;/b&gt;
line of code  &lt;i class=&quot;conum&quot; data-value=&quot;4&quot;&gt;&lt;/i&gt;&lt;b&gt;(4)&lt;/b&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;1&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;A callout behind a line comment for C-style languages.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;2&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;A callout behind a line comment for Ruby, Python, Perl, etc.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;3&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;A callout behind a line comment for Clojure.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;4&quot;&gt;&lt;/i&gt;&lt;b&gt;4&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;A callout behind a line comment for XML or SGML languages like HTML.&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-xml&quot; data-lang=&quot;xml&quot;&gt;&amp;lt;section&amp;gt;
  &amp;lt;title&amp;gt;Section Title&amp;lt;/title&amp;gt; &lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;(1)&lt;/b&gt;
&amp;lt;/section&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;1&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;The section title is required.&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;插入视频&quot;&gt;插入视频&lt;/h4&gt;
&lt;div class=&quot;videoblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;iframe src=&quot;https://player.vimeo.com/video/67480300&quot; frameborder=&quot;0&quot; allowfullscreen&gt;&lt;/iframe&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;table class=&quot;tableblock frame-all grid-all stretch&quot;&gt;
&lt;caption class=&quot;title&quot;&gt;Table 1. Table Title&lt;/caption&gt;
&lt;colgroup&gt;
&lt;col style=&quot;width: 33.3333%;&quot;&gt;
&lt;col style=&quot;width: 33.3333%;&quot;&gt;
&lt;col style=&quot;width: 33.3334%;&quot;&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th class=&quot;tableblock halign-left valign-top&quot;&gt;Name of Column 1&lt;/th&gt;
&lt;th class=&quot;tableblock halign-left valign-top&quot;&gt;Name of Column 2&lt;/th&gt;
&lt;th class=&quot;tableblock halign-left valign-top&quot;&gt;Name of Column 3&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;Cell in column 1, row 1&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;Cell in column 2, row 1&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;Cell in column 3, row 1&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;Cell in column 1, row 2&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;Cell in column 2, row 2&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;Cell in column 3, row 2&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class=&quot;tableblock frame-all grid-all stretch&quot;&gt;
&lt;colgroup&gt;
&lt;col style=&quot;width: 33.3333%;&quot;&gt;
&lt;col style=&quot;width: 33.3333%;&quot;&gt;
&lt;col style=&quot;width: 33.3334%;&quot;&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th class=&quot;tableblock halign-left valign-top&quot;&gt;Artist&lt;/th&gt;
&lt;th class=&quot;tableblock halign-left valign-top&quot;&gt;Track&lt;/th&gt;
&lt;th class=&quot;tableblock halign-left valign-top&quot;&gt;Genre&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;Baauer&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;Harlem Shake&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;Hip Hop&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;The Lumineers&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;Ho Hey&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;Folk Rock&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class=&quot;tableblock frame-all grid-all stretch&quot;&gt;
&lt;colgroup&gt;
&lt;col style=&quot;width: 33.3333%;&quot;&gt;
&lt;col style=&quot;width: 33.3333%;&quot;&gt;
&lt;col style=&quot;width: 33.3334%;&quot;&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th class=&quot;tableblock halign-left valign-top&quot;&gt;Artist&lt;/th&gt;
&lt;th class=&quot;tableblock halign-left valign-top&quot;&gt;Track&lt;/th&gt;
&lt;th class=&quot;tableblock halign-left valign-top&quot;&gt;Genre&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;Baauer&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;Harlem Shake&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;Hip Hop&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class=&quot;tableblock frame-all grid-all&quot; style=&quot;width: 25%;&quot;&gt;
&lt;colgroup&gt;
&lt;col style=&quot;width: 25%;&quot;&gt;
&lt;col style=&quot;width: 25%;&quot;&gt;
&lt;col style=&quot;width: 25%;&quot;&gt;
&lt;col style=&quot;width: 25%;&quot;&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;&lt;em&gt;1&lt;/em&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-right valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;&lt;strong&gt;2&lt;/strong&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-center valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;3&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-right valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;&lt;strong&gt;4&lt;/strong&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;tableblock halign-center valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;&lt;em&gt;5&lt;/em&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-center valign-middle&quot; colspan=&quot;2&quot; rowspan=&quot;2&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;&lt;code&gt;6&lt;/code&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-bottom&quot; rowspan=&quot;3&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;&lt;code&gt;7&lt;/code&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;tableblock halign-center valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;&lt;em&gt;8&lt;/em&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;&lt;em&gt;9&lt;/em&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-right valign-top&quot; colspan=&quot;2&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;&lt;code&gt;10&lt;/code&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;To save the file, select &lt;span class=&quot;menuseq&quot;&gt;&lt;b class=&quot;menu&quot;&gt;File&lt;/b&gt;&amp;#160;&lt;i class=&quot;fa fa-angle-right caret&quot;&gt;&lt;/i&gt; &lt;b class=&quot;menuitem&quot;&gt;Save&lt;/b&gt;&lt;/span&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Select &lt;span class=&quot;menuseq&quot;&gt;&lt;b class=&quot;menu&quot;&gt;View&lt;/b&gt;&amp;#160;&lt;i class=&quot;fa fa-angle-right caret&quot;&gt;&lt;/i&gt; &lt;b class=&quot;submenu&quot;&gt;Zoom&lt;/b&gt;&amp;#160;&lt;i class=&quot;fa fa-angle-right caret&quot;&gt;&lt;/i&gt; &lt;b class=&quot;menuitem&quot;&gt;Reset&lt;/b&gt;&lt;/span&gt; to reset the zoom level to the default setting.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</description>
        <pubDate>Wed, 12 Feb 2020 05:26:00 +0000</pubDate>
        <link>https://zwt.io/2020/02/12/hello-asciidoctor/</link>
        <guid isPermaLink="true">https://zwt.io/2020/02/12/hello-asciidoctor/</guid>
        
        <category>Asciidoc</category>
        
        <category>Notes</category>
        
        
      </item>
    
      <item>
        <title>Java 内部类</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;在这一篇文章，你将会学习到：&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;内部类是什么&lt;/li&gt;
    &lt;li&gt;如何声明内部类&lt;/li&gt;
    &lt;li&gt;如何声明成员、局部，以及匿名内部类&lt;/li&gt;
    &lt;li&gt;如何创建内部类的对象&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;什么是内部类&quot;&gt;什么是内部类？&lt;/h3&gt;

&lt;p&gt;我们知道类（class）是包（package）的成员（member）。即顶层类，直接放在包下面的类。例如以下这段代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;// TopLevel.java
package io.zwt.innerclasses;

public class TopLevel {
    private int value = 101;
    
    public int getValue() {
        return value;
    }
    
    public void setValue(int value) {
        this.value = value;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的 &lt;code&gt;TopLevel&lt;/code&gt; 类是 &lt;code&gt;io.zwt.innerclasses&lt;/code&gt; 包的成员。 这个里有三个成员：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;一个实例变量（instance variable）：&lt;code&gt;value&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;两个方法（method）：&lt;code&gt;getValue()&lt;/code&gt; and &lt;code&gt;setValue()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一个类也可以声明在另一个类里面。这种类称为&lt;em&gt;内部类&lt;/em&gt;。如果定义在另一个类中的类显式或隐式被声明为static，则它被称为嵌套类，而不是内部类。包含内部类的类称为&lt;em&gt;外层类&lt;/em&gt;或&lt;em&gt;外部类&lt;/em&gt;。看一下下面的 &lt;code&gt;Outer&lt;/code&gt; 和 &lt;code&gt;Inner&lt;/code&gt; 类声明：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;// Outer.java
pakcage io.zwt.innerclasses;

public class Outer {
	public class Inner {
		// 内部类的成员在这里
	}
	// 外部类的其它成员在这里
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一个内部类实例只能存在于其外部类实例内。也就是说，你在创建内部类实例之前必须要有一个外部类的实例。这个规则在规范一个对象不能脱离另一个对象而存在这方面很有用。内部类可以完全访问到它的外部类的所有成员，包括私有成员。&lt;!--more--&gt;&lt;/p&gt;

&lt;h3 id=&quot;使用内部类的好处&quot;&gt;使用内部类的好处&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;可以将一个类定义在它的使用者附近。例如，一个计算机有处理器，所以最好将 &lt;code&gt;Processor&lt;/code&gt; 类定义为 &lt;code&gt;Computer&lt;/code&gt; 类的内部类。&lt;/li&gt;
  &lt;li&gt;它们提供了额外管理类结构的命名空间。例如，在未有内部类之前，一个类只能是包的成员。有了内部类，包含内部类的顶层类，提供了额外的命名空间。&lt;/li&gt;
  &lt;li&gt;某些设计模式用内部类实现更简单。例如，适配器模式，枚举模式，还有状态模式，都可以用内部类轻松实现。&lt;/li&gt;
  &lt;li&gt;用内部类实现回调机制优雅且方便。Java 8 的 Lambda 表达式是一种更好且更简洁的回调实现方式。&lt;/li&gt;
  &lt;li&gt;有助于在 Java 实现闭包。&lt;/li&gt;
  &lt;li&gt;使用内部类你可以体验一种类的多继承。一个内部类可以继承其它类。因此，内部类可以访问它的外部类成员，以及它的超类成员。注意，访问两个以上类的成员是多继承的目标之一，这可以通过使用内部类实现。然而，只是可以访问两个类的成员，并不是真正意义上的多继承。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;内部类的种类&quot;&gt;内部类的种类&lt;/h3&gt;

&lt;p&gt;你可以在类的任意可以写 Java 语句的位置定义一个内部类，有三种内部类。它们的类型取决于声明所在的位置和声明的方式。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;成员内部类&lt;/li&gt;
  &lt;li&gt;局部内部类&lt;/li&gt;
  &lt;li&gt;匿名内部类&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;成员内部类&quot;&gt;成员内部类&lt;/h4&gt;

&lt;p&gt;成员内部类和成员字段或成员方法一样声明在一个类里面。可以声明为 &lt;code&gt;public&lt;/code&gt;, &lt;code&gt;private&lt;/code&gt;, &lt;code&gt;protected&lt;/code&gt; 或者是包级别访问权限。其实例仅在外部类存在的条件下才存在。&lt;/p&gt;

&lt;h4 id=&quot;局部内部类&quot;&gt;局部内部类&lt;/h4&gt;

&lt;p&gt;局部内部类声明在块内。它的作用范围受限于它声明所在的块。由于它作用范围始终受限于块，它的声明不可以使用任何访问修饰符，例如 &lt;code&gt;public&lt;/code&gt;, &lt;code&gt;private&lt;/code&gt; 或 &lt;code&gt;protected&lt;/code&gt;。 通常局部内部类定义在一个方法内。然而，它也可以被定义在静态初始化块，实例初始化块，以及构造器内。当只在块内使用一个类，你可以使用局部内部类。&lt;/p&gt;

&lt;p&gt;要在块外使用局部内部类，它必须符合以下至少一项：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Implement a public interface 实现一个公有接口&lt;/li&gt;
  &lt;li&gt;继承自另一个公有类，并重写它的超类方法。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;匿名内部类&quot;&gt;匿名内部类&lt;/h4&gt;

&lt;p&gt;匿名内部类跟局部内部类同样，除了一个区别：它没有名字。因为它没有名字，所以没有构造器。&lt;/p&gt;

&lt;h3 id=&quot;静态成员类不是内部类&quot;&gt;静态成员类不是内部类&lt;/h3&gt;

&lt;p&gt;在另一个类中定义的成员类可以声明为 &lt;code&gt;static&lt;/code&gt;。 以下代码声明了一个顶层类 &lt;code&gt;A&lt;/code&gt; 和一个静态成员类 &lt;code&gt;B&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;package io.zwt.innnerclasses;
public class A {
	// A static member class
	public static class B {
		// The body of class B goes here
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一个静态成员类不是内部类。它被看作是顶层类。它亦被称为嵌套顶层类。因为它是一个顶层类，你不需要它的外层类的实例去创建它的对象。一个类 A 的实例和类 B 的实例可以独立地存在，因为它们都是顶层类。一个静态成员类可以声明为 &lt;code&gt;public&lt;/code&gt;, &lt;code&gt;protected&lt;/code&gt;，包访问级别，或者是&lt;code&gt; private&lt;/code&gt; 以限制它在外层类之外的访问权限。&lt;/p&gt;

&lt;h3 id=&quot;创建内部类对象&quot;&gt;创建内部类对象&lt;/h3&gt;

&lt;p&gt;创建局部内部类，匿名内部类，和静态成员类是非常直接的。局部内部类的对象在声明所在的内使用 &lt;code&gt;new&lt;/code&gt; 创建对象。匿名内部类的对象在声明时候创建对象。静态成员类是另一类顶层类，其对象创建方式跟顶层类一样。&lt;/p&gt;

&lt;h3 id=&quot;访问外层类的成员&quot;&gt;访问外层类的成员&lt;/h3&gt;

&lt;h3 id=&quot;局部变量访问的限制&quot;&gt;局部变量访问的限制&lt;/h3&gt;

&lt;p&gt;A local inner class is declared inside a block—typically inside a method of a class. A local inner class can access the instance variables of its enclosing class as well as the local variables, which are in scope. The instance of an inner class exists within an instance of its enclosing class. Therefore, accessing the instance variables of the enclosing class inside a local inner class is not a problem because they exist throughout the lifecycle of the instance of the local inner class. However, the local variables in a method exist only during the execution of that method. All local variables become inaccessible when method execution is over. Java makes a copy of the local variables that are used inside a local inner class and stores that copy along with the inner class object. However, to guarantee that the values of the local variables can be reproduced when accessed inside the local inner class code after the method call is over, Java puts a restriction that the local variables must be effectively final. An effectively final variable is a variable whose value does not change after it is initialized. One way to have an effectively final variable is to declare the variable final. Another way is not to change its value after it is initialized. Therefore, a local variable or an argument to a method must be effectively final if it is used inside a local inner class. This restriction also applies to an anonymous inner class declared inside a method.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;提示&lt;/strong&gt; 在 Java 8 以前，如果一个局部变量是被局部内部类，或者匿名内部类访问的，它必须被声明为 &lt;code&gt;final&lt;/code&gt;。 Java 8 更改了这个规则：局部变量不需要被声明为 &lt;code&gt;final&lt;/code&gt;， 但它应该是 effectively final 的。 什么意思呢？就是说，在变量声明前面添加个 &lt;code&gt;final&lt;/code&gt; 修饰符，仍然能够通过编译，相当于 &lt;code&gt;final&lt;/code&gt;，就是所谓的 “effective final” ，就等效于 &lt;code&gt;final&lt;/code&gt; 嘛。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;内部类与继承&quot;&gt;内部类与继承&lt;/h3&gt;

&lt;p&gt;An inner class can inherit from another inner class, a top-level class, or its enclosing class. For example, in the following snippet of code, inner class C inherits from inner class B; inner class D inherits from its enclosing top-level class A, and inner class F inherits from inner class A.B:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public class A {
    public class B {
    }
    public class C extends B {
    }
    public class D extends A {
    }
}

public class E extends A {
    public class F extends B {
        
    }
}

public class G extends A.B {
    // This code won't compile
    // 这段代码不能通过编译！
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;内部类中不能有静态成员除非是编译时常量&quot;&gt;内部类中不能有静态成员（除非是编译时常量）&lt;/h3&gt;

&lt;p&gt;Java 里面的 &lt;code&gt;static&lt;/code&gt; 关键字使得一个结构变成顶层结构。因此，你不能在一个内部类里边定义任何静态成员（字段、方法或者是初始化语句块）。以下代码不能通过编译，因为内部类 &lt;code&gt;B&lt;/code&gt; 声明了一个静态字段 &lt;code&gt;DAYS_IN_A_WEEK&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public class A {
    public class B {
        // Cannot have the following declaration
        public static int DAYS_IN_A_WEEK = 7; // A compile-time error
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然而，内部类里面可以有性质为编译时常量的静态字段。什么意思？请看以下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public class A {
    public class B {
        // Can have a compile-time static constant field
        public final static int DAYS_IN_A_WEEK = 7; // OK
        // a compile-time constant, even though it is final
        // 上面一句不对，str 不能用 new String(&quot;Hello&quot;);
        // 差点被坑了🕳
        public final static String str = new String(&quot;Hello&quot;);
		// 可以用 public final static String str = &quot;Hello&quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;内部类和编译器的魔法&quot;&gt;内部类和编译器的魔法&lt;/h3&gt;

&lt;h3 id=&quot;闭包与回调&quot;&gt;闭包与回调&lt;/h3&gt;

&lt;p&gt;In functional programming, a higher order function is an anonymous function that can be treated as a data object. That is, it can be stored in a variable and passed around from one context to another.  It might be invoked in a context that did not necessarily define it. Note that a higher order function is an anonymous function, so the invoking context does not have to know its name. A closure is a higher order function packaged with its defining environment. A closure carries with it the variables in scope when it was defined, and it can access those variables even when it is invoked in a context other than the context in which it was defined.&lt;/p&gt;

&lt;h3 id=&quot;在静态上下文定义内部类&quot;&gt;在静态上下文定义内部类&lt;/h3&gt;

&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
</description>
        <pubDate>Tue, 04 Feb 2020 22:34:00 +0000</pubDate>
        <link>https://zwt.io/2020/02/04/inner-class/</link>
        <guid isPermaLink="true">https://zwt.io/2020/02/04/inner-class/</guid>
        
        <category>Java</category>
        
        <category>语言特性</category>
        
        
      </item>
    
      <item>
        <title>深入生成器设计模式</title>
        <description>&lt;h3 id=&quot;gof-定义&quot;&gt;GoF 定义&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Separate the construction of a complex object from its representation so that the same construction processes can create different representations.&lt;/p&gt;

  &lt;p&gt;将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同表示。（中文版书里的翻译）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Builder 在《设计模式》的中文版里边翻译为“生成器”，那我就按这个译法吧。生成器模式属于创建型模式（Creational patterns），它关注如何创建对象。当需要构建的对象比较复杂，由多个部分组成，也就说它的构造方法会有很多参数，就可以考虑使用这种模式。生成器模式认为对象的构建机制应该独立于它的组成部分（也就是属性），对象的&lt;strong&gt;构建过程&lt;/strong&gt;不关注对象的&lt;strong&gt;组成部分&lt;/strong&gt;。所以同一个构建过程可以构建出不同表示（属性）的对象（通过&lt;strong&gt;改变构建步骤&lt;/strong&gt;）。&lt;!--more--&gt;在 GoF 书中的生成器模式 UML 类图如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/builder-pattern.png&quot; alt=&quot;Builder&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上图中，Product 是所要创建的复杂对象，ConcreteBuilder 类表示具体的生成器，它实现了 Builder 接口，负责组装构成最终对象的各部分。ConcreteBuilder 定义了&lt;strong&gt;构建过程&lt;/strong&gt;和&lt;strong&gt;对象组装机制&lt;/strong&gt;，就是如何用各部分、按照怎样的步骤去构造一个 Product 对象。ConcreteBuilder 还定义了 getResult() 方法，用于返回构建好的 Product 对象。然后 Director 则是负责通过使用 Builder 接口去构建最终所需的 Product 对象，就是做指挥的。&lt;/p&gt;

&lt;p&gt;以上是对经典的 GoF 生成器模式的解读，下面结合具体的例子加深理解。&lt;/p&gt;

&lt;h3 id=&quot;具体简单例子&quot;&gt;具体简单例子&lt;/h3&gt;

&lt;p&gt;在这个例子里会有这些参与者：Builder, Car, MotorCycle, Product, 以及 Director。其中，Car, MotorCycle 是实现了 Builder 接口的具体类。Builder 用于构建 Product 对象的各部分，Product 则是要被创建的复杂对象（小车或摩托车）。因为 Car 和 MotorCycle 都实现了 Builder 接口，所以需要实现接口中的方法，即 &lt;code&gt;startUpOperations()&lt;/code&gt;, &lt;code&gt;buildBody()&lt;/code&gt;, &lt;code&gt;insertWheels()&lt;/code&gt;, &lt;code&gt;addHeadLights()&lt;/code&gt;, &lt;code&gt;endOperations()&lt;/code&gt;, 和 &lt;code&gt;getVehicle()&lt;/code&gt; 方法。前五个方法好理解，对应载具的构建过程，开始，构建车身，装轮子，装头灯，收尾。而 &lt;code&gt;getVehicle()&lt;/code&gt; 方法，就是返回已构建好的载具。 然后还有 Director，它调用同一个 &lt;code&gt;construct()&lt;/code&gt; 方法去构建不同类型的载具。这个具体例子的类图如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/builder-pattern-vehicles.png&quot; alt=&quot;builder-pattern-vehicles&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;代码实现&quot;&gt;代码实现&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;import java.util.LinkedList;

// 公共接口
interface Builder {
	void startUpOperations();
	void buildBody();
	void insertWheels();
	void addHeadlights();
	void endOperations();

	/* 用于获取已经构建好的对象的方法。*/
	Product getVehicle();
}

// Car 类
class Car implements Builder {
	private String brandName;
	private Product product;

	public Car(String brand) {
		product = new Product();
		this.brandName = brand;
	}

	public void startUpOperations() {
		// 开始就设置品牌名称
		product.add(String.format(&quot;Car model is :%s&quot;, this.brandName));
	}

	public void buildBody() {
		product.add(&quot;This is a body of a Car&quot;);
	}

	public void insertWheels() {
		product.add(&quot;4 wheels are added&quot;);
	}

	public void addHeadlights() {
		product.add(&quot;2 Headlights are added&quot;);
	}

	public void endOperations() { // Nothing in this case
	}

	public Product getVehicle() {
		return product;
	}
}

// Motorcycle 类
class MotorCycle implements Builder {
	private String brandName;
	private Product product;

	public MotorCycle(String brand) {
		product = new Product();
		this.brandName = brand;
	}

	public void startUpOperations() { // Nothing in this case
	}

	public void buildBody() {
		product.add(&quot;This is a body of a Motorcycle&quot;);
	}

	public void insertWheels() {
		product.add(&quot;2 wheels are added&quot;);
	}

	public void addHeadlights() {
		product.add(&quot;1 Headlights are added&quot;);
	}

	public void endOperations() {
		// 添加品牌名称作为收尾
		product.add(String.format(&quot;Motorcycle model is :%s&quot;, this.brandName));
	}

	public Product getVehicle() {
		return product;
	}
}

// Product 类 
class Product {
	/*
	 * 你可以使用任何数据结构，这里使用
	 * LinkedList&amp;lt;String&amp;gt; 
	 */
	private LinkedList&amp;lt;String&amp;gt; parts;

	public Product() {
		parts = new LinkedList&amp;lt;String&amp;gt;();
	}

	public void add(String part) {
		// 添加部件
		parts.addLast(part);
	}

	public void showProduct() {
		System.out.println(&quot;\nProduct completed as below :&quot;);
		for (String part : parts)
			System.out.println(part);
	}
}

// Director 类 
class Director {
	Builder builder;

	// Director 知道如何使用 builder 以及调用步骤。
	public void construct(Builder builder) {
		this.builder = builder;
		builder.startUpOperations();
		builder.buildBody();
		builder.insertWheels();
		builder.addHeadlights();
		builder.endOperations();
	}
}

public class BuilderPatternExample {

	public static void main(String[] args) {
		System.out.println(&quot;***Builder Pattern Demo***&quot;);
		Director director = new Director();

		Builder fordCar = new Car(&quot;Ford&quot;);
		Builder hondaMotorycle = new MotorCycle(&quot;Honda&quot;);

		// 造小车 Car
		director.construct(fordCar);
		Product p1 = fordCar.getVehicle();
		p1.showProduct();

		// 造摩托 MotorCycle
		director.construct(hondaMotorycle);
		Product p2 = hondaMotorycle.getVehicle();
		p2.showProduct();
	}
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;输出结果：&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-console&quot;&gt;***Builder Pattern Demo***

Product completed as below :
Car model is :Ford
This is a body of a Car
4 wheels are added
2 Headlights are added

Product completed as below :
This is a body of a Motorcycle
2 wheels are added
1 Headlights are added
Motorcycle model is :Honda
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;q--a&quot;&gt;Q &amp;amp; A&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;使用生成器模式有什么好处?&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;你可以用生成器模式逐步构建复杂对象，并且可以改变构建步骤。通过隐藏构建复杂对象的细节（构建每部分的细节），加强了封装性。 Director 可以从 Builder 获取最终构建完成的 Product，在表面看了就好像只有一个方法（construct()）用于构建最终产品，其他的内部方法只是涉及构建具体的部分。&lt;/li&gt;
      &lt;li&gt;使用这种模式，同样的构建过程，可以产生不同的产品。&lt;/li&gt;
      &lt;li&gt;因为你可以改变构造步骤，所以你可以改变产品的内部表示。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;生成器模式的坏处？&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;不适用于处理可变对象（mutable object），即创建后可被修改的对象。&lt;/li&gt;
      &lt;li&gt;可能需要写些重复代码，例如不同的具体生成器有些代码类似或重复，某些情况下可能会有不好的影响，并可能成为&lt;em&gt;&lt;a href=&quot;https://blog.csdn.net/jiangpingjiangping/article/details/78067595&quot;&gt;反模式&lt;/a&gt;&lt;/em&gt;。&lt;/li&gt;
      &lt;li&gt;一个具体的生成器专用于产生某类产品，所以要生产另一类产品，就需要编写一个用于该类产品的具体生成器。&lt;/li&gt;
      &lt;li&gt;生成器模式只有在构建比较复杂的对象时用才有优势。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在上面例子中我可以使用抽象类而不是接口吗？&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;可以的。你可以使用抽象类，而不是用接口。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如何确定应该使用抽象类还是接口？&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;如果你想要一些集中的或是默认的行为，那么抽象类是更好的选择，因为这种情况下你可以提供一些默认的实现。另一方面，使用接口则需要从零开始实现，接口定义了某些规则/契约，强调应该做什么，但不强调怎么做。还有就是如果要考虑实现多继承，接口就更合适。 如果你要给接口添加一个新的方法，那么这个接口的所有实现都需要实现这个新方法，有点麻烦。但如果在抽象类中添加一个新方法，并有默认实现，那么旧代码不受影响。在 Java 8 引入了 &lt;code&gt;default&lt;/code&gt; 关键字在接口的用法，可以在接口里提供默认方法。&lt;/li&gt;
      &lt;li&gt;下面是抽象类更适用的场景：
        &lt;ul&gt;
          &lt;li&gt;想要在多个联系紧密的类之间共享代码&lt;/li&gt;
          &lt;li&gt;被继承的抽象类有很多公共方法或字段，或者它们当中需要非公有访问修饰符。&lt;/li&gt;
          &lt;li&gt;你想使用非静态或非 &lt;code&gt;final&lt;/code&gt; 字段，这样可以修改其所属对象的状态。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;接下来是使用接口更合适的场景：
        &lt;ul&gt;
          &lt;li&gt;希望一些不相关的类实现你的接口。&lt;/li&gt;
          &lt;li&gt;指定某种数据类型的行为，但是不关心如何实现。&lt;/li&gt;
          &lt;li&gt;想要适用多继承。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;上面例子中，在 Car 里，brand name 在第一步添加了，而在 MotorCycle 里， brand name 在最后一步添加，这是故意的吗？&lt;/p&gt;

    &lt;p&gt;是的。这是为了说明，每种具体生成器可以自由决定如何产生最终产品。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;为什么使用单独一个类作为 Director？应该可以使用客户端代码（client code）充当 Director 的角色啊。&lt;/p&gt;

    &lt;p&gt;这方面没有限制。上面的代码例子，将 Director 角色与客户端代码分离，但是接下来的例子会直接适用客户端代码做 Director。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;客户端代码（client code）是什么意思？&lt;/p&gt;

    &lt;p&gt;包含 main() 方法的类就是客户端代码（client code）。在 &lt;em&gt;Effective Java&lt;/em&gt; 一书的第 4 页，有三段话讲了术语 &lt;em&gt;exported API&lt;/em&gt; 以及 a &lt;em&gt;client&lt;/em&gt; of the API. 引用如下：&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;This book uses a few technical terms that are not defined in &lt;em&gt;The Java Language Specification&lt;/em&gt;. The term &lt;em&gt;exported API&lt;/em&gt;, or simply &lt;em&gt;API&lt;/em&gt;, refers to the classes, interfaces, constructors, members, and serialized forms by which a programmer accesses a class, interface, or package. (The term &lt;em&gt;API&lt;/em&gt;, which is short for &lt;em&gt;application programming interface&lt;/em&gt;, is used in preference to the otherwise preferable term &lt;em&gt;interface&lt;/em&gt; to avoid confusion with the language construct of that name.) A programmer who writes a program that uses an API is referred to as a &lt;em&gt;user&lt;/em&gt; of the API. A class whose implementation uses an API is a &lt;em&gt;client&lt;/em&gt; of the API.&lt;/p&gt;

      &lt;p&gt;Classes, interfaces, constructors, members, and serialized forms are collectively known as &lt;em&gt;API elements&lt;/em&gt;. An exported API consists of the API elements that are accessible outside of the package that defines the API. These are the API elements that any client can use and the author of the API commits to support. Not coincidentally, they are also the elements for which the Javadoc utility generates documentation in its default mode of operation. Loosely speaking, the exported API of a package consists of the public and protected members and constructors of every public class or interface in the package.&lt;/p&gt;

      &lt;p&gt;In Java 9, a &lt;em&gt;module system&lt;/em&gt; was added to the platform. If a library makes use of the module system, its exported API is the union of the exported APIs of all the packages exported by the library’s module declaration.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;前面提到改变构建步骤。能否演示一下通过改变构建步骤产生不同的最终产品？&lt;/p&gt;

    &lt;p&gt;下面的例子给出演示。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;改进版例子&quot;&gt;改进版例子&lt;/h3&gt;

&lt;p&gt;改进版例子做了如下修改：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;这次只关注 Car 作为最终产品。&lt;/li&gt;
  &lt;li&gt;定制 Car 的构建步骤包含这些：
    &lt;ul&gt;
      &lt;li&gt;开始的消息（startUpMessage)。&lt;/li&gt;
      &lt;li&gt;处理结束消息（endOperationsMessage）&lt;/li&gt;
      &lt;li&gt;确定车身材料（bodyType）&lt;/li&gt;
      &lt;li&gt;车轮数量（noOfWheels）&lt;/li&gt;
      &lt;li&gt;车头灯数量（noOfHeadLights）&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;客户端代码同时充当了 Director 的角色。&lt;/li&gt;
  &lt;li&gt;生成器的接口被重命名为 ModifiedBuilder， 除 constructCar() 和 getConstructedCar() 方法外，接口中的其他方法的返回类型都是 ModifiedBuilder，这样可以实现方法链（method chaining）。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;代码实现-1&quot;&gt;代码实现&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;// 公共接口
interface ModifiedBuilder {
	/*
	 * 所有这些方法的返回值类型都是 ModifiedBuilder。这样可以做链式调用
	 */
	ModifiedBuilder startUpOperations(String startUpMessage);
	ModifiedBuilder buildBody(String bodyType);
	ModifiedBuilder insertWheels(int noOfWheels);
	ModifiedBuilder addHeadlights(int noOfHeadLights);
	ModifiedBuilder endOperations(String endOperationsMessage);

	/* 组合部件制造最终产品。 */
	ProductClass constructCar();

	// 可选的方法：获取已构建的产品
	ProductClass getConstructedCar();
}

//Car 类
class CarBuilder implements ModifiedBuilder {
    // 默认起始消息
	private String startUpMessage = &quot;Start building the product&quot;;
    private String bodyType = &quot;Steel&quot;; // 默认车身类型
	private int noOfWheels = 4; // 默认车轮数量
	private int noOfHeadLights = 2; // 默认车头灯数量
	// 默认结束消息
	private String endOperationsMessage = &quot;Product creation completed&quot;;
	ProductClass product;

	@Override
	public ModifiedBuilder startUpOperations(String startUpMessage) {
		this.startUpMessage = startUpMessage;
		return this;
	}

	@Override
	public ModifiedBuilder buildBody(String bodyType) {
		this.bodyType = bodyType;
		return this;
	}

	@Override
	public ModifiedBuilder insertWheels(int noOfWheels) {
		this.noOfWheels = noOfWheels;
		return this;
	}

	@Override
	public ModifiedBuilder addHeadlights(int noOfHeadLights) {
		this.noOfHeadLights = noOfHeadLights;
		return this;
	}

	@Override
	public ModifiedBuilder endOperations(String endOperationsMessage) {
		this.endOperationsMessage = endOperationsMessage;
		return this;
	}

	@Override
	public ProductClass constructCar() {

		product = new ProductClass(this.startUpMessage, this.bodyType,
                                   this.noOfWheels, this.noOfHeadLights,
				this.endOperationsMessage);
		return product;
	}

    @Override
	public ProductClass getConstructedCar() {
		return product;
	}
}

// Product 类 
final class ProductClass {
	private String startUpMessage;
	private String bodyType;
	private int noOfWheels;
	private int noOfHeadLights;
	private String endOperationsMessage;

	public ProductClass(final String startUpMessage, String bodyType,
                        int noOfWheels, int noOfHeadLights,
			String endOperationsMessage) {
		this.startUpMessage = startUpMessage;
		this.bodyType = bodyType;
		this.noOfWheels = noOfWheels;
		this.noOfHeadLights = noOfHeadLights;
		this.endOperationsMessage = endOperationsMessage;
	}
	/*
	 * 没有使用 setter 方法，加强不可以变性。因为属性是私有，且没有 setter 方法，
	 * 所以不必要使用 final 关键字。
	 */
	@Override
	public String toString() {
		return &quot;Product Completed as:\n startUpMessage=&quot; + 
            startUpMessage + &quot;\n bodyType=&quot; + 
            bodyType + &quot;\n noOfWheels=&quot; + 
            noOfWheels + &quot;\n noOfHeadLights=&quot; + 
            noOfHeadLights + &quot;\n endOperationsMessage=&quot; + 
            endOperationsMessage;
	}
}

// Director 类 
public class BuilderPatternModifiedExample {

	public static void main(String[] args) {
		System.out.println(&quot;***Modified Builder Pattern Demo***&quot;);
		/*
		 * 构造一个定制的小车（通过使用 builder），注意步骤：
		 * 第1步：已必要的参数获取一个 builder 对象。
		 * 第2步：使用类似 setter 的方法设置可选字段。
		 * 第3步：调用 constructCar() 方法去获取最终生成的小车。
		 */
		final ProductClass customCar1 = new CarBuilder()
            .addHeadlights(5)
            .insertWheels(5)
            .buildBody(&quot;Plastic&quot;)
			.constructCar();
		System.out.println(customCar1);
		System.out.println(&quot;--------------&quot;);
		/*
		 * 用不同的步骤构造另一个定制小车（通过使用 builder）
		 */
		ModifiedBuilder carBuilder2 = new CarBuilder();
		final ProductClass customCar2 = carBuilder2
            .insertWheels(7)
            .addHeadlights(6)
            .startUpOperations(&quot;I am making my own car&quot;)
            .constructCar();
		System.out.println(customCar2);
		System.out.println(&quot;--------------&quot;);
		/*
		 * 错误，因为 customCar2 是 final 的
         * customCar2 = carBuilder2.insertWheels(70)
		 * .addHeadlights(6) .startUpOperations(&quot;I am making my own car&quot;)
		 * .constructCar(); System.out.println(customCar2);
		 */		
		// 验证 getConstructedCar() 方法
        
		final ProductClass customCar3 = carBuilder2.getConstructedCar();
		System.out.println(customCar3);
	}
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;输出结果：&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-console&quot;&gt;***Modified Builder Pattern Demo***
Product Completed as:
startUpMessage=Start building the product
bodyType=Plastic
noOfWheels=5
noOfHeadLights=5
endOperationsMessage=Product creation completed
--------------
Product Completed as:
startUpMessage=I am making my own car
bodyType=Steel
noOfWheels=7
noOfHeadLights=6
endOperationsMessage=Product creation completed
--------------
Product Completed as:
startUpMessage=I am making my own car
bodyType=Steel
noOfWheels=7
noOfHeadLights=6
endOperationsMessage=Product creation completed
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在改进版例子中，第 124 行，构建 &lt;code&gt;customCar1&lt;/code&gt;，逐步调用了 &lt;code&gt;addHeadLights()&lt;/code&gt;, &lt;code&gt;insertWheels()&lt;/code&gt;, &lt;code&gt;buildBody()&lt;/code&gt; 方法。 然后当构建 &lt;code&gt;customCar2&lt;/code&gt; 时，方法的调用顺序不同了，而没调用的方法，会取默认值。&lt;/p&gt;

&lt;h3 id=&quot;q--a-1&quot;&gt;Q &amp;amp; A&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;改进版例子中客户端代码用到 &lt;code&gt;final&lt;/code&gt; 关键字，但是 &lt;code&gt;ProductClass&lt;/code&gt; 的属性却没有用 &lt;code&gt;final&lt;/code&gt; 关键字，为什么？&lt;/p&gt;

    &lt;p&gt;在客户端代码使用 &lt;code&gt;final&lt;/code&gt; 关键字是为了提高不可修改性（immutability），但是在 &lt;code&gt;ProductClass&lt;/code&gt; 属性已经是私有且那个类没有 setter 方法，所以已经是不可修改了，不需要使用 &lt;code&gt;final&lt;/code&gt; 关键字。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;不可修改的对象有什么好处？&lt;/p&gt;

    &lt;p&gt;这样的对象一旦构建完成，就可以安全地共享，更重要的是它们是线程安全的（thread-safe），所以在多线程环境中省去了很多同步操作。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;何时应该考虑使用生成器模式？&lt;/p&gt;

    &lt;p&gt;当你需要创建一个复杂的对象，涉及到很多步骤，而且被创建的对象需要是不可修改的对象，可以考虑使用生成器模式。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;补充&quot;&gt;补充&lt;/h3&gt;

&lt;h4 id=&quot;静态嵌套类链式调用&quot;&gt;静态嵌套类，链式调用&lt;/h4&gt;

&lt;p&gt;这里补充 Effective Java 第三版里边 Item 2 所讲的 &lt;strong&gt;Consider a builder when faced with many constructor parameters&lt;/strong&gt; 的代码例子，因为觉得这里面的例子稍微高级一点，应用到静态嵌套类（不知道这样翻译准不准确，英文是 Static nested class）。 在说完 Telescoping constructor pattern (does not scale well!) 和 JavaBeans Pattern (allows inconsistency, mandates mutability) 缺点之后，Joshua Bloch 给出了一种 Builder Pattern，代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;// Builder Pattern
public class NutritionFacts {
    private final int servingSize;
    private final int servings;
    private final int calories;
    private final int fat;
    private final int sodium; // 钠
    private final int carbohydrate; // 碳水化合物
    
    // 用 Static nested class 作为 Builder
    // 放在这里面可以 convey 一种 ownership，
    // 说明这个 Builder 用于生成 NutritionFacts
    public static class Builder {
        // Required parameters 必须的参数
        private final int servingSize;
        private final int servings;
        
        // Optional parameters - initialized to default values
        // 可选参数，初始化为默认值
        private int calories     = 0;
        private int fat          = 0;
        private int sodium       = 0;
        private int carbohydrate = 0;
        
        public Builder(int servingSize, int servings) {
            this.servingSize = servingSize;
            this.servings    = servings;
        }
        
        // 表示各个构造步骤，返回 Builder 自身引用，形成 fluent API 链式调用
        public Builder calories(int val)
        	{ calories = val;  return this; }
        public Builder fat(int val)
        	{ fat = val;  return this; }
        public Builder sodium(int val)
        	{ sodium = val;  return this; }        
        public Builder carbohydrate(int val)
        	{ carbohydrate = val;  return this; }
        
        // 返回最终产品
        public NutritionFacts build() {
            return new NutritionFacts(this);
        }
    }
    
    // 私有构造函数
    private NutritionFacts(Builder builder) {
        servingSize  = builder.servingSize;
        servings     = builder.servings;
        calories     = builder.calories;
        fat          = builder.fat;
        sodium       = builder.sodium;
        carbohydrate = builder.carbohydrate;
    }
        
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;按上面的 Builder 实现，客户端代码可以这样写：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;NutritionFacts cocaCola = new NutritionFacts.Builder(240, 8).
    calories(100).sodium(35).carbohydrate(27).build();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样的链式调用，易写、易读，模仿了像 Python 或 Scala 中的命名参数（named optional parameters).&lt;/p&gt;

&lt;h4 id=&quot;适用于类继承体系结构&quot;&gt;适用于类继承体系结构&lt;/h4&gt;

&lt;p&gt;即抽象类有抽象 builder，具体类有具体的 builder，例如以下代码是一个抽象类，代表各种披萨：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;// Builder pattern for class hierarchies
public abstract class Pizza {
    public enum Topping { HAM, MUSHROOM, ONION, PEPPER, SAUSAGE }
    final Set&amp;lt;Topping&amp;gt; toppings;
    
    abstract static class Builder&amp;lt;T extends Builder&amp;lt;T&amp;gt;&amp;gt; {
        EnumSet&amp;lt;Topping&amp;gt; toppings = EnumSet.noneOf(Topping.class);
        public T addTopping(Topping topping) {
            toppings.add(Objects.requireNonNull(topping));
            return self();
        }
        abstract Pizza build();
        
        // Subclasses must override this method to return &quot;this&quot;
        protected abstract T self();
    }
    Pizza(Builder&amp;lt;?&amp;gt; builder) {
        toppings = builder.toppings.clone();  // See Item 50
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的 &lt;code&gt;Pizza.Builder&lt;/code&gt; 是带有&lt;em&gt;递归类型参数&lt;/em&gt;的泛型，加上抽象的 &lt;code&gt;self&lt;/code&gt; 方法，可以允许子类实现方法链式调用。因为 Java 没有 self 类型，这种做法是模仿 self 类型的习惯。(This workaround for the fact that Java lacks a self type is known as the &lt;strong&gt;simulated self-type idiom&lt;/strong&gt;.)&lt;/p&gt;

&lt;p&gt;然后接下来是两个具体的 &lt;code&gt;Pizza&lt;/code&gt; 子类：&lt;/p&gt;

&lt;p&gt;纽约披萨：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public class NyPizza extends Pizza {
    public enum Size { SMALL, MEDIUM, LARGE }
    private final Size size;
    
    public static class Builder extends Pizza.Builder&amp;lt;Builder&amp;gt; {
        private final Size size;
        
        // covariant return typing
        public Builder(Size size) {
            this.size = Objects.requiresNonNull(size);
        }
        @Override public NyPizza build() {
            return new NyPizza(this);
        }
        @Override protected Builder self() {
            return this;
        }
    }
    private NyPizza(Builder builder) {
        super(builder);
        size = builder.size;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;意式披萨：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public class Calzone extends Pizza {
    private final boolean sauceInside;
    
    public static class Builder extends Pizza.Builder&amp;lt;Builder&amp;gt; {
        private final boolean sanceInside = false; // Default
        
        // covariant return typing
        public Builder sauceInside() {
            sauceInside = true;
            return this;
        }
        @Override public Calzone build() {
            return new Calzone(this);
        }
        @Override protected Builder self() { return this; }
    }
    private Calzone(Builder builder) {
        super(builder);
        sauceInside = builder.sauceInside;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后客户端代码看起来是这样的：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;NyPizza pizza = new NyPizza.Builder(SAMLL)
    .addTopping(SAUSAGE).addTopping(ONION).buid();
Calzone calzone = new Calzone.Builder()
    .addTopping(HAM).sauceInside().build();
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;

&lt;p&gt;总的来说，当一个类的构造函数或者静态工厂有较多的参数时，生成器模式是一种好的选择，特别是有些参数是可选的，或者类型是相同的。【完结】&lt;/p&gt;

&lt;h3 id=&quot;参考&quot;&gt;参考&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;[Gamma95] Gamma, Erich, Richard Helm, Ralph Johnson, and John Vlissides. 1995. &lt;em&gt;Design Patterns: Elements of Reusable Object-Oriented Software.&lt;/em&gt; Reading, MA: Addison-Wesley. ISBN: 0201633612&lt;/li&gt;
  &lt;li&gt;Sarcar, Vaskaran. &lt;em&gt;Design Patterns in Java, Second Edition.&lt;/em&gt; Apress, 2019&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://springframework.guru/gang-of-four-design-patterns/builder-pattern/&quot;&gt;Springframework guru: Builder Pattern&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Joshua Block. &lt;em&gt;Effective Java, Third Edition.&lt;/em&gt; Addison-Wesley, 2018&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/jiangpingjiangping/article/details/78067595&quot;&gt;设计模式杂谈——模式与反模式之争&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;更新记录：&lt;/p&gt;

  &lt;p&gt;2020年3月13日 下午3点13分 修正一些错别字，整理一下代码格式，和替换注释为中文。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Sun, 02 Feb 2020 18:42:00 +0000</pubDate>
        <link>https://zwt.io/2020/02/02/builder-pattern-in-depth/</link>
        <guid isPermaLink="true">https://zwt.io/2020/02/02/builder-pattern-in-depth/</guid>
        
        <category>Design Pattern</category>
        
        <category>设计模式</category>
        
        
      </item>
    
  </channel>
</rss>
